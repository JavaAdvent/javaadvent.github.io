---
id: 22
title: How and Why is Unsafe used in Java?
date: 2014-12-11T18:35:00+00:00
author: gpanther
layout: post
permalink: /2014/12/how-and-why-is-unsafe-used-in-java.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Peter Lawrey
blogger_permalink:
  - /2014/12/how-and-why-is-unsafe-used-in-java.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/7818632041101066535
categories:
  - 2014
  - Expect the unexpected
  - java
  - java advent 2014
  - low latency
  - memory mapped files
  - performance counters
  - unsafe
---
<h3>Overview</h3>sun.misc.Unsafe has been in Java from at least as far back as Java 1.4 (2004). &nbsp;In Java 9, Unsafe will be hidden along with many other, for-internal-use classes. to improve the maintainability of the JVM. &nbsp;While it is still unclear exactly what will replace Unsafe, and I suspect it will be more than one thing which replaces it, it raises the question, why is it used at all?<br /><br /><h3>Doing things which the Java language doesn't allow but are still useful.</h3>Java doesn't allow many of the tricks which are available to lower level languages. &nbsp;For most developers this is very good thing, and it not only saves you from yourself, it also saves you from your co-workers. &nbsp;It also makes it easier to import open source code because you know there is limits to how much damage they can do. &nbsp;Or at least there is limits to how much you can do accidentally. If you try hard enough you can still do damage. <br /><br />But why would you even try, you might wonder? &nbsp;When building libraries many (but not all) of the methods in Unsafe are useful and in some cases, there is no other way to do the same thing without using JNI, which is even more dangerous and you lose the "compile once, run anywhere"<br /><br /><h3>Deserialization of objects</h3><div>When deserializing or building an object using a framework, you make the assumption you want to reconstitute an object which existed before. &nbsp;You expect that you will use reflection to either call the setters of the class, or more likely set the internal fields directly, even the final fields. &nbsp;The problem is you want to create an instance of an object, but you don't really need a constructor as this is likely to only make things more difficult and have side effects.</div><div><br /></div><div><pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: 'DejaVu Sans Mono';"><pre style="font-family: 'DejaVu Sans Mono';"><span style="color: #cc7832;">public class </span>A <span style="color: #cc7832;">implements </span>Serializable {<br />    <span style="color: #cc7832;">private final int </span><span style="color: #9876aa;">num</span><span style="color: #cc7832;">;</span><span style="color: #cc7832;"><br /></span><span style="color: #cc7832;">    public </span>A(<span style="color: #cc7832;">int </span>num) {<br />        System.<span style="color: #9876aa; font-style: italic;">out</span>.println(<span style="color: #a5c25c;">"Hello Mum"</span>)<span style="color: #cc7832;">;</span><br/><span style="color: #cc7832;">        this</span>.<span style="color: #9876aa;">num </span>= num<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">    </span>}<br /><br />    <span style="color: #cc7832;">public int </span><span style="color: #ffc66d;">getNum</span>() {<br />        <span style="color: #cc7832;">return </span><span style="color: #9876aa;">num</span><span style="color: #cc7832;">;</span><span style="color: #cc7832;"><br />    </span>}<br />}</pre></pre></div><div><br /></div>In this class, you should be able to rebuild and set the final field, but if you have to call a constructor and it might do things which don't have anything to do with deserialization. &nbsp;For these reasons many libraries use Unsafe to create instances without calling a constructor<br /><br /><pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: 'DejaVu Sans Mono';">Unsafe unsafe = <span style="font-style: italic;">getUnsafe</span>()<span style="color: #cc7832;">;</span><br />Class aClass = A.<span style="color: #cc7832;">class;</span><br />A a = (A) unsafe.allocateInstance(aClass)<span style="color: #cc7832;">;</span></pre><br />Calling allocateInstance avoids the need to call the appropriate constructor, when we don't need one.<br /><br /><h3>Thread safe access to direct memory</h3>Another use for Unsafe is thread safe access to off heap memory. &nbsp;ByteBuffer gives you safe access to off heap or direct memory, however it doesn't have any thread safe operations. &nbsp;This is particularly useful if you want to share data between processes.<br /><br /><pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: 'DejaVu Sans Mono'; font-size: 11pt;"><span style="color: #cc7832;">import</span><span style="color: #cc7832;"> </span>sun.misc.Unsafe<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">import </span>sun.nio.ch.DirectBuffer<span style="color: #cc7832;">;</span><span style="color: #cc7832;"><br /></span><br /><span style="color: #cc7832;">import </span>java.io.File<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">import </span>java.io.IOException<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">import </span>java.io.RandomAccessFile<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">import </span>java.lang.reflect.Field<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">import </span>java.nio.MappedByteBuffer<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">import </span>java.nio.channels.FileChannel<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;"><br /></span><span style="color: #cc7832;">public class </span>PingPongMapMain {<br />    <span style="color: #cc7832;">public static void </span><span style="color: #ffc66d;">main</span>(String... args) <span style="color: #cc7832;">throws </span>IOException {<br />        <span style="color: #cc7832;">boolean </span>odd<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">        switch </span>(args.<span style="color: #9876aa;">length </span>&lt; <span style="color: #6897bb;">1 </span>? <span style="color: #a5c25c;">"usage" </span>: args[<span style="color: #6897bb;">0</span>].toLowerCase()) {<br />            <span style="color: #cc7832;">case </span><span style="color: #a5c25c;">"odd"</span>:<br />                odd = <span style="color: #cc7832;">true;</span><br /><span style="color: #cc7832;">                break;</span><br /><span style="color: #cc7832;">            case </span><span style="color: #a5c25c;">"even"</span>:<br />                odd = <span style="color: #cc7832;">false;</span><br /><span style="color: #cc7832;">                break;</span><br /><span style="color: #cc7832;">            default</span>:<br />                System.<span style="color: #9876aa; font-style: italic;">err</span>.println(<span style="color: #a5c25c;">"Usage: java PingPongMain [odd|even]"</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">                return;</span><span style="color: #cc7832;">        </span>}<br />        <span style="color: #cc7832;">int </span>runs = <span style="color: #6897bb;">10000000</span><span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">        long </span>start = <span style="color: #6897bb;">0</span><span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">        </span>System.<span style="color: #9876aa; font-style: italic;">out</span>.println(<span style="color: #a5c25c;">"Waiting for the other odd/even"</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">        </span>File counters = <span style="color: #cc7832;">new </span>File(System.<span style="font-style: italic;">getProperty</span>(<span style="color: #a5c25c;">"java.io.tmpdir"</span>)<span style="color: #cc7832;">, </span><span style="color: #a5c25c;">"counters.deleteme"</span>)<span style="color: #cc7832;">;</span><span style="color: #cc7832;">        </span>counters.deleteOnExit()<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;"><br /></span><span style="color: #cc7832;">        try </span>(FileChannel fc = <span style="color: #cc7832;">new </span>RandomAccessFile(counters<span style="color: #cc7832;">, </span><span style="color: #a5c25c;">"rw"</span>).getChannel()) {<br />            MappedByteBuffer mbb = fc.map(FileChannel.MapMode.<span style="color: #9876aa; font-style: italic;">READ_WRITE</span><span style="color: #cc7832;">, </span><span style="color: #6897bb;">0</span><span style="color: #cc7832;">, </span><span style="color: #6897bb;">1024</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">            long </span>address = ((DirectBuffer) mbb).address()<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">            for </span>(<span style="color: #cc7832;">int </span>i = -<span style="color: #6897bb;">1</span><span style="color: #cc7832;">; </span>i &lt; runs<span style="color: #cc7832;">; </span>i++) {<br />                <span style="color: #cc7832;">for </span>(<span style="color: #cc7832;">; ; </span>) {<br />                    <span style="color: #cc7832;">long </span>value = <span style="color: #9876aa; font-style: italic;">UNSAFE</span>.getLongVolatile(<span style="color: #cc7832;">null, </span>address)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">                    boolean </span>isOdd = (value &amp; <span style="color: #6897bb;">1</span>) != <span style="color: #6897bb;">0</span><span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">                    if </span>(isOdd != odd)<br />                        <span style="color: grey;">// wait for the other side.</span><br /><span style="color: grey;">                        </span><span style="color: #cc7832;">continue;</span><br /><span style="color: #cc7832;">                    </span><span style="color: grey;">// make the change atomic, just in case there is more than one odd/even process</span><br /><span style="color: grey;">                    </span><span style="color: #cc7832;">if </span>(<span style="color: #9876aa; font-style: italic;">UNSAFE</span>.compareAndSwapLong(<span style="color: #cc7832;">null, </span>address<span style="color: #cc7832;">, </span>value<span style="color: #cc7832;">, </span>value + <span style="color: #6897bb;">1</span>))<br />                        <span style="color: #cc7832;">break;</span><br /><span style="color: #cc7832;">                </span>}<br />                <span style="color: #cc7832;">if </span>(i == <span style="color: #6897bb;">0</span>) {<br />                    System.<span style="color: #9876aa; font-style: italic;">out</span>.println(<span style="color: #a5c25c;">"Started"</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">                    </span>start = System.<span style="font-style: italic;">nanoTime</span>()<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">                </span>}<br />            }<br />        }<br />        System.<span style="color: #9876aa; font-style: italic;">out</span>.printf(<span style="color: #a5c25c;">"... Finished, average ping/pong took %,d ns%n"</span><span style="color: #cc7832;">,</span><br /><span style="color: #cc7832;">                </span>(System.<span style="font-style: italic;">nanoTime</span>() - start) / runs)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">    </span>}<br /><br />    <span style="color: #cc7832;">static final </span><span style="background-color: #424445;">Unsafe</span> <span style="color: #9876aa; font-style: italic;">UNSAFE</span><span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;"><br /></span><span style="color: #cc7832;">    static </span>{<br />        <span style="color: #cc7832;">try </span>{<br />            Field theUnsafe = <span style="background-color: #424445;">Unsafe</span>.<span style="color: #cc7832;">class</span>.getDeclaredField(<span style="color: #a5c25c;">"theUnsafe"</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">            </span>theUnsafe.setAccessible(<span style="color: #cc7832;">true</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">            </span><span style="color: #9876aa; font-style: italic;">UNSAFE </span>= (<span style="background-color: #424445;">Unsafe</span>) theUnsafe.get(<span style="color: #cc7832;">null</span>)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">        </span>} <span style="color: #cc7832;">catch </span>(Exception e) {<br />            <span style="color: #cc7832;">throw new </span>AssertionError(e)<span style="color: #cc7832;">;</span><br /><span style="color: #cc7832;">        </span>}<br />    }<br />}</pre><br />When you run this in two programs, one with <i>odd</i> and the other with <i>even</i>. You can see that each process is changing data via &nbsp;persisted shared memory. <br /><br />In each program it maps the same are of the disks cache into the process. &nbsp;There is actually only one copy of the file in memory. &nbsp;This means the memory can be shared, provided you use thread safe operations such as the volatile and CAS operations.<br /><br />The output on an i7-3970X is<br /><br />Waiting for the other odd/even<br />Started<br />... Finished, average ping/pong took 83 ns<br /><div><br /></div>That is 83 ns round trip time between two processes. When you consider System V IPC takes around 2,500 ns and IPC volatile instead of persisted, that is pretty quick.<br /><br /><h3>Is using Unsafe suitable for work?</h3><div>I wouldn't recommend you use Unsafe directly. &nbsp;It requires far more testing than natural Java development. &nbsp;For this reason I suggest you use a library where it's usage has been tested already. &nbsp;If you wan to use Unsafe yourself, I suggest you thoughly test it's usage in a stand alone library. &nbsp;This limits how Unsafe is used in your application and give syou a safer, Unsafe.</div><div><br /></div><h3>Conclusion</h3><div>It is interesting that Unsafe exists in Java, and you might to play with it at home. &nbsp;It has some work applications especially in writing low level libraries, but in general it is better to use a library which uses Unsafe which has been tested than use it directly yourself.</div><div><br /></div><h3>About the Author.</h3><div>Peter Lawrey has the most Java answers on StackOverflow. He is the founder of the <a href="https://plus.google.com/communities/107178245817384004088">Performance Java User's Group</a>, and lead developer of <a href="https://github.com/OpenHFT/Chronicle-Queue">Chronicle Queue</a> and <a href="https://github.com/OpenHFT/Chronicle-Map">Chronicle&nbsp;Map</a>, two libraries which use Unsafe to share persisted data between processes.</div>