---
id: 72
title: 'Java &#8211; far sight look at JDK 8'
date: 2012-12-17T19:14:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/java-far-sight-look-at-jdk-8/
permalink: /2012/12/java-far-sight-look-at-jdk-8.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Olimpiu Pop
blogger_permalink:
  - /2012/12/java-far-sight-look-at-jdk-8.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/2863035577160730449
categories:
  - 2012
  - collections
  - iteration
  - java
  - java closures
  - jdk 8
  - lambda
---
<div dir="ltr" style="text-align: left;"><div dir="ltr" style="text-align: left;">The world is changing slowly but surely. After the changes that gave java a fresher look with JDK 7, the java community is looking forward to the rest of the improvements that will come with JDK 8 and probably JDK 9. The targeted purpose of JDK 8 was to fill in the gaps in the implementation of JDK 7 - part  of the remaining puzzle pieces laking from this implementation, that should be available for the broad audience by in late 2013 is to improve and boost the language in three particular directions:    <br /><ul><li>productivity</li><li>performance</li><li>modularity</li></ul>So from next year, java will run everywhere (mobile, cloud, desktop, server etc.), but in an improved manner. In what follows I will provide a short overview of what to expect from 2013 - just in time for New Year's Resolutions - afterwards I will focus mainly on productivity side with emphasis on project lambda and  how will its introduction affect the way we code. <br /><br /><strong>Productivity</strong> <br /><strong><br /></strong>In regards of productivity JDK 8 targets two main areas:       - collections - a more facile way to interact with collections through literal extensions brought to the language  - annotations - enhanced support for annotations, allowing writting them in contexts where are currently illegal (e.g. primitives) <br /><br /><strong>Performance</strong> <br /><strong><br /></strong>The addition of the Fork/Join framework to JDK 7, was the first step that java took in the direction of multicore CPUs. JDK 8 takes this road even further by bringing closures' support to java (lambda expression, that is).  Probably the most affected part of java will be the Collections part, the closures combined with the newly added interfaces and functionalities pushing the java containers to the next level. Besides the more readable and  shorter code to be written, by providing to the collections a lambda expression that will be executed internally the platform can take advantage of multicore processors.  <br /><br /><strong>Modularity</strong> <br /><strong><br /></strong>One of the most interresting pieces for the community was project jigsaw: "The goal of this Project is to design and implement a standard module system for the  Java SE Platform, and to apply that system to the Platform itself and to the JDK.". I am using past tense because, for the those of us that were hoping to get rid of the classpaths and classloaders, we have to postpone our exciment for Java 9, as for that point of time was also project jigsaw <a href="http://www.blogger.com/"><span></span>postponed<span></span></a>. <br />To have a clearer picture of how the remaning Java Roadmap 2013:<br /><br />2013/01/31 M6 Feature Complete<br />2013/02/21 M7 Developer Preview<br />2013/07/05 M8 Final Release Candidate<br />2013/09/09 GA General Availability<br /><br />Besides project <a href="http://openjdk.java.net/projects/jigsaw/">jigsaw </a>another big and exciting change that will come (in this version), is the support for closures. Provided through the help of lambda expressions they will improve key points of the JDK. <br /><br /><strong>Lambdas</strong><br /><br /><em>Getting started</em><br /><em><br /></em>First and first of all one should get a lambda enabled SDK. In this direction there are two ways to obtain one:<br /><br />&nbsp;* the one intended for the brave ones: build it from the <a href="http://hg.openjdk.java.net/lambda/lambda">sources&nbsp;</a><br />&nbsp;* the convenient one: downloading an already compiled version of the <a href="http://jdk8.java.net/lambda/">SDK&nbsp;</a><br /><br />&nbsp;Initially I started with building it from the sources, but due to the lack of time and too many warnings related to environment variables, I opted for the lazy  approach and took the already existing JDK. The other important tool is a text editor to write the code. As it happened until now, tipically first came the JDK   release and after a period of time, an enabled IDE came out. This time it is different, maybe also due to the transparency and the broad availability of the SDK   through openjdk. Some days ago, the first Java 8 enabled IDE was realesed by JetBrain. So IntelliJ IDEA <a href="http://www.jetbrains.com/idea/download/index.html">version </a>12 is the first IDE to provide support for JDK 8,  besides are improvements? So for testing purposes I used IntelliJ 12 Community Edition together with JDK 8 b68, on a Windows 7, x64 machine. For those of you that prefer Netbeans, a nightly build with lambda support is available for <a href="http://bertram2.netbeans.org:8080/job/jdk8lambda/lastSuccessfulBuild/artifact/nbbuild/">download</a>.<br /><br /><em> Adjusting to the appropriate mindset. </em><br /><em><br /></em>Before starting to write improved and cleaner code using the newly provided features, one must get a grasp on a couple new concepts - I needed to, anyway.  <br /><ul><li> What is a lambda expression?  The easiest way to see a lambda expression is just like a method: "it provides a list of formal parameters and a body—an expression or block—  expressed in terms of those parameters.The parameters of a lambda expression can be either declared or inferred, when the formal parameters have inferred types,  then these types are derived from the functional interface type targeted by the lambda expression. From the point of view of the returned value, a lambda   expression can be void compatible - they don't return anything or value compatible - if any given execution path returns a value. <br />   Examples of lambda expressions:   <code>  <pre>(a) (int a, int b) -&gt; a + b<br />  <br />(b) (int a, int b) -&gt; {<br /> if (a &gt; b) {<br />     return a;<br /> } else if (a == b) {<br />     return a * b;<br /> } else {<br />     return b;<br /> }<br />   }<br />  </pre></code> </li><li>What is a functional interface?  A functional interface is an interface that contains just one abstract method, hence represents a single method contract. In some   situations, the single method may have the form of multiple methods with override-equivalent signatures, in this case all the methods   represent a single method. Besides the typical way of creating an interface instance by creating and instantiating a class, functional   interface instances can be created also by usage of lambda expressions, method or constructor references. <br />   Example of functional interfaces:     <code>  <pre>// custom built functional interface<br />public interface FuncInterface {<br />   public void invoke(String s1, String s2);<br />}<br />  </pre></code>     Example of functional interfaces from the JAVA API:       <code>  <pre>  java.lang.Comparable<br />  java.lang.Runnable<br />  java.util.concurrent.Callable<br />  java.awt.event.ActionListener<br />  </pre></code>     So let's see how the starting of a thread might change in the future: <br />OLD WAY:      <code>  <pre>   new Thread(new Runnable() {<br />            @Override<br />            public void run() {<br />                for (int i=0; i&lt; 9; i++) {<br />                    System.out.println(String.format("Message #%d from inside the thread!", i));<br />                }<br />            }<br />        }).start();<br /></pre></code>    NEW WAY:      <code>  <pre>   new Thread(() -&gt; {<br />        for (int i=0; i&lt; 9; i++) {<br />           System.out.println(String.format("Message #%d from inside the thread!", i));<br />        }<br />    }).start();<br /> </pre></code>  Even if I didn't write for some time any java Swing, AWT related functionality I have to admit that    lambdas will give a breath of fresh air to the Swing developers      Action listener addition:         <code>  <pre>  JButton button = new JButton("Click");<br /><br />  // NEW WAY:<br />  button.addActionListener( (e) -&gt; {<br />      System.out.println("The button was clicked!");<br />  });<br />  <br />  // OLD WAY:<br />  button.addActionListener(new ActionListener() {<br />            @Override<br />            public void actionPerformed(ActionEvent e) {<br />                System.out.println("The button was clicked using old fashion code!");<br />            }<br />        });<br />  </pre></code> </li><li> Who/What is SAM?    SAM stands for Single Abstract Method, so to cut some corners we can say that SAM == functional interface.   Even if in the initial specification, also abstract classes with only one abstract method were considered SAM types,   some people found/guessed also the reason why.&nbsp;</li><li>Method/Constructor referencing</li>The lambdas sound all nice and all? But somehow the need for functional interface is somehow to some extend restrictive - does this    mean that I can use only interfaces that contain a single abstract method? Not really - JDK 8 provides an aliasing     mechanism that allows "extraction" of methods from classes or objects. This can be done by using the newly added ::    operator. It can be applied on classes - for extraction of static methods or on objects for extraction of methods.    The same operator can be used for constructors also. <br /> Referencing:         <code>  <pre>interface ConstructorReference<t> {<br />    T constructor();<br />}<br /><br />interface  MethodReference {<br />    void anotherMethod(String input);<br />}<br /><br />public class ConstructorClass {<br />    String value;<br /><br />    public ConstructorClass() {<br />        value = "default";<br />    }<br /><br />    public static void method(String input) {<br />        System.out.println(input);<br />    }<br /><br />    public void nextMethod(String input) {<br />        // operations<br />    }<br /><br />    public static void main(String... args) {<br />        // constructor reference<br />        ConstructorReference<constructor> reference = ConstructorClass::new;<br />        ConstructorClass cc = reference.constructor();<br /><br />        // static method reference<br />        MethodReference mr = cc::method;<br /><br />        // object method reference<br />        MethodReference mr2 = cc::nextMethod;<br /><br />        System.out.println(cc.value);<br />    }<br />}<br /></constructorclass></t></pre></code><li>Default methods in interfaces</li>This means that from version 8, java interfaces can contain method bodies, so to put it simple java will support multiple inheritance without the headaches that usually come with it. Also, by providing default    implementations for interface methods one can assure ensure that adding a new method will not create chaos in the implementing classes. JDK 8 added default methods to interfaces like java.util.Collection or java.util.Iterator and    through this it provided a mechanism to better use lambdas where it is really needed. <br />  Notable interfaces added:  <code> <pre>   java.util.stream.Streamable<br />   java.util.stream.Stream<br /></pre></code>  <strong>Improved collections' interaction</strong>   In my opinion all the changes that come with project lambda are great additions to the language, that will make it align with the current day standards and make it simpler and    leaner but probably the change that will have the biggest productivity impact and the biggest cool + wow effect is definitely the revamping of the collections framework. No, there    is no Collection 2 framework, we still have to cope with type erasure for now, but java will make another important shift: from external to internal iteration. By doing so, it provides    the developer the mechanism to filter and aggregate collections in an elegant manner and besides this to push for more efficiency. By providing a lambda expression that will be executed    internally, so multicore processors can be used to their full power. Let's consider the following scenarios:    <br />    a. Considering a list of strings, select all of them that are uppercased written. How would this be written?           OLD WAY: <code> </code><br /><pre><code>  <br /> //.....<br /> <br /> List<string> inputList = new LinkedList&lt;&gt;();<br /> List<string> upper = new LinkedList&lt;&gt;();<br /><br /> // add elements<br /><br /> for (String currentValue : inputList) {<br />   if (currentValue != null &amp;&amp; currentValue.matches("[A-Z0-9]*")) {<br />       upper.add(currentValue);<br />   }<br /> }<br /><br /> System.out.println(upper);<br />   </string></string></code></pre><code></code>   //.....         NEW WAY: <code> <pre>  <br /> //.....<br /> inputList.stream().filter(x -&gt; (x != null &amp;&amp; x.matches("[A-Z0-9]*"))).into(upper);<br /></pre></code> <br /> b. Consider that you would like to change all the extracted characters to lowercase. Using the JDK8 way this would look like this: <code> </code><br /><pre><code> <br /> // .....<br />  inputList.stream().filter(x -&gt; (x != null &amp;&amp; x.matches("[A-Z0-9]*"))).map(String::toLowerCase).into(upper);<br /></code></pre><code></code><br />    c. And how about finding out the number of characters from the selected collection <code> </code><br /><pre><code> <br /> // .....  <br />  <br /> int sumX = inputList.stream().filter(x -&gt; (x != null &amp;&amp; x.matches("[A-Z0-9]*"))).map(String::length).reduce(0, Integer::sum);<br /> </code></pre><code></code>   Used methods: <code> <pre> default Stream<e> stream() // java.util.Collection<br /> Stream<t> filter(Predicate predicate) // java.util.stream.Stream<br /> IntStream map(IntFunction mapper) //java.util.stream.Stream<br /></t></e></pre></code><br /> d. What if I would like to take each element from a collection and print it?   <code> </code><br /><pre><code> //OLD WAY:<br />for (String current : list) {<br />  System.out.println(current);<br />}<br /> <br /> //NEW WAY:<br /> list.forEach(x -&gt; System.out.println(x));<br /></code></pre><code></code> <br /> Besides the mentioned functionality, JDK 8 has are other interesting news also, but for brevity reasons I will stop here. More information about it can be found on the JDK 8<a href="http://jdk8.java.net/lambda/"> Project lambda</a> site or the webpage of the <a href="http://www.jcp.org/en/jsr/detail?id=337">JSR 337.</a><br />  To conclude, Java is moving forward and I personally like the direction it is heading, another point of interest would be to point of time when library developers start adopting JDK 8 too. That will be for  sure interesting.     Thank you for your time and patience, I wish you a merry Christmas. <br /><br /><b>Resources</b><br /><b><br /></b>Brian Goetz resource folder: <a href="http://cr.openjdk.java.net/~briangoetz/lambda">http://cr.openjdk.java.net/~briangoetz/lambda</a><br />Method/constructor references: <a href="http://doanduyhai.wordpress.com/2012/07/14/java-8-lambda-in-details-part-iii-method-and-constructor-referencing">http://doanduyhai.wordpress.com/2012/07/14/java-8-lambda-in-details-part-iii-method-and-constructor-referencing</a><br />  </ul><div><br /></div></div><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a>tocontribute!</em><br /><em>Disclaimer: This post was based on the JDK8 lambda enabled SDK from 15. December 2012, some features might be subject to change. </em></div>