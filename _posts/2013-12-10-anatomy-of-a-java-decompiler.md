---
id: 50
title: Anatomy of a Java Decompiler
date: 2013-12-10T08:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/anatomy-of-a-java-decompiler/
permalink: /2013/12/anatomy-of-a-java-decompiler.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Mike Strobel
blogger_permalink:
  - /2013/12/anatomy-of-java-decompiler.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/8102289133489793686
categories:
  - 2013
  - java
  - JVM
---
<div dir="ltr" style="text-align: left;"><p><em>Mike Strobel &amp; Lee Benfield</em></p> <!-- LB - Scroll down to 'what's with all these lists…. when you want to add graphs -->  <p>A decompiler, simply put, attempts to reverse the transformation of source code to object code.  But there are many interesting complexities&mdash;Java source code is structured; bytecode certainly isn't.  Moreover, the transformation isn't one-to-one: two different Java programs may yield identical bytecode.  We need to apply heuristics in order to get a reasonable approximation of the original source.</p> <h3>(A Tiny) Bytecode Refresher</h3> <p>In order to understand how a decompiler works, it's necessary to understand the basics of byte code.  If you’re already familiar with byte code, feel free to skip ahead to the next section.</p> <p>The JVM is a <em>stack-based machine</em> (as opposed to a register-based machine), meaning instructions operate on an evaluation stack.  Operands may be popped off the stack, various operations performed, and the results pushed back onto the stack for further evaluation.  Consider the following method:</p> <pre><br />public static int plus(int a, int b) {<br />    int c = a + b;<br />    return c;<br />}<br /></pre>  <p><sup><em>Note: All byte code shown in this article is output from <code>javap</code>, e.g., <code>javap -c -p MyClass</code>.</em></sup></p> <pre><br />public static int plus(int, int);<br /> Code:<br />  stack=2, locals=3, arguments=2<br />   0: iload_0    // load ‘x’ from slot 0, push onto stack<br />   1: iload_1    // load ‘y’ from slot 1, push onto stack<br />   2: iadd       // pop 2 integers, add them together, and push the result<br />   3: istore_2   // pop the result, store as ‘sum’ in slot 2<br />   4: iload_2    // load ‘sum’ from slot 2, push onto stack<br />   5: ireturn    // return the integer at the top of the stack<br /></pre>  <p><sup><em>(Comments added for clarity.)</em></sup></p> <p>A method's local variables (including arguments to the method) are stored in what the JVM refers to as the <em>local variable array</em>.  We'll refer to a value (or reference) stored in location <code>#x</code> in the local variable array as `slot #x' for brevity (see <a href="http://docs.oracle.com/javase/specs/jvms/se5.0/html/Overview.doc.html#15722">JVM Specification &#x00A7;3.6.1</a>).</p> <p>For instance methods, the value in slot #0 is always the <code>this</code> pointer.  Then come the method arguments, from left to right, followed by any local variables declared within the method.  In the example above, the method is static, so there is no <code>this</code> pointer; slot #0 holds parameter <code>x</code>, and slot #1 holds parameter <code>y</code>.  The local variable <code>sum</code> resides in slot #2.</p> <p>It's interesting to note that each method has a max stack size and max local variable storage, both of which are determined at compile time.</p> <p>One thing that's immediately obvious from here, which you might not initially expect, is that the compiler made no attempt to optimise the code.   In fact, <code>javac</code> almost never emits optimized bytecode.  This has multiple benefits, including the ability to set breakpoints at most locations: if we were to eliminate the redundant load/store operations, we'd lose that capability.  Thus, most of the heavy lifting is performed at runtime by a just-in-time (JIT) compiler.</p> <h3>Decompiling</h3> <p>So, how can you take unstructured, stack-based byte code and translate it back into structured Java code?  One of the first steps is usually to get rid of the operand stack, which we do by mapping stack values to variables and inserting the appropriate load and store operations.</p> <p>A 'stack variable' is only assigned once, and consumed once.  You might note that this will lead to a <em>lot</em> of redundant variables&mdash;more on this later!  The decompiler may also reduce the byte code into an even simpler instruction set, but we won't consider that here.</p> <!-- LB: I'm suing this notation rather than Stack_0_2 etc for brevity, and so we can make screens wider -->  <p>We'll use the notation <code>s0</code> (etc.) to represent <em>stack variables</em>, and <code>v0</code> to represent true local variables referenced in the original byte code (and stored in slots).</p> <!-- LB: Mou's tables aren't quite good enough, so I've used raw html.  Yes, it's a pain.  But it comes out pretty nice.  Keep them narrow enough that nothing wraps, even on a 1/2 screen mou preview. -->    <table style="border: 0px; font-size: 9pt;"><tr><th style="padding: 0em 2em 0em 0em; text-align: left;"/><th style="padding: 0em 2em 0em 0em; text-align: left;">Bytecode</th><th style="padding: 0em 2em 0em 0em; text-align: left;">Stack Variables</th><th style="padding: 0em 0em 0em 0em; text-align: left;">Copy Propagation</th></tr><tr><td valign="top">0<br/>1<br/>2<br/>3<br/>4<br/>5<br/></td> <td valign="top" style="padding: 0em 2em 0em 0em;">iload_0<br/>iload_1<br/>iadd<br/>istore_2<br/>iload_2<br/>ireturn<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;">s0 = v0<br/>s1 = v1<br/>s2 = s0 + s1<br/>v2 = s2<br/>s3 = v2<br/>return s3<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;"><br/><br/><br/>v2 = v0 + v1<br/><br/>return v2<br/></td></tr></table>  <p>We get from <em>bytecode</em> to <em>variables</em> by assigning identifiers to every value pushed or popped, e.g., <code>iadd</code> pops two operands to add and pushes the result.</p> <p>We then apply a technique called <em>copy propagation</em> to eliminate some of the redundant variables.  Copy propagation is a form of inlining in which references to variables are simply replaced with the assigned value, provided the transformation is valid.</p> <p>What do we mean by "valid"?  Well, there are some important restrictions.  Consider the following:</p> <pre><code>0: s0 = v1<br />1: v1 = s4<br />2: v2 = s0 &lt;-- s0 cannot be replaced with v1<br /></code></pre> <p>Here, if we were to replace <code>s0</code> with <code>v0</code>, the behavior would change, as the value of <code>v0</code> changes after <code>s0</code> is assigned, but before it is consumed.  To avoid these complications, we only use copy propagation to inline variables that are assigned <em>exactly once</em>.</p> <p>One way to enforce this might be to track all stores to non-stack variables, i.e., we know that <code>v1</code> is assigned v1<sub>0</sub> at #0, and also v1<sub>1</sub> at #2.  Since there is more than one assignment to <code>v1</code>,  we cannot perform copy propagation.</p> <p>Our original example, however, has no such complications, and we end up with a nice, concise result:</p> <pre><code>v2 = v0 + v1<br />return v2<br /></code></pre> <h3>Aside: Restoring Variable Names</h3> <p>If variables are reduced to slot references in the byte code, how then do we restore the original variable names?  It's possible we can't.  To improve the debugging experience, the byte code for each method may include a special section called the <em>local variable table</em>.  For each variable in the original source, there exists an entry that specifys the name, the slot number, and the bytecode range for which the name applies.  This table (and other useful metadata) can be included in the <code>javap</code> disassembly by including the <code>-v</code> option.  For our <code>plus()</code> method above, the table looks like this:</p> <pre><code>Start  Length  Slot  Name   Signature<br />0      6       0     a      I<br />0      6       1     b      I<br />4      2       2     c      I<br /></code></pre> <p>Here, we see that <code>v2</code> refers to an integer variable originally named '<code>c</code>' at bytecode offsets #4-5.</p> <p>For classes that have been compiled without local variable tables (or which had them stripped out by an obfuscator), we have to generate our own names.  There are many strategies for doing this; a clever implementation might look at how a variable is used for hints on an appropriate name.</p> <h3>Stack Analysis</h3> <p>In the previous example, we could guarantee which value was on top of the stack at any given point, and so we could name <code>s0</code>, <code>s1</code>, and so on.</p> <p>So far, dealing with variables has been pretty straightforward because we've only explored methods with a single code path.  In a real world application, most methods aren't going to be so accommodating.  Each time you add a loop or condition to a method, you increase the number of possible paths a caller might take.  Consider this modified version of our earlier example:</p> <pre><br />public static int plus(boolean t, int a, int b) {<br />    int c = t ? a : b;<br />    return c;<br />}<br /></pre>  <p>Now we have control flow to complicate things; if try to perform the same assignments as before, we run into a problem.</p> <table style="border: 0px; font-size: smaller;"><tr><th style="padding: 0em 2em 0em 0em; text-align: left;" /><th style="padding: 0em 2em 0em 0em; text-align: left;">Bytecode</th><th style="padding: 0em 0em 0em 0em; text-align: left;">Stack Variables</th></tr><tr><td valign="top" style="padding: 0em 1em 0em 0em;">0<br/>1<br/>4<br/>5<br/>8<br/>9<br/>10<br/>11<br/></td> <td valign="top" style="padding: 0em 2em 0em 0em;">iload_0<br/>ifeq 8<br/>iload_1<br/>goto 9<br/>iload_2<br/>istore_3<br/>iload_3<br/>ireturn<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;">s0 = v0<br/>if (s0 == 0) goto #8<br/>s1 = v1<br/>goto #9<br/>s2 = v2<br/>v3 = {s1,s2}<br/>s4 = v3<br/>return s4<br/></td></tr></table>  <p>We need to be a little smarter about how we assign our stack identifiers.  It's no longer sufficient to consider each instruction on its own; we need to keep track of how the stack looks at any given location, because there are multiple paths we might take to get there.</p> <p>When we examine <code>#9</code>, we see that <code>istore_3</code> pops a single value, but that value has two sources: it might have originated at either <code>#5</code> or <code>#8</code>.  The value at the top of the stack at <code>#9</code> might be either <code>s1</code> or <code>s2</code>, depending on whether we came from <code>#5</code> or <code>#8</code>, respectively.  Therefore, we need to consider these to be the same variable&mdash;we merge them, and all references to <code>s1</code> or <code>s2</code> become references to the unambiguous variable <code>s{1,2}</code>.  After this 'relabeling', we can safely perform copy propagation.</p> <table style="border: 0px; font-size: smaller;"><tr><th style="padding: 0em 2em 0em 0em; text-align: left;" /><th style="padding: 0em 2em 0em 0em; text-align: left;">After Relabeling</th><th style="padding: 0em 0em 0em 0em; text-align: left;">After Copy Propagation</th></tr><tr><td valign="top" style="padding: 0em 1em 0em 0em;">0<br/>1<br/>4<br/>5<br/>8<br/>9<br/>10<br/>11<br/></td> <td valign="top" valign="top" style="padding: 0em 2em 0em 0em;">s0 = v0<br/>if (s0 == 0) goto #8<br/>s{1,2} = v1<br/>goto #9<br/>s{1,2} = :v2<br/>v3 = s{1,2}<br/>s4 = v3<br/>return s4<br/></td><td><br/>if (v0 == 0) goto #8<br/>s{1,2} = v1<br/>goto #9<br/>s{1,2} = v2<br/>v3 = s{1,2}<br/><br/>return v3<br/></td></tr></table>  <p>Notice the conditional branch at <code>#1</code>: if the value of <code>s0</code> is zero, we jump to the <code>else</code> block; otherwise, we continue along the current path.  It's interesting to note that the test condition is negated when compared to the original source.</p> <p>We've now covered enough to dive into...</p> <h3>Conditional Expressions</h3> <!-- LB : At this point, we might want to introduce a few graphviz images.  If you do that, comment out the code blocks below, rather than dropping them, as we may end up iterating.  -->  <p>At this point, we can determine that our code could be modeled with a ternary operator (<code>?:</code>): we have a conditional, with each branch having a single assignment to the same stack variable s{1,2}, after which the two paths converge.</p> <p>Once we've identified this pattern, we can roll the ternary up straight away.</p> <table style="border: 0px; font-size: smaller;"><tr><th style="padding: 0em 2em 0em 0em; text-align: left;" /><th style="padding: 0em 2em 0em 0em; text-align: left;">After Copy Prop.</th><th style="padding: 0em 0em 0em 0em; text-align: left;">Collapse Ternary</th></tr><tr><td valign="top" style="padding: 0em 1em 0em 0em;">0<br/>1<br/>4<br/>5<br/>8<br/>9<br/>10<br/>11<br/></td> <td valign="top" style="padding: 0em 2em 0em 0em;"><br/>if (v0 == 0) goto #8<br/>s{1,2} = v1<br/>goto 9<br/>s{1,2} = v2<br/>v3 = s{1,2}<br/><br/>return v3<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;"><br/><br/><br/><br/><br/>v3 = v0 != 0 ? v1 : v2<br/>  <br/>return v3<br/></td> </tr></table>  <p>Note that, as part of the transformation, we negated the condition at <code>#9</code>.  It turns out that <code>javac</code> is fairly predictable in how it negates conditions, so we can more closely matche the original source if we flip those conditions back.</p> <!-- LB: I think this IS worth having.  Ideally, I'd have it in a sidebar, but that's a bit complex for this layout -->  <h3>Aside - But what are the types?</h3> <p>When dealing with stack values, the JVM uses a more simplistic type system than Java source.  Specifically, <code>boolean</code>, <code>char</code>, and <code>short</code> values are manipulated using the same instructions as <code>int</code> values.  Thus, the comparison <code>v0 != 0</code> could be interpreted as either:</p> <p><code>v0 != false ? v1 : v2</code><br/>&nbsp;&nbsp;&nbsp;&nbsp;<em>...or:</em><br/><code>v0 != 0 ? v1 : v2</code><br/>&nbsp;&nbsp;&nbsp;&nbsp;<em>...or even:</em><br/><code>v0 != false ? v1 == true : v2 == true</code><br/>&nbsp;&nbsp;&nbsp;&nbsp;<em>...and so on!</em></p> <p>In this case, however, we are fortunate to know the exact type of <code>v0</code>, as it is contained within the <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3.3">method descriptor</a>:</p> <pre><code>    descriptor: (ZII)I<br />    flags: ACC_PUBLIC, ACC_STATIC<br /></code></pre> <p>This tells us the method signature is of the form:</p> <pre><code>    public static int plus(boolean, int, int)<br /></code></pre> <p>We can also infer that <code>v3</code> should be an <code>int</code> (as opposed to a <code>boolean</code>) because it is used as the return value, and the descriptor tells us the return type.  We are then left with:</p> <pre><code>v3 =  v0 ? v1 : v2<br />return v3<br /></code></pre> <p>As an aside, if <code>v0</code> were a local variable (and not a formal parameter) then we might not know it represents a <code>boolean</code> value and not an <code>int</code>.  Remember that local variable table we mentioned earlier, which tells us the original variable names?  It also includes information about the variable <em>types</em>, so if your compiler is configured to emit debug information, we can look to that table for type hints.  There is another, similar table called <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">LocalVariableTypeTable</a> that contains similar information; the key difference is that a <code>LocalVariableTypeTable</code> may include detailed information about generic types, whereas a <code>LocalVariableTable</code> cannot.  It's worth noting that these tables are <em>unverified</em> metadata, so they <strong>are not necessarily trustworthy</strong>.  A particularly devious obfuscator might choose to fill these tables with lies, and the resulting bytecode would still be valid!  Use them at your own discretion.</p> <h3>Short-Circuit Operators (<code>'&amp;&amp;'</code> and <code>'||'</code>)</h3> <pre><br />public static boolean fn(boolean a, boolean b, boolean c){<br />    return a || b && c;<br />}<br /></pre>  <p>How could anything be simpler?  The bytecode is, unfortunately, a bit of a pain...</p> <table style="border: 0px; font-size: smaller;"><tr><th style="padding: 0em 2em 0em 0em; text-align: left;"/><th style="padding: 0em 2em 0em 0em; text-align: left;">Bytecode</th><th style="padding: 0em 2em 0em 0em; text-align: left;">Stack Variables</th><th style="padding: 0em 0em 0em 0em; text-align: left;">After Copy Propagation</th></tr><tr><td valign="top" style="padding: 0em 1em 0em 0em;">0<br/>1<br/>4<br/>5<br/>8<br/>9<br/>12<br/>13<br/>16<br/>17<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;">iload_0<br/>ifne          #12<br/>iload_1<br/>ifeq          #16<br/>iload_2<br/>         ifeq          #16<br/>iconst_1<br/>        goto          #17<br/>iconst_0<br/>        ireturn<br/>         </td><td valign="top" style="padding: 0em 2em 0em 0em;">s0 = v0<br/>if (s0 != 0) goto #12<br/>s1 = v1<br/>if (s1 == 0) goto #16<br/>s2 = v2<br/>if (s2 == 0) goto #16<br/>s3 = 1<br/>goto 17<br/>s4 = 0<br/>return s{3,4}<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;"><br/>if (v0 != 0) goto #12<br/><br/>if (v1 == 0) goto #16<br/><br/>if (v2 == 0) goto #16<br/>s{3,4} = 1<br/>goto 17<br/>s{3,4} = 0<br/>return s{3,4}<br/></td> </tr></table>  <p>The <code>ireturn</code> instruction at <code>#17</code> could return either <code>s3</code> or <code>s4</code>, depending on what path is taken.  We alias them as described above, and then we perform copy propagation to eliminate <code>s0</code>, <code>s1</code>, and <code>s2</code>.</p> <p>We are left with three consecutive conditionals at <code>#1</code>, <code>#5</code> and <code>#7</code>.  As we mentioned earlier, conditional branches either jump or fall through to the next instruction.</p> <p>The bytecode above contains sequences of conditional branches that follow specific and very useful patterns:</p> <table style="border: 0px; font-size: smaller; margin: auto;"><tr><th style="padding: 0em 4em 0em 0em; text-align: left;">Conditional Conjunction (&&)</th><th style="padding: 0em 0em 0em 0em; text-align: left;">Conditional Disjunction (||)</th></tr><tr><td valign="top" style="padding: 0em 2em 0em 0em;"><pre><br />T1: <br />  if (c1) goto L1<br />  if (c2) goto L2<br />L1:<br />  ...<br /><br />Becomes<br /><br />  if (!c1 && c2) goto L2<br />L1:<br />  ...<br /></pre></td><td valign="top" style="padding: 0em 2em 0em 0em;"><pre><br />T1:<br />  if (c1) goto L2<br />  if (c2) goto L2<br />L1:<br />  ...<br />  <br />Becomes<br /><br />  if (c1 || c2) goto L2<br />L1:<br />  ...<br /></pre></td></tr></table>  <p>If we consider neighbouring pairs of conditionals above, <code>#1...#5</code> do not conform to either of these patterns, but <code>#5...#9</code> is a conditional disjunction (<code>||</code>), so we apply the appropriate transformation:</p> <pre><br /> 1:  if (v0 != 0) goto #12<br /> 5:  if (v1 == 0 || v2 == 0) goto #16<br />12:  s{3,4} = 1<br />13:  goto #17<br />16:  s{3,4} = 0<br />17:  return s{3,4}<br /></pre>  <p>Note that every transform we apply might create opportunities to perform <em>additional</em> transforms.  In this case, applying the <code>||</code> transform restructured our conditions, and now <code>#1...#5</code> conform to the <code>&amp;&amp;</code> pattern!  Thus, we can further simplify the method by combining these lines into a single conditional branch:</p> <pre><br /> 1:  if (v0 == 0 && (v1 == 0 || v2 == 0)) goto #16<br />12:  s{3,4} = 1<br />13:  goto #17<br />16:  s{3,4} = 0<br />17:  return s{3,4}<br /></pre>  <p>Does this look familiar?  It should: this bytecode now conforms to the ternary (<code>?:</code>) operator pattern we covered earlier.  We can reduce <code>#1...#16</code> to a single expression, then use copy propagation to inline <code>s{3,4}</code> into the <code>return</code> statement at <code>#17</code>:</p> <pre><br />return (v0 == 0 && (v1 == 0 || v2 == 0)) ? 0 : 1;<br /></pre>  <p>Using the method descriptor and local variable type tables described earlier, we can infer all the types necessary to reduce this expression to:</p> <pre><br />return (v0 == false && (v1 == false || v2 == false)) ? false : true;<br /></pre>  <p>Well, this is certainly more concise than our original decompilation, but it's still pretty jarring.  Let's see what we can do about that.  We can start by collapsing comparisons like <code>x == true</code> and <code>x == false</code> to <code>x</code> and <code>!x</code>, respectively.  We can also eliminate the ternary operator by reducing <code>x ? false : true</code> as the simple expression <code>!x</code>.</p> <pre><br />return !(!v0 && (!v1 || !v2));<br /></pre>  <p>Better, but it's still a of a handful.  If you remember your high school discrete maths, you can see that De Morgan's theorem can be applied here:</p> <pre><code>    !(a || b) --&gt; (!a) &amp;&amp; (!b)<br />    !(a &amp;&amp; b) --&gt; (!a) || (!b)<br /></code></pre> <p>And thus:</p> <pre><br />return ! ( !v0 && ( !v1 || !v2 ) )<br /></pre>  <p>...becomes:</p> <pre><br />return ( v0 || !(!v1 || !v2 ) )<br /></pre>  <p>...and eventually:</p> <pre><br />return ( v0 || (v1 && v2) )<br /></pre>  <p>Hurrah!</p> <h3>Dealing with Method Calls</h3> <p>We've already seen what it looks like for a method to be called: arguments 'arrive' in the locals array.  To <em>call</em> a method, arguments must be pushed onto the stack, following a <code>this</code> pointer in the case of for instance methods).  Calling a method in bytecode is as you'd expect:</p> <pre><code>    push arg_0<br />    push arg_1 <br />    invokevirtual METHODREF<br /></code></pre> <p>We've specified <code>invokevirtual</code> above, which is the instruction used to invoke most instance methods.  The JVM actually has a handful of instructions used for method calls, each with different semantics:</p> <ol><li><p> <code>invokeinterface</code> invokes interface methods.</p></li><li><p> <code>invokevirtual</code> invokes instance methods using virtual semantics, i.e., the call is dispatched to the proper override based on the runtime type of the target.</p></li><li><p> <code>invokespecial</code> invokes invokes a <em>specific</em> instance method (without virtual sematics); it is most commonly used for invoking constructors, but is also used for calls like <code>super.method()</code>.</p></li><li><p> <code>invokestatic</code> invokes static methods.</p></li><li><p> <code>invokedynamic</code> is the least common (in Java), and it uses a 'bootstrap' method to invoke a custom call site binder.  It was created to improve support for dynamic languages, and has been used in Java 8 to implement lambdas.</p></li></ol>  <p>The important detail for a decompiler writer is that the class's <em>constant pool</em> contains details for any method called, including the number and type of its arguments, as well as its return type.  Recording this information in the caller class allows the runtime to verify that the intended method exists at runtime, and that it conforms to the expected signature.  If the target method is in third party code, and its signature changes, then any code that attempts to call the old version will throw an error (as opposed to producing undefined behavior).</p> <p>Going back to our example above, the presence of the <code>invokevirtual</code> opcode tells us that the target method is an <em>instance method</em>, and therefore requires a <code>this</code> pointer as an implicit first argument.  The <code>METHODREF</code> in the constant pool tells us that the method has one formal parameter, so we know we need to pop an argument off of the stack in addition to the target instance pointer.  We can then rewrite the code as:</p> <pre><code>    arg_0.METHODREF(arg_1)<br /></code></pre> <p>Of course, bytecode isn't always so friendly; there's no requirement that stack arguments be pushed neatly onto the stack, one after the other.  If, for example, one of the arguments was a ternary expression, then there would be intermediate load, store, and branch instructions that will need to be transformed independently.  Obfuscators might rewrite methods into a particularly convoluted sequence of instructions.  A good decompiler will need to be flexible enough to handle many interesting edge cases that are beyond the scope of this article.</p> <h3>There has to be more to it than this...</h3> <p>So far, we've limited ourselves to analyzing a single sequence of code, beginning with a list of simple instructions and applying transformations that produce more familiar, higher-level constructs.  If you are thinking that this seems a little too simplistic, then you are correct.   Java is a highly structured language with concepts like scopes and blocks, as well as more complicated control flow mechanisms.  In order to deal with constructs like <code>if/else</code> blocks and loops, we need to perform a more rigorous analysis of the code, paying special attention to the various paths that might be taken.  This is called <em>control flow analysis</em>.</p> <p>We begin by breaking down our code into contiguous blocks that are guaranteed to execute from beginning to end.  These are called <em>basic blocks</em>, and we construct them by splitting up our instruction list along places where we might jump to another block, as well as any instructions which might be jump targets themselves.</p> <p>We then build up a <em><a href="https://en.wikipedia.org/wiki/Control_flow_graph">control flow graph</a></em> (CFG) by creating edges between the blocks to represent all possible branches.  Note that these edges may not be <em>explicit</em> branches; blocks containing instructions that might throw exceptions will be connected to their respective exception handlers.  We won't go into detail about constructing CFGs, but some high level knowledge is required to understand how we use these graphs to detect code constructs like loops.</p> <p style="text-align: center;"><a target="#new" href="https://upload.wikimedia.org/wikipedia/commons/2/26/Simplified_Control_Flowgraphs.jpg"><img alt="[Control Flow Graph Examples]" src="https://upload.wikimedia.org/wikipedia/commons/2/26/Simplified_Control_Flowgraphs.jpg" width="480" height="240" style="border: 1px solid black;" /></a><br/><sub><em>Examples of control flow graphs.</em></sub></p>  <p>The aspects of control flow graphs that we are most interested in are <em>domination relationships</em>:</p> <ul><li><p>A node <code>D</code> is said to <em>dominate</em> another node <code>N</code> if all paths to <code>N</code> pass through <code>D</code>.  All nodes dominate themselves; if <code>D</code> and <code>N</code> are different nodes, then <code>D</code> is said to <em>strictly dominate</em> <code>N</code>.</p></li><li><p>If <code>D</code> strictly dominates <code>N</code> and does <em>not</em> strictly dominate any <em>other</em> node that strictly dominates <code>N</code>, then <code>D</code> can be said to <em>immediately dominate</em> <code>N</code>.</p></li><li><p>The <em>dominator tree</em> is a tree of nodes in which each node's children are the nodes it immediately dominates.</p></li><li><p>The <em>dominance frontier</em> of <code>D</code> is the set of all nodes <code>N</code> such that <code>D</code> dominates an immediate predecessor of <code>N</code> but does not strictly dominate <code>N</code>.  In other words, it is the set of nodes where <code>D</code>'s dominance ends.</p></li></ul>  <!-- As such, we have a forward edge (jump to a later instruction) or a back edge (jump to a previous instruction) - **but of course**, this assumes that opcode ordering has meaning - if we make these assumptions, an obfuscator could randomly shuffle instructions to confuse us.  Because of this, you may want to apply a topological sort to your instruction graph.  (Or apply the sort if you find that you can't get good decompilation *without* sorting.)  -->  <!-- LB - Mike - insert a graph or two here …. -->  <h3>Basic Loops and Control Flow</h3> <!-- Consider the following Java method and disassembly:  <table style="border: 0px; font-size: smaller; margin: auto;"><tr><th style="padding: 0em 4em 0em 0em; text-align: left;">Original Source</th><th style="padding: 0em 0em 0em 0em; text-align: left;">Disassembly</th></tr><tr><td valign="top" style="padding: 0em 4em 0em 0em;"><pre><br />public static void fn(int n){<br />    for (int i = 0; i < n; ++i) {<br />        System.out.println(i);<br />    }<br />}<br /></pre></td><td valign="top"><pre><br /> 0:  iconst_0<br /> 1:  istore_1<br /> 2:  iload_1<br /> 3:  iload_0<br /> 4:  if_icmpge 20<br /> 7:  getstatic #2      // System.out<br />10:  iload_1<br />11:  invokevirtual #3  // PrintStream.println:(I)V<br />14:  iinc 1, 1<br />17:  goto 2<br />20:  return   <br /></pre></td></tr></table>-->  <p>Consider the following Java method:</p> <pre><br />public static void fn(int n) {<br />    for (int i = 0; i < n; ++i) {<br />        System.out.println(i);<br />    }<br />}<br /></pre>  <p>...and its disassembly:</p> <pre><br /> 0:  iconst_0<br /> 1:  istore_1<br /> 2:  iload_1<br /> 3:  iload_0<br /> 4:  if_icmpge 20<br /> 7:  getstatic #2      // System.out:PrintStream<br />10:  iload_1<br />11:  invokevirtual #3  // PrintStream.println:(I)V<br />14:  iinc 1, 1<br />17:  goto 2<br />20:  return   <br /></pre>  <p>Let's apply what we discussed above to convert this into a more readable form, first by introducing stack variables, then performing copy propagation.</p> <table style="border: 0px; font-size: smaller;"><tr><th style="padding: 0em 1em 0em 0em; text-align: left;" /><th style="padding: 0em 4em 0em 0em; text-align: left;">Bytecode</th><th style="padding: 0em 4em 0em 0em; text-align: left;">Stack Variables</th><th style="padding: 0em 4em 0em 0em; text-align: left;">After Copy Propagation</th></tr><tr><td valign="top" style="padding: 0em 1em 0em 0em;">&nbsp;0<br/>&nbsp;1<br/>&nbsp;2<br/>&nbsp;3<br/>&nbsp;4<br/>&nbsp;7<br/>10<br/>11<br/>14<br/>17<br/>20<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;">iconst_0<br/>     istore_1<br/>     iload_1<br/>       iload_0<br/>       if_icmpge 20<br/>getstatic #2<br/>iload_1<br/>invokevirtual #3<br/>iinc 1, 1<br/>goto 2<br/>return<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;">s0 = 0<br/>     v1 = s0<br/>     s2 = v1<br/>       s3 = v0<br/>       if (s2 >= s3) goto 20<br/>s4 = System.out<br/>s5 = v1<br/>s4.println(s5)<br/>v1 = v1 + 1<br/>goto 2<br/>return<br/></td><td valign="top" style="padding: 0em 2em 0em 0em;"><br/>     v1 = 0<br/>     <br/>       <br/>       if (v1 >= v0) goto 20<br/><br/><br/>System.out.println(v1)<br/>v1 = v1 + 1<br/>goto 4<br/>return<br/></td></tr></table>  <p></p> <p>Notice how the conditional branch at <code>#4</code> and the <code>goto</code> at <code>#17</code> create a logical loop.  We can see this more easily by looking at a control flow graph:</p> <!-- LB - Mike - graph here -->  <div style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-EhdcJg9B53U/Up9ExK_sHHI/AAAAAAAAAYY/1svdXdlriXc/s1600/fn.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-EhdcJg9B53U/Up9ExK_sHHI/AAAAAAAAAYY/1svdXdlriXc/s1600/fn.png" /></a></div>  <p>From the graph, it's obvious that we have a neat cycle, with an edge from the <code>goto</code> back to a conditional branch.  In this case, the conditional branch is referred to as a <em>loop header</em>, which can be defined as a dominator with a loop-forming backward edge.  A loop header dominates all nodes within the loop's body.</p> <p>We can determine whether a condition is a loop header by looking for a loop-forming back edge, but how do we do that?  A simple solution is to test whether the condition node is in its own dominance frontier.  Once we know we have a loop header, we have to figure out which nodes to pull into the loop body; we can do that by finding all nodes dominated by the header.  In pseudocode, our algorithm would look something like this:</p> <pre><code>    findDominatedNodes(header)<br />        q := new Queue()<br />        r := new Set()<br /><br />        q.enqueue(header)<br /><br />        while (not q.empty())<br />            n := q.dequeue()<br /><br />            if (header.dominates(n))<br />                r.add(n)<br /><br />                for (s in n.successors())<br />                    q.enqueue(n)<br /><br />        return r<br /></code></pre> <p>Once we've figured out the loop body, we can transform our code into a loop.  Keep in mind that our loop header may be a conditional jump <em>out</em> of the loop, in which case we need to negate the condition.</p> <pre><br />v1 = 0<br />while (v1 < v0) {<br />    System.out.println(v1)<br />    v1 = v1 + 1<br />}<br />return<br /></pre>  <p>And voila, we have a simple pre-condition loop!  Most loops, including <code>while</code>, <code>for</code> and <code>for-each</code>, compile down to the same basic pattern, which we detect as a simple <code>while</code> loop.  There's no way to know for sure what kind of loop the programmer originally wrote, but <code>for</code> and <code>for-each</code> follow pretty specific patterns that we can look for.  We won't go into the details, but if you look at the <code>while</code> loop above, you can see how the original <code>for</code> loop's initializer (<code>v1 = 0</code>) precedes the loop, and its iterator (<code>v1 = v1 + 1</code>) has been inserted at the end of the loop body.  We'll leave it as an exercise to think about when and how one might transform <code>while</code> loops into <code>for</code> or <code>for-each</code>.  It's also interesting to think about how we might have to adjust our logic to detect <em>post-conditional</em> (<code>do/while</code>) loops.</p> <p>We can apply a similar technique to decompile <code>if/else</code> statements.  The bytecode pattern is pretty straightforward:</p> <pre><br />begin:<br />    iftrue(!condition) goto #else<br />    // `if` block begins here<br />    ...<br />    goto #end<br />    <br />else:<br />    // `else` block begins here<br />    ...<br />    <br />end:<br />    // end of `if/else`<br /></pre>  <p>Here, we use <code>iftrue</code> as a pseudo-instruction to represent any conditional branch: test a condition, and if it passes, then branch; otherwise, continue.  We know that the <code>if</code> block starts at the instruction following the condition, and the <code>else</code> block starts at the condition's jump target.  Finding the contents of those blocks is as simple as finding the nodes dominated by those starting nodes, which we can do using the same algorithm we described above.</p> <p>We've now covered basic control flow mechanisms, and while there are others (e.g., exception handlers and subroutines), those are beyond the scope of this introductory article.</p> <h3>Wrap-Up</h3> <p>Writing a decompiler is no simple task, and the experience easily translates into a book's worth of material&mdash;perhaps even a series of books!  Obviously, we could not cover everything in a single blog post, and you probably wouldn't want to read it if we'd tried.  We hope that by touching on the most common constructs&mdash;logical operators, conditionals, and basic control flow&mdash;we have given you an interesting glimpse into the world of decompiler development.</p> <p><strong>Lee Benfield</strong> is the author of the <a href="http://www.benf.org/other/cfr">CFR</a> Java decompiler.<br/><strong>Mike Strobel</strong> is the author of <a href="https://bitbucket.org/mstrobel/procyon/wiki/Java%20Decompiler">Procyon</a>, a Java decompiler and metaprogramming framework.</p> <p>Now go write your own! :)</p> <p><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></div></p>