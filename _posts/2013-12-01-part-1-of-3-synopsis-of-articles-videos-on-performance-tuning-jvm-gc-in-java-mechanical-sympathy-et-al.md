---
id: 59
title: '(Part 1 of 3): Synopsis of articles &#038; videos on Performance tuning, JVM, GC in Java, Mechanical Sympathy, et al'
date: 2013-12-01T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/part-1-of-3-synopsis-of-articles-videos-on-performance-tuning-jvm-gc-in-java-mechanical-sympathy-et-al/
permalink: /2013/12/part-1-of-3-synopsis-of-articles-videos-on-performance-tuning-jvm-gc-in-java-mechanical-sympathy-et-al.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Mani Sarkar
blogger_permalink:
  - /2013/12/part-1-of-3-synopsis-of-articles-videos.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/6913478341209969693
categories:
  - 2013
  - Atomic I/O
  - CPU
  - GC
  - hotspot
  - java
  - JIT
  - JVM
  - Linux
  - low latency
  - mechanical sympathy
  - Memory Barriers
  - performance tuning
---
<div dir="ltr" style="text-align: left;"><div style="text-align: justify;">I have been contemplating for a number of months about reviewing a  cache of articles and videos on topics like <i>Performance tuning, JVM, GC  in Java, Mechanical Sympathy, etc...</i> and finally took the time to do it -  may be this was the point in my intellectual progress when was I required  to do such a thing!</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Thanks to <em>Attila-Mihaly </em>for giving me the opportunity to write a post for his yearly newsletter&nbsp;<a data-mce-href="http://www.javaadvent.com/" href="http://www.javaadvent.com/" target="_blank" title="Java Advent Calendar"><em><strong>Java Advent Calendar</strong></em></a>,  hence a review on various Java related topics fits the bill! The  selection of videos and articles are purely random, and based on the  order in which they came to my knowledge. My hidden agenda is to mainly go through them to understand and broaden my own knowledge at the same time share any insight with others along the way.<br /><br />I'll be covering three reviews of talks by Attila Szegedi (1 talk) and Ben Evans (2 talks). They speak on the subject of Java Performance and the GC. The first talk by Attila covers a lot of his experience as an Engineer at Twitter - so its lots of information out of live experience in the field on production systems. Making use of thin objects instead of fat ones is one of the buzzwords in his talk.<br /><br />Ben in his two talks covers Performance, JVM and GC in great depth. He points out about people's misconception about Performance, the JVM and GC, things that people don't have certain run-time flags enabled in production. &nbsp;How the underlying machinery works, why it works the way it works?How efficient the machinery is and what best to do and not to do to get good throughput out of it?</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Here I go with my commentary, I decided to start with Attila Szegedi's talk as I quite liked the title.....</div><strong><br /></strong><strong><a href="http://www.infoq.com/presentations/JVM-Performance-Tuning-twitter" target="_blank">Everything I Ever Learned About JVM Performance Tuning @Twitter by Attila Szegedi</a></strong><br />(video &amp; slides)<br /><br /><div style="text-align: justify;">Attila  at the time of the talk worked for Twitter where he learnt a lot about  the internals of the JVM and the Java language itself - Twitter being an  organisation where tuning, optimising JVMs, low-latency are defacto practises.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">He covers interesting topics like:</div><div style="text-align: justify;">- contributors of latency</div><div style="text-align: justify;">- finished code not ready for production</div><div style="text-align: justify;">- areas of performance tuning (primarily memory tuning and lock contention tuning)</div><div style="text-align: justify;">- Memory footprint tuning (OOME, inefficient tuning, FAT data)</div><div style="text-align: justify;">- FAT data - a new terminology coined by him, and how to resolve issues  created by it (pretty indepth and interesting) - learn about byte allocations to data types in the Java / JVM languages.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Some deep dive  topics like compressed object pointers, are one of the suggestions  (including a pit-fall). Certain types in Scala 2.7.7 are inefficient -  as revealed by a JVM profiler. Do not use Thrift - as it is not a friend  of low-latency, as they are heavy - adds between 52 to 72 bytes of  overhead per object, does not support 32-bit floats, etc... Be careful  with thread locals - sticks around and uses more resources than  expected.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Performance triangle, Attila shares his insight into  this concept. GC is the biggest threat of the JVM. Old gen uses  ConcCollector, while the new gen goes through the STW process, and  enlists a number of throughput and low-pause collectors.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Improve  GC by taking advantage of the Adaptive sizing policy, and give it a target to work on.  Use a throughput collector with or without the adaptive policy and  benchmark the results.&nbsp; He takes us through the various -XX: +Print...  flags and explains its uses. Keep fragmentations low and avoid full GC  stops. Lots of detail on the workings of the GC and what can be done to  improve GC (tuning both new and old gens).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Latency that are not GC  related - thread coordination optimization. Barriers and half-barriers  can be used when using threads to improve latency - along with some  tricks when using the Atomic values &amp; AtomicReferences. Cassandra  slab allocator - helps efficiency and performance - do not write your  own memory manager. Attila is no longer a fan of "Soft references" -  although great in theory but not in practice, more GC cycles are needed  to clear them!</div><br /><b style="text-align: justify;">Conclusion: </b><span style="text-align: justify;">know your code as often they may be the root to your problems - frameworks can many a times be the cause of performance issues. Lots of things can be done to squeeze performance out of the programs written, if one knows how to best use the fundamental building blocks of data structures of your development environment. Its a hard game to maintain the best throughput and get the best performance out of the JVM.</span><br /><b style="text-align: justify;"><br /></b><em>--- Recommend watching the video, lots more covered than the synopsis above&nbsp; ---</em><br /><strong><br /></strong><strong><br /></strong><strong><a href="http://www.infoq.com/articles/9_Fallacies_Java_Performance" target="_blank">9 Fallacies of Java Performance by Ben Evans</a>&nbsp;</strong>(blog)<br /><div style="text-align: justify;">In this article Ben goes about busting old myths and assumptions about Java, its performance, GC, etc... Areas covered being:</div><div style="text-align: justify;"><b>1)</b> Java is slow, <b>2)</b> A single line of Java means anything in isolation, <b>3)</b> A micro-benchmark means what you think it does , <b>4)</b> Algorithmic slowness is the most common cause of performance problems,&nbsp;<b>5)&nbsp;</b>Caching solves everything, <b>6)</b>&nbsp;&nbsp;All apps need to be concerned about Stop-The-World, <b>7)</b> Hand-rolled Object Pooling is appropriate for a wide range of apps,&nbsp;<b>8)&nbsp;</b>CMS is always a better choice of GC than Parallel Old,&nbsp;<b>9)&nbsp;</b>Increasing the heap size will solve your memory problem</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">- JIT compiled code is as fast as C++ in many cases</div><div style="text-align: justify;">- JIT compiler can optimize away dead and unused code, even on the basis of profiling data. In JVMs like JRockit, the JIT can decompose object operations.</div><div style="text-align: justify;">- For best results don't prematurely optimize, instead correct your performance hot spots.&nbsp;</div><div style="text-align: justify;">-&nbsp;Richard Feynman once said: "The first principle is that you must not fool yourself - and you are the easiest person to fool" - something to keep in mind when thinking of writing Java micro-benchmarks.</div><div style="text-align: justify;">The points being the ideas people have in their minds about Java is but the opposite of the reality of things. Basically suggesting the masses to revisit the ideas and make conclusions based on sheer facts and not assumptions or old beliefs.</div><div style="text-align: justify;">- GC, database access, misconfiguration, etc... are likely to cause application slowness as compared to algorithms.</div><div style="text-align: justify;">- Measure, don't guess ! Use empirical production data to uncover the true causes of performance problems.</div><div style="text-align: justify;">-&nbsp;Don't just add a cache to redirect the problem elsewhere and add complexity to the system, but collect basic usage statistics (miss rate, hit rate, etc.) to prove that the caching layer is actually adding value.</div><div style="text-align: justify;">- If the users haven't complained or you are not in the low-latency stack - don't worry about STOP-THE-WORLD pauses (circa 200 ms depending on the heap size).</div><div style="text-align: justify;">- Object pooling is very difficult and should only be used when GC pauses are unacceptable, and intelligent attempts at tuning and refactoring have been unable to reduce pauses to an acceptable level.</div><div style="text-align: justify;"><strong>-&nbsp;</strong>Check if CMS is your correct GC strategy, you should  first determine that STW pauses from Parallel Old are unacceptable and  can't be tuned. Ben stresses: <i><b>be sure  that all metrics are obtained on a production-equivalent system</b></i>.<strong>&nbsp;&nbsp;</strong></div><div style="text-align: justify;">-&nbsp;Understanding the dynamics of object allocation and lifetime before changing heap size or tuning other parameters is essential.<i> Acting without measuring can make matters worse.</i> The tenuring distribution information from the garbage collector is especially important here.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b>Conclusion:&nbsp;</b>The GC subsystem has incredible potential for tuning and for producing data to guide tuning, and then to use a tool to analyse the logs - either handwritten  scripts and some graph generation, or a visual tool such as the  (open-source) GCViewer or <i>a commercial product</i>.</div><div style="text-align: justify;"></div><br /><div style="text-align: justify;"><span style="font-weight: bold;"><br /></span></div><strong><a href="http://www.infoq.com/presentations/Visualizing-Java-GC" target="_blank">Visualizing Java GC by Ben Evans</a></strong><span style="text-align: justify;">&nbsp;(video &amp; slides)</span><br /><br /><div style="text-align: justify;">Misunderstanding or shortcomings in people's understanding of GC. Its not just Mark &amp; Sweep. Many run-times these days have GC! Two schools of thoughts - GC &amp; Reference counting! Humans make mistakes as compared to machines which requires high levels of precision. True GC is incredibly efficient, reference counting is expensive - <strike>pioneered by Java</strike> <i><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">(<b>comments from <a href="http://plus.google.com/112180353019404914954" target="_blank">+Gil Tene</a>:</b>&nbsp;<span style="background-color: white; color: #222222; text-align: start;">On the correctness side, I'd be careful saying "pioneered by Java" for anything in GC. Java's GC semantics are fairly classic, and present no new significant problems that predating environments did not. Most core GC techniques used in JVMs were researched and well known in other environments (smalltalk, lisp, etc.) and are also available in other Runtimes. While it is fair to say that from a practical perspective, JVMs tend to have the most mature GC mechanisms these days, that's because Java is a natural place to apply new GC techniques that actually work. But innovation and pioneering in GC is not strongly tied to Java.)</span></span></i></div><br /><div style="text-align: justify;">The allocation list is where all objects are rooted from. <strike>You can't get an accurate picture of all the objects of a running object at any given point of time of a running live application without stopping the application that's why we have STW (Stop-The-World)</strike>!&nbsp;<i><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">(<b>comments from&nbsp;<a href="http://plus.google.com/112180353019404914954" target="_blank">+Gil Tene</a>:</b>&nbsp;<span style="background-color: white; color: #222222; text-align: start;">In addition, the notion that "you can't get an accurate picture of all the objects of a running object at any given point of time of a running live application without stopping the application that's why we have STW (Stop-The-World)!" is wrong. Concurrent marking and concurrent compaction are very real things that </span><span style="background-color: white; color: #222222; text-align: start;">achieve just that without stopping the application. "Just needs some good engineering", and "you just can't do X"</span><span style="background-color: white; color: #222222; text-align: start;"> are very different things.)</span></span></i></div><div style="text-align: justify;"><strong><br /></strong></div><div style="text-align: justify;">Golden rules of GC</div><div style="text-align: justify;">- must collect all the garbage (sensitive rule)</div><div style="text-align: justify;">- must never collect a live object</div><div style="text-align: justify;">(trick: but they are never created equal)<br /><br /></div><div style="text-align: justify;">Hotspot is C/C++/Assembly application. Heap is a contiguous block of memory with different memory pools - Young Gen, Old Gen, and PermGen pools. Objects are created by application (mutator) threads and removed by GC. Applications are not slow due to GC all the time.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">PermG - not desirable, going away in Java 8 (known issue: causes OOME exceptions), to be replaced by Metaspace outside the heap (native memory).</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><strike>GC is based on 'Weak generational hypothesis' - objects die young, or die old - found out through empirical research.</strike>&nbsp;<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><i>(<b>comments from&nbsp;<a href="http://plus.google.com/100360383089760742764" target="_blank">+Michael Barker</a></b>: I think this statement:</i></span><br /><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><i>"GC is based on 'Weak generational hypothesis' - objects die young, or die old - found out through empirical research."</i></span><br /><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><i>Is not correct. &nbsp;I think I can guess at what you mean, but you may want to consider rewording it so that it is not misleading. &nbsp;There are GC implementations in real world VMs that are not generational collectors.</i></span><br /><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><i><br /></i></span><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><i><b>comments from <a href="http://plus.google.com/104048775722639428077" target="_blank">+Kirk Pepperdine</a></b>: Indeed. the ParcPlace VM had 7 different memory spaces that have a strong resemblance to the todays generational spaces. There is Eden with two hemi spaces plus 4 other spaces for different types of long lived data.)</i></span></div><div style="text-align: justify;"><br /><i><b>Re-worded version:</b> GC in the JVM</i> is based on 'Weak generational hypothesis' - objects die young, or die old - found out through empirical research.<br /><br /></div><div style="text-align: justify;">Tenuring threshold is the number of GC you survive before your get moved to the Old Gen (Tenuring space). JavaFX is bundled with jdk7u6 and up.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Source code of JavaFX Memory Visualizer written in Java replacing the Flash version &nbsp;-&nbsp;<a href="https://github.com/kittylyst/jfx-mem">https://github.com/kittylyst/jfx-mem</a> - written using FlexML (FXML). An extensive explanation of how the program is written in FlexML, a nice programming language - uses the builder pattern in combination with DSL like expressions. The program models the way GC works and how objects are created, destroyed and moved about the different pools.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">List of mandatory flags, which do not have <i>any performance impact</i></div><div style="text-align: justify;">-verbose: gc</div><div style="text-align: justify;">-Xloggc:&lt;pathtofile&gt;</div><div style="text-align: justify;">-XX:+PrintGCDetails</div><div style="text-align: justify;">-XX:+PrintTenuringDistribution</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">All the information needed about an executing application and GC are recorded by the above. Also covers basic heap sizing flags. Setting the heap flags to equal do not apply anymore since recent versions of the JDK. Also there's more than 200 flags to the GC and VM not including all the undocumented ones.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">GC log files are useful for post-processing, but sometimes are not recorded correctly. MXBeans impact the running application but also do not give more information than the log files.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">GC log files have a general format giving information on change of allocation, occupancy, tenuring info, collection info, etc..., &nbsp;- explosion of GC log file formats and not much tooling out there. Many of the free tools cover some sort of dashboard like output showing various GC related metrics, the commercial versions have a better approach and useful information in general.</div><br /><i>Premature promotion</i> - under pressure of creation of new objects, objects are moved directly from YG to OG without going through the Survivor spaces.<br /><br />Use tools, <i>measure and don't guess!</i><br /><i><br /></i><br /><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px;"></div><br /><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px;"><div style="margin: 0px;"><b>Conclusion:</b>&nbsp;know the facts and find out details if they are not known but do not guess or assume. False conceptions have lead to assumptions and incorrect understanding of the JVM and the GC process at times. Don't just changes flags or use tools, know why to and what they do. For e.g. switching on GC logging (with appropriate flags enabled) does not have a visible impact on the performance of the JVM but is a boon in the medium to long run.</div></div><i><br /></i><em>--- Highly recommend watching the video, lots more covered than the synopsis above, Ben has explained GC in the simplest form one could, covering many important details &nbsp;---</em><br /><br /><div style="text-align: justify;">As  it is not practical to review all such videos and articles, a number of  them have been provided in the links below for further study. In many cases I have paraphrased or directly quoted what the authors have to say to preserve the message and meaning they wished to convey. A follow-on to this blog post will appear in the same space under the titled&nbsp;<u><i><a href="http://www.javaadvent.com/2013/12/part-2-of-3-synopsis-of-articles-videos.html" target="_blank">(Part 2 of 3): Synopsis of articles &amp; videos on Performance tuning, JVM, GC in Java, Mechanical Sympathy, et al</a></i></u><i>&nbsp;</i><i>on 19th Dec 2013.</i></div><div><i><br /></i><br /><h2><strong>Thanks</strong></h2><i>Thanks to&nbsp;<a href="http://plus.google.com/112180353019404914954" target="_blank">+Gil Tene</a>, <a href="http://plus.google.com/100360383089760742764" target="_blank">+Michael Barker</a>, @Ryan Rawson, <a href="http://plus.google.com/112944610666608821278" target="_blank">+Kirk Pepperdine</a>, and <a href="http://plus.google.com/101313557474382087033" target="_blank">+Richard Warburton</a>&nbsp;for read the post and providing using feedback.</i><br /><br />Feel free to post your comments below or tweet&nbsp;at&nbsp;<a href="http://twitter.com/theNeomatrix369" target="_blank">@theNeomatrix369</a>!</div><h2><strong>Useful resources</strong></h2><h2><div style="text-align: justify;"><div style="text-align: start;"><ul><li style="font-size: medium; font-weight: normal;"><i>Are your GC logs speaking to you, the G1GC edition by Kirk Pepperdine - <a href="http://www.parleys.com/play/51643b58e4b09b60aec89cf4/chapter0/about" target="_blank">Slides</a>&nbsp;-&nbsp;<a href="http://parleys.com/play/517f2503e4b0c6dcd95464ad/chapter0/about" target="_blank">Video</a></i></li><li style="font-size: medium; font-weight: normal;"><i><a href="http://skillsmatter.com/podcast/home/performance-special-interest-group" target="_blank">Performance Special Interest Group discussion</a>&nbsp;- moderated by Richard Warburton</i><i>&nbsp;(video)</i></li><li style="font-size: medium; font-weight: normal;"><i><a href="http://parleys.com/play/517fb1c9e4b0c2a859eb9ecb/chapter0/about" target="_blank">Caching in: understand, measure and use your CPU Cache more effectively"</a> by @RichardWarburto -</i><i>&nbsp;(video &amp; slides)</i></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://lwn.net/Articles/552095/" target="_blank">Article on Atomic I/O operations (Linux)</a>&nbsp;by Jonathan Corbet</em></li><li style="font-size: medium; font-weight: normal;"><i><a href="http://www.azulsystems.com/resources/presentations" target="_blank">Articles and Presentations about Azul Zing, Low Latency GC &amp; OpenJDK</a>&nbsp;by Gil Tene (videos &amp; slides)</i></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/presentations/Lock-Free-Algorithms" target="_blank">Lock-Free Algorithms For Ultimate Performance</a> by Martin Thompson</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="https://plus.google.com/communities/107178245817384004088" target="_blank">Performance Java User's Group - "For expert Java developers who want to push their systems to the next level"</a></em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/articles/Java-Thread-Pool-Performance-Tuning" target="_blank">Tuning the Size of your thread pool</a>&nbsp;by Kirk Pepperdine</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/presentations/latency-pitfalls" target="_blank">How NOT to measure Latency</a> by Gil Tene</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/presentations/Java-GC-Azul-C4" target="_blank">Understanding Java Garbage Collection and What You Can Do about It</a>&nbsp;by Gil Tene</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://vanillajava.blogspot.co.uk/search/label/Performance" target="_blank">Vanilla #Java Understanding how Core Java really works can help you write simpler, faster applications</a>&nbsp;by Peter Lawrey</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.youtube.com/watch?v=Yg6_ulhwLw0" target="_blank">Profiling Java In Production</a>&nbsp;- by Kaushik Srenevasan</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://blog.ragozin.info/2013/11/hotspot-jvm-garbage-collection-options.html" target="_blank">HotSpot JVM garbage collection options cheat sheet (v3)</a>&nbsp;by Alexey Ragozin</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/40696.pdf" target="_blank">Optimizing Googleâ€™s Warehouse Scale Computers: The NUMA Experience</a> -&nbsp; authors from Univ. of Cal (SD) &amp; Google!</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="https://docs.google.com/viewer?a=v&amp;pid=forums&amp;srcid=MDUxODU4OTA1NTU1MzUxODE5MDQBMTA5MDUzNTI5Mzg2ODk0MjY5NjUBYWM5cnR1MEY4Z1FKATQBAXYy" target="_blank">MegaPipe: A New Programming Interface for Scalable Network I/O</a> by several authors!</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.akkadia.org/drepper/cpumemory.pdf" target="_blank">What Every Programmer Should Know About Memory</a> by Ulrich Drepper</em>&nbsp;</li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2009.04.05a.pdf" target="_blank">Memory Barriers: a Hardware View for Software Hackers</a> - Paul E. McKenney (Linux Technology Center - IBM Beaverton)</em></li></ul></div></div><ul style="font-size: medium; font-weight: normal;"></ul><div style="font-size: medium; font-weight: normal;"><em><br /></em><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></div></h2></div>