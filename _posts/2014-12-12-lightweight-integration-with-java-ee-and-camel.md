---
id: 21
title: Lightweight Integration with Java EE and Camel
date: 2014-12-12T08:01:00+00:00
author: Markus Eisele
layout: post
permalink: /2014/12/lightweight-integration-with-java-ee-and-camel.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Markus Eisele
blogger_permalink:
  - /2014/12/lightweight-integration-with-java-ee-and-camel.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/1222777733310006538
image: /content/uploads/2014/12/camel-route.png
categories:
  - Camel
  - Java Advent
  - java advent 2014
  - JavaEE
  - lightweight
---
Enterprise Java has different flavors and perspectives. Starting at the plain platform technology, which is well known as Java EE over to different frameworks and integration aspects and finally use-cases which involve data-centric user interfaces or specific visualizations. The most prominent problem which isn't solved by Java EE itself is "integration". There are plenty of products out there from well know vendors which solve all kinds of integration problems and promise to deliver complete solutions. As a developer, all you need from time to time is a solution that just works. This is the ultimate "Getting Started Resource" for Java EE developers when it comes to system integration.<br /><br /><b>A Bit Of Integration Theory</b><br />Integration challenges are nothing new. Since there has been different kinds of system and the need to combine their data into another one, this has been a central topic.&nbsp;Gregor Hohpe and Bobby Woolf started to collect a set of basic patterns they used to solve their customers integration problems with. These <a href="http://www.eaipatterns.com/toc.html" target="_blank">Enterprise Integration Patterns</a>&nbsp;(EIPs) can be considered the bible of integration. It tries to find a common vocabulary and body of knowledge around asynchronous messaging architectures by defining 65 integration pattern. Forrester calls those&nbsp;"The core language of EAI".<br /><br /><b>What Is Apache Camel?</b><br /><a href="http://camel.apache.org/" target="_blank">Apache Camel</a> offers you the interfaces for the EIPs, the base objects, commonly needed implementations, debugging tools, a configuration system, and many other helpers which will save you a ton of time when you want to implement your solution to follow the EIPs.&nbsp;It's a complete production-ready framework. But it does not stop at those <a href="http://camel.apache.org/enterprise-integration-patterns.html" target="_blank">initially defined 65 patterns</a>. It extends those with over <a href="http://camel.apache.org/components.html" target="_blank">150 ready-to-use components</a>&nbsp;which solve different problems around endpoints or system or technology integration. At a high level Camel consists of a CamelContext which contains a collection of Component instances. A Component is essentially a factory of Endpoint instances. You can explicitly configure Component instances in Java code or an IoC container like Spring, Guice or CDI, or they can be auto-discovered using URIs.<br /><br /><b>Why Should A Java EE Developer Care?</b><br />Enterprise projects require us to do so. Dealing with all sorts of system integrations always has been a challenging topic. You can either chose the complex road by using messaging systems and wiring them into your application and implement everything yourself or go the heavyweight road by using different products. I have been a fan of more pragmatic solutions since ever. And this is what Camel actually is: Comparably lightweight, easy to bootstrap and coming with a huge amount of pre-built integration components which let the developer focus on solving the business requirement behind it. Without having to learn new APIs or tooling. Camel comes with either&nbsp;a <a href="http://camel.apache.org/dsl.html" target="_blank">Java-based Fluent API</a>, <a href="http://camel.apache.org/spring.html" target="_blank">Spring</a> or <a href="http://camel.apache.org/using-osgi-blueprint-with-camel.html" target="_blank">Blueprint</a> <a href="http://camel.apache.org/xml-configuration.html" target="_blank">XML Configuration files</a>, and even a <a href="http://camel.apache.org/scala-dsl.html" target="_blank">Scala DSL</a>. So no matter which base you start to jump off from, you'll always find something that you already know.<br /><br /><b>How To Get Started?</b><br />Did I got you? Want to give it a try? That's easy, too. You have different ways according to the frameworks and platform you use. Looking back at the post title, this is going to focus on Java EE.<br />So, first thing you can do is just bootstrap Camel yourself. All you need is the core camel dependency and the cdi-camel dependency. Setting up a plain Java EE 7 maven project and adding those two is more than sufficient.<br /><br /><pre style="background-color: whitesmoke; border-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.42857143; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: break-all; word-wrap: break-word;"><code style="background-color: transparent; border-radius: 0px; box-sizing: border-box; color: inherit; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: inherit; padding: 0px; white-space: pre-wrap;">&lt;dependency&gt;<br />   &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;<br />   &lt;artifactId&gt;camel-core&lt;/artifactId&gt;<br />   &lt;version&gt;${camel.version}&lt;/version&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />  &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;<br />  &lt;artifactId&gt;camel-cdi&lt;/artifactId&gt;<br />  &lt;version&gt;${camel.version}&lt;/version&gt;<br />&lt;/dependency&gt;</code></pre><br />Next thing you need to do is find a place to inject your first CamelContext. <br /><pre style="background-color: whitesmoke; border-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.42857143; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: break-all; word-wrap: break-word;"><code style="background-color: transparent; border-radius: 0px; box-sizing: border-box; color: inherit; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: inherit; padding: 0px; white-space: pre-wrap;"><br /> @Inject<br /> CdiCamelContext context;<br /></code></pre><br />After everything is injected, you can start adding routes to it. A more complete example can be found in my <a href="https://github.com/myfear/CamelEE7/" target="_blank">CamelEE7 project on GitHub</a>. Just fork it an go ahead. This one will work on a random Java EE application server. If you are on <a href="http://www.wildfly.org/" target="_blank">WildFly</a> already, you can also take full advantage of the <a href="https://github.com/wildfly-extras/wildfly-camel" target="_blank">WildFly-Camel subsystem</a>.<br /><br /><b>The WildFly Camel Subsystem</b><br />The strategy of wildfly-camel is, that a user can “just use” the camel core/component APIs in deployments that WildFly supports already. In other words, Camel should “just work” in standard Java EE deployments. The binaries are be provided by the platform. The deployment should not need to worry about module/wiring details.<br />Defining and Deploying Camel Contexts can be done in different ways. You either can directly define a <a href="http://wildflyext.gitbooks.io/wildfly-camel/content/features/context-definitions.html" target="_blank">Context in your standalone-camel.xml</a> server configuration or deploy it as part of your <a href="http://wildflyext.gitbooks.io/wildfly-camel/content/features/context-deployments.html" target="_blank">web-app</a> either as a single XML file with a predefined -camel-context.xml file suffix or as part of another WildFly supported deployment as META-INF/jboss-camel-context.xml file.<br />The WildFly Camel test suite uses the WildFly Arquillian managed container. This can connect to an already running WildFly instance or alternatively start up a standalone server instance when needed. A number of test enrichers have been implemented that allow you have these WildFly Camel specific types injected into your Arquillian test cases; you can inject a CamelContextFactory or a CamelContextRegistry as an &nbsp;@ArquillianResource.<br />If you want to get started with that you can take a more detailed look at my <a href="http://blog.eisele.net/2014/12/wildfly-camel-subsystem-for-wildfly-integrates-javaee-getting-started.html" target="_blank">more detailed blog-post</a>.<br /><br /><b>Finding Examples</b><br /><div style="clear: both; text-align: center;"><a href="http://blog.eisele.net/2014/11/technical-details-about-the-jboss-devoxx-demo.html" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;" target="_blank"><img border="0" src="http://www.javaadvent.com/../uploads/2014/12/camel-route-140x300.png" /></a></div>If you are excited and got everything up and running it is time to dig into some examples. First place to look at is the <a href="https://git-wip-us.apache.org/repos/asf?p=camel.git;a=tree;f=examples;hb=HEAD" target="_blank">example directory</a> in the distribution. There is an example for everything that you might need.<br />One of the most important use-cases is the tight integration with ActiveMQ. And assuming that you have something like a bunch of JMS messages that need to be converted into Files that are stored in a filesystem: This is a perfect Camel job. You need to configure the <a href="http://camel.apache.org/activemq.html" target="_blank">ActiveMQ component</a> additional to what you've seen above and it allows messages to be sent to a JMS Queue or Topic or messages to be consumed from a JMS Queue or Topic using <a href="http://activemq.apache.org/" target="_blank">Apache ActiveMQ</a>.<br />Teh following code shows you what it takes to convert a JMS messages from the test.queue queue into the file component which consumes them and stores them to disk.<br /><pre style="background-color: whitesmoke; border-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.42857143; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: break-all; word-wrap: break-word;"><code style="background-color: transparent; border-radius: 0px; box-sizing: border-box; color: inherit; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: inherit; padding: 0px; white-space: pre-wrap;"><br /> context.addRoutes(new RouteBuilder() {<br />            public void configure() {<br />                from("test-jms:queue:test.queue").to("file://test");<br />            }<br />        });<br /></code></pre><br />Imagine to do this yourself. Want more sophisticated examples? With Twitter integration? Or different other technologies? There are plenty of examples out there to pick from. Probably one of the most exciting aspects of Camel. It is lightweight, stable and out there since years. Make sure to also follow the <a href="http://activemq.apache.org/mailing-lists.html" target="_blank">mailing-lists</a> and the <a href="http://activemq.apache.org/discussion-forums.html" target="_blank">discussion forums</a>. <br /><br /><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em>