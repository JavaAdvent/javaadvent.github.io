---
id: 26
title: Creating a REST API with Spring Boot and MongoDB
date: 2014-12-08T08:30:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2014/12/creating-a-rest-api-with-spring-boot-and-mongodb/
permalink: /2014/12/creating-a-rest-api-with-spring-boot-and-mongodb.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Petri Kainulainen
blogger_permalink:
  - /2014/12/creating-rest-api-with-spring-boot-and.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/1835977013719709904
dsq_thread_id:
  - 4962579260
categories:
  - boot
  - Java Advent
  - java advent 2014
  - maven
  - mongodb
  - REST
  - service
  - Spring
  - spring boot
---
<div dir="ltr" style="text-align: left;"><a href="http://projects.spring.io/spring-boot/">Spring Boot</a> is an opinionated framework that simplifies the development of Spring applications. It frees us from the slavery of complex configuration files and helps us to create standalone Spring applications that don’t need an external servlet container.<br />This sounds almost too good to be true, but <strong>Spring Boot can really do all this</strong>.<br />This blog post demonstrates how easy it is to implement a REST API that provides CRUD operations for todo entries that are saved to <a href="http://www.mongodb.org/">MongoDB</a> database.<br />Let’s start by creating our Maven project.<br /><strong>Note:</strong> This blog post assumes that you have already installed the MongoDB database. If you haven’t done this, you can follow the instructions given in the blog post titled: <a href="http://spring.io/guides/gs/accessing-data-mongodb/#initial">Accessing Data with MongoDB</a>.<br /><h3>Creating Our Maven Project</h3>We can create our Maven project by following these steps: <br /><ol><li>Use the <em>spring-boot-starter-parent</em> POM as the parent POM of our Maven project. This ensures that our project inherits sensible default settings from Spring Boot.</li><li>Add the <a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/maven-plugin/">Spring Boot Maven Plugin</a> to our project. This plugin allows us to package our application into an executable jar file, package it into a war archive, and run the application.</li><li>Configure the dependencies of our project. We need to configure the following dependencies: <ul><li>The <em>spring-boot-starter-web</em> dependency provides the dependencies of a web application.</li><li>The <em>spring-data-mongodb</em> dependency provides integration with the MongoDB document database.</li></ul></li><li>Enable the Java 8 Support of Spring Boot.</li><li>Configure the main class of our application. This class is responsible of configuring and starting our application. </li></ol>The relevant part of our <em>pom.xml</em> file looks as follows: <code>      </code><br /><pre><code>&lt;properties&gt;<br />    &lt;!-- Enable Java 8 --&gt;<br />    &lt;java.version&gt;1.8&lt;/java.version&gt;<br />    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />    &lt;!-- Configure the main class of our Spring Boot application --&gt;<br />    &lt;start-class&gt;com.javaadvent.bootrest.TodoAppConfig&lt;/start-class&gt;<br />&lt;/properties&gt;<br />        <br />&lt;!-- Inherit defaults from Spring Boot --&gt;<br />&lt;parent&gt;<br />    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br />    &lt;version&gt;1.1.9.RELEASE&lt;/version&gt;<br />&lt;/parent&gt;<br /><br />&lt;dependencies&gt;<br />    &lt;!-- Get the dependencies of a web application --&gt;<br />    &lt;dependency&gt;<br />        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br />    &lt;/dependency&gt;<br /><br />    &lt;!-- Spring Data MongoDB--&gt;<br />    &lt;dependency&gt;<br />        &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;<br />        &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;<br />    &lt;/dependency&gt;<br />&lt;/dependencies&gt;<br /><br />&lt;build&gt;<br />    &lt;plugins&gt;<br />        &lt;!-- Spring Boot Maven Support --&gt;<br />        &lt;plugin&gt;<br />            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br />        &lt;/plugin&gt;<br />    &lt;/plugins&gt;<br />&lt;/build&gt;<br />      </code></pre><code></code><br /><strong>Additional Reading:</strong><br /><ul><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/reference/htmlsingle/#getting-started-maven-installation">Spring Boot Reference Manual: 9.1.1 Maven installation</a></li><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/reference/htmlsingle/#using-boot-maven">Spring Boot Reference Manual: 12.1 Maven</a></li><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/maven-plugin/usage.html">Spring Boot Maven Plugin - Usage</a></li></ul>Let’s move on and find out how we can configure our application.<br /><h3>Configuring Our Application</h3>We can configure our Spring Boot application by following these steps:<br /><ol><li>Create a <em>TodoAppConfig</em> class to the <em>com.javaadvent.bootrest package</em>. </li><li>Enable Spring Boot auto-configuration.</li><li>Configure the Spring container to scan components found from the child packages of the <em>com.javaadvent.bootrest</em> package.</li><li>Add the <em>main()</em> method to the <em>TodoAppConfig</em> class and implement by running our application.</li></ol>The source code of the <em>TodoAppConfig</em> class looks as follows:<br /><code>      </code><br /><pre><code>package com.javaadvent.bootrest;<br /><br />import org.springframework.boot.SpringApplication;<br />import org.springframework.boot.autoconfigure.EnableAutoConfiguration;<br />import org.springframework.context.annotation.ComponentScan;<br />import org.springframework.context.annotation.Configuration;<br /><br />@Configuration<br />@EnableAutoConfiguration<br />@ComponentScan<br />public class TodoAppConfig {<br />    <br />    public static void main(String[] args) {<br />        SpringApplication.run(TodoAppConfig.class, args);<br />    }<br />}<br />      </code></pre><code></code><br />We have now created the configuration class that configures and runs our Spring Boot application. Because the MongoDB jars are found from the classpath, Spring Boot configures the MongoDB connection by using its default settings.<br /><strong>Additional Reading:</strong><br /><ul><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/reference/htmlsingle/#using-boot-locating-the-main-class">Spring Boot Reference Manual: 13.2 Location the main application class</a></li><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/reference/htmlsingle/#using-boot-configuration-classes">Spring Boot Reference Manual: 14. Configuration classes</a></li><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.htm"> The Javadoc of the <em>@EnableAutoConfiguration</em> annotation</a></li><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/reference/htmlsingle/#using-boot-auto-configuration">Spring Boot Reference Manual: 15. Auto-configuration</a></li><li><a href="http://docs.spring.io/spring-boot/docs/1.1.9.RELEASE/api/org/springframework/boot/SpringApplication.html">The Javadoc of the <em>SpringApplication</em> class</a></li><li><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-connecting-to-mongodb">Spring Boot Reference Manual: 27.2.1 Connecting to a MongoDB database</a></li></ul>Let’s move on and implement our REST API.<br /><h3>Implementing Our REST API</h3>We need implement a REST API that provides CRUD operations for todo entries. The requirements of our REST API are:<br /><ul><li>A <em>POST</em> request send to the url ‘/api/todo’ must create a new todo entry by using the information found from the request body and return the information of the created todo entry.</li><li>A <em>DELETE</em> request send to the url ‘/api/todo/{id}’ must delete the todo entry whose id is found from the url and return the information of the deleted todo entry.</li><li>A <em>GET</em> request send to the url ‘/api/todo’ must return all todo entries that are found from the database.</li><li>A <em>GET</em> request send to the url ‘/api/todo/{id}’ must return the information of the todo entry whose id is found from the url.</li><li>A <em>PUT</em> request send to the url ‘/api/todo/{id}’ must update the information of an existing todo entry by using the information found from the request body and return the information of the updated todo entry.</li></ul>We can fulfill these requirements by following these steps:<br /><ol><li>Create the entity that contains the information of a single todo entry.</li><li>Create the repository that is used to save todo entries to MongoDB database and find todo entries from it.</li><li>Create the service layer that is responsible of mapping DTOs into domain objects and vice versa. The purpose of our service layer is to isolate our domain model from the web layer.</li><li>Create the controller class that processes HTTP requests and returns the correct response back to the client.</li></ol><strong>Note:</strong> This example is so simple that we could just inject our repository to our controller. However, because this is not a viable strategy when we are implementing real-life applications, we will add a service layer between the web and repository layers.<br />Let’s get started.<br /><h4>Creating the Entity</h4>We need to create the entity class that contains the information of a single todo entry. We can do this by following these steps:<br /><ol><li>Add the <em>id</em>, <em>description</em>, and <em>title</em> fields to the created entity class. Configure the id field of the entity by annotating the <em>id</em> field with the <em>@Id</em> annotation.</li><li>Specify the constants (<em>MAX_LENGTH_DESCRIPTION</em> and <em>MAX_LENGTH_TITLE</em>) that specify the maximum length of the <em>description</em> and <em>title</em> fields.</li><li>Add a static builder class to the entity class. This class is used to create new <em>Todo</em> objects.</li><li>Add an <em>update()</em> method to the entity class. This method simply updates the <em>title</em> and <em>description</em> of the entity if valid values are given as method parameters.</li></ol>The source code of the <em>Todo</em> class looks as follows:<br /><code>      </code><br /><pre><code>import org.springframework.data.annotation.Id;<br /><br />import static com.javaadvent.bootrest.util.PreCondition.isTrue;<br />import static com.javaadvent.bootrest.util.PreCondition.notEmpty;<br />import static com.javaadvent.bootrest.util.PreCondition.notNull;<br /><br />final class Todo {<br /><br />    static final int MAX_LENGTH_DESCRIPTION = 500;<br />    static final int MAX_LENGTH_TITLE = 100;<br /><br />    @Id<br />    private String id;<br /><br />    private String description;<br /><br />    private String title;<br /><br />    public Todo() {}<br /><br />    private Todo(Builder builder) {<br />        this.description = builder.description;<br />        this.title = builder.title;<br />    }<br /><br />    static Builder getBuilder() {<br />        return new Builder();<br />    }<br /><br />    //Other getters are omitted<br /><br />    public void update(String title, String description) {<br />        checkTitleAndDescription(title, description);<br /><br />        this.title = title;<br />        this.description = description;<br />    }<br /><br />    /**<br />     * We don't have to use the builder pattern here because the constructed <br />  * class has only two String fields. However, I use the builder pattern <br />  * in this example because it makes the code a bit easier to read.<br />     */<br />    static class Builder {<br /><br />        private String description;<br /><br />        private String title;<br /><br />        private Builder() {}<br /><br />        Builder description(String description) {<br />            this.description = description;<br />            return this;<br />        }<br /><br />        Builder title(String title) {<br />            this.title = title;<br />            return this;<br />        }<br /><br />        Todo build() {<br />            Todo build = new Todo(this);<br /><br />            build.checkTitleAndDescription(build.getTitle(), build.getDescription());<br /><br />            return build;<br />        }<br />    }<br /><br />    private void checkTitleAndDescription(String title, String description) {<br />        notNull(title, "Title cannot be null");<br />        notEmpty(title, "Title cannot be empty");<br />        isTrue(title.length() &lt;= MAX_LENGTH_TITLE,<br />                "Title cannot be longer than %d characters",<br />                MAX_LENGTH_TITLE<br />        );<br /><br />        if (description != null) {<br />            isTrue(description.length() &lt;= MAX_LENGTH_DESCRIPTION,<br />                    "Description cannot be longer than %d characters",<br />                    MAX_LENGTH_DESCRIPTION<br />            );<br />        }<br />    }<br />}<br />      </code></pre><code></code><br /><strong>Additional Reading:</strong><br /><ul><li><a href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=2">Item 2: Consider a builder when faced with many constructor parameters</a></li></ul>Let's move on and create the repository that communicates with the MongoDB database.<br /><h4>Creating the Repository</h4>We have to create the repository interface that is used to save <em>Todo</em> objects to MondoDB database and retrieve <em>Todo</em> objects from it.<br />If we don’t want to use the Java 8 support of Spring Data, we could create our repository by creating an interface that extends the <em>CrudRepository&lt;T, ID&gt;</em> interface. However, because we want to use the Java 8 support, we have to follow these steps:<br /><ol><li>Create an interface that extends the <em>Repository&lt;T, ID&gt;</em> interface.</li><li>Add the following repository methods to the created interface: <ol><li>The <em>void delete(Todo deleted)</em> method deletes the todo entry that is given as a method parameter.</li><li>The <em>List&lt;Todo&gt; findAll()</em> method returns all todo entries that are found from the database.</li><li>The <em>Optional&lt;Todo&gt; findOne(String id)</em> method returns the information of a single todo entry. If no todo entry is found, this method returns an empty <em>Optional</em>.</li><li>The <em>Todo save(Todo saved)</em> method saves a new todo entry to the database and returns the the saved todo entry.</li></ol></li></ol>The source code of the <em>TodoRepository</em> interface looks as follows:<br /><code>      </code><br /><pre><code>import org.springframework.data.repository.Repository;<br /><br />import java.util.List;<br />import java.util.Optional;<br /><br />interface TodoRepository extends Repository&lt;Todo, String&gt; {<br /><br />    void delete(Todo deleted);<br /><br />    List&lt;Todo&gt; findAll();<br /><br />    Optional&lt;Todo&gt; findOne(String id);<br /><br />    Todo save(Todo saved);<br />}<br />      </code></pre><code></code><br /><strong>Additional Reading:</strong><br /><ul><li><a href="http://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" target="_blank">The Javadoc of the <em>CrudRepository&lt;T, ID&gt;</em> interface</a></li><li><a href="http://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html">The Javadoc of the <em>Repository&lt;T, ID&gt; interface</em></a></li><li><a href="http://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#repositories">Spring Data MongoDB Reference Manual: 5. Working with Spring Data Repositories</a></li><li><a href="http://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#repositories.definition-tuning">Spring Data MongoDB Reference Manual: 5.3.1 Fine-tuning repository definition</a></li></ul>Let’s move on and create the service layer of our example application.<br /><h4>Creating the Service Layer</h4><strong>First</strong>, we have to create a service interface that provides CRUD operations for todo entries. The source code of the <em>TodoService</em> interface looks as follows:<br /><code>      </code><br /><pre><code>import java.util.List;<br /><br />interface TodoService {<br /><br />    TodoDTO create(TodoDTO todo);<br /><br />    TodoDTO delete(String id);<br /><br />    List&lt;TodoDTO&gt; findAll();<br /><br />    TodoDTO findById(String id);<br /><br />    TodoDTO update(TodoDTO todo);<br />}<br />      </code></pre><code></code><br />The <em>TodoDTO</em> class is a DTO that contains the information of a single todo entry. We will talk more about it when we create the web layer of our example application.<br /><strong>Second</strong>, we have to implement the TodoService interface. We can do this by following these steps:<br /><ol><li>Inject our repository to the service class by using constructor injection.</li><li>Add a <em>private Todo findTodoById(String id)</em> method to the service class and implement it by either returning the found <em>Todo</em> object or throwing the <em>TodoNotFoundException</em>.</li><li>Add a <em>private TodoDTO convertToDTO(Todo model)</em> method the service class and implement it by converting the <em>Todo</em> object into a <em>TodoDTO</em> object and returning the created object.</li><li>Add a <em>private List&lt;TodoDTO&gt; convertToDTOs(List&lt;Todo&gt; models)</em> and implement it by converting the list of <em>Todo</em> objects into a list of <em>TodoDTO</em> objects and returning the created list.</li><li>Implement the <em>TodoDTO create(TodoDTO todo)</em> method. This method creates a new <em>Todo</em> object, saves the created object to the MongoDB database, and returns the information of the created todo entry.</li><li>Implement the <em>TodoDTO delete(String id)</em> method. This method finds the deleted <em>Todo</em> object, deletes it, and returns the information of the deleted todo entry. If no <em>Todo</em> object is found with the given id, this method throws the <em>TodoNotFoundException</em>.</li><li>Implement the <em>List&lt;TodoDTO&gt; findAll()</em> method. This methods retrieves all <em>Todo</em> objects from the database, transforms them into a list of <em>TodoDTO</em> objects, and returns the created list.</li><li>Implement the <em>TodoDTO findById(String id)</em> method. This method finds the <em>Todo</em> object from the database, converts it into a <em>TodoDTO</em> object, and returns the created <em>TodoDTO</em> object. If no todo entry is found, this method throws the <em>TodoNotFoundException</em>.</li><li>Implement the <em>TodoDTO update(TodoDTO todo)</em> method. This method finds the updated <em>Todo</em> object from the database, updates its <em>title</em> and <em>description</em>, saves it, and returns the updated information. If the updated <em>Todo</em> object is not found, this method throws the <em>TodoNotFoundException</em>.</li></ol>The source code of the <em>MongoDBTodoService</em> looks as follows:<br /><code>      </code><br /><pre><code>import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Service;<br /><br />import java.util.List;<br />import java.util.Optional;<br /><br />import static java.util.stream.Collectors.toList;<br /><br />@Service<br />final class MongoDBTodoService implements TodoService {<br /><br />    private final TodoRepository repository;<br /><br />    @Autowired<br />    MongoDBTodoService(TodoRepository repository) {<br />        this.repository = repository;<br />    }<br /><br />    @Override<br />    public TodoDTO create(TodoDTO todo) {<br />        Todo persisted = Todo.getBuilder()<br />                .title(todo.getTitle())<br />                .description(todo.getDescription())<br />                .build();<br />        persisted = repository.save(persisted);<br />        return convertToDTO(persisted);<br />    }<br /><br />    @Override<br />    public TodoDTO delete(String id) {<br />        Todo deleted = findTodoById(id);<br />        repository.delete(deleted);<br />        return convertToDTO(deleted);<br />    }<br /><br />    @Override<br />    public List<tododto> findAll() {<br />        List<todo> todoEntries = repository.findAll();<br />        return convertToDTOs(todoEntries);<br />    }<br /><br />    private List<tododto> convertToDTOs(List<todo> models) {<br />        return models.stream()<br />                .map(this::convertToDTO)<br />                .collect(toList());<br />    }<br /><br />    @Override<br />    public TodoDTO findById(String id) {<br />        Todo found = findTodoById(id);<br />        return convertToDTO(found);<br />    }<br /><br />    @Override<br />    public TodoDTO update(TodoDTO todo) {<br />        Todo updated = findTodoById(todo.getId());<br />        updated.update(todo.getTitle(), todo.getDescription());<br />        updated = repository.save(updated);<br />        return convertToDTO(updated);<br />    }<br /><br />    private Todo findTodoById(String id) {<br />        Optional<todo> result = repository.findOne(id);<br />        return result.orElseThrow(() -&gt; new TodoNotFoundException(id));<br /><br />    }<br /><br />    private TodoDTO convertToDTO(Todo model) {<br />        TodoDTO dto = new TodoDTO();<br /><br />        dto.setId(model.getId());<br />        dto.setTitle(model.getTitle());<br />        dto.setDescription(model.getDescription());<br /><br />        return dto;<br />    }<br />}<br />      </todo></todo></tododto></todo></tododto></code></pre><code></code><br />We have now created the service layer of our example application. Let's move on and create the controller class.<br /><h4>Creating the Controller Class</h4><strong>First</strong>, we need to create the DTO class that contains the information of a single todo entry and specifies the validation rules that are used to ensure that only valid information can be saved to the database. The source code of the <em>TodoDTO</em> class looks as follows:<br /><code>      </code><br /><pre><code>import org.hibernate.validator.constraints.NotEmpty;<br /><br />import javax.validation.constraints.Size;<br /><br />public final class TodoDTO {<br /><br />    private String id;<br /><br />    @Size(max = Todo.MAX_LENGTH_DESCRIPTION)<br />    private String description;<br /><br />    @NotEmpty<br />    @Size(max = Todo.MAX_LENGTH_TITLE)<br />    private String title;<br /><br />    //Constructor, getters, and setters are omitted<br />}<br />      </code></pre><code></code><br /><strong>Additional Reading:</strong><br /><ul><li><a href="http://docs.jboss.org/hibernate/validator/5.0/reference/en-US/html_single/">The Reference Manual of Hibernate Validator 5.0.3</a></li></ul><strong>Second</strong>, we have to create the controller class that processes the HTTP requests send to our REST API and sends the correct response back to the client. We can do this by following these steps:<br /><ol><li>Inject our service to our controller by using constructor injection.</li><li>Add a <em>create()</em> method to our controller and implement it by following these steps: <ol><li>Read the information of the created todo entry from the request body.</li><li>Validate the information of the created todo entry.</li><li>Create a new todo entry and return the created todo entry. Set the response status to 201.</li></ol></li><li>Implement the <em>delete()</em> method by delegating the id of the deleted todo entry forward to our service and return the deleted todo entry.</li><li>Implement the <em>findAll()</em> method by finding the todo entries from the database and returning the found todo entries.</li><li>Implement the <em>findById()</em> method by finding the todo entry from the database and returning the found todo entry.</li><li>Implement the <em>update()</em> method by following these steps: <ol><li>Read the information of the updated todo entry from the request body.</li><li>Validate the information of the updated todo entry.</li><li>Update the information of the todo entry and return the updated todo entry.</li></ol></li><li>Create an <em>@ExceptionHandler</em> method that sets the response status to 404 if the todo entry was not found (<em>TodoNotFoundException</em> was thrown).</li></ol>The source code of the <em>TodoController</em> class looks as follows:<br /><code>      </code><br /><pre><code>import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.http.HttpStatus;<br />import org.springframework.web.bind.annotation.ExceptionHandler;<br />import org.springframework.web.bind.annotation.PathVariable;<br />import org.springframework.web.bind.annotation.RequestBody;<br />import org.springframework.web.bind.annotation.RequestMapping;<br />import org.springframework.web.bind.annotation.RequestMethod;<br />import org.springframework.web.bind.annotation.ResponseStatus;<br />import org.springframework.web.bind.annotation.RestController;<br /><br />import javax.validation.Valid;<br />import java.util.List;<br /><br />@RestController<br />@RequestMapping("/api/todo")<br />final class TodoController {<br /><br />    private final TodoService service;<br /><br />    @Autowired<br />    TodoController(TodoService service) {<br />        this.service = service;<br />    }<br /><br />    @RequestMapping(method = RequestMethod.POST)<br />    @ResponseStatus(HttpStatus.CREATED)<br />    TodoDTO create(@RequestBody @Valid TodoDTO todoEntry) {<br />        return service.create(todoEntry);<br />    }<br /><br />    @RequestMapping(value = "{id}", method = RequestMethod.DELETE)<br />    TodoDTO delete(@PathVariable("id") String id) {<br />        return service.delete(id);<br />    }<br /><br />    @RequestMapping(method = RequestMethod.GET)<br />    List&lt;TodoDTO&gt; findAll() {<br />        return service.findAll();<br />    }<br /><br />    @RequestMapping(value = "{id}", method = RequestMethod.GET)<br />    TodoDTO findById(@PathVariable("id") String id) {<br />        return service.findById(id);<br />    }<br /><br />    @RequestMapping(value = "{id}", method = RequestMethod.PUT)<br />    TodoDTO update(@RequestBody @Valid TodoDTO todoEntry) {<br />        return service.update(todoEntry);<br />    }<br /><br />    @ExceptionHandler<br />    @ResponseStatus(HttpStatus.NOT_FOUND)<br />    public void handleTodoNotFound(TodoNotFoundException ex) {<br />    }<br />}<br /><br />      </code></pre><code></code><br /><strong>Note:</strong> If the validation fails, our REST API returns the validation errors as JSON and sets the response status to 400. If you want to know more about this, read a blog post titled: <a href="http://www.petrikainulainen.net/programming/spring-framework/spring-from-the-trenches-adding-validation-to-a-rest-api/">Spring from the Trenches: Adding Validation to a REST API</a>.<br />That is it. We have now created a REST API that provides CRUD operations for todo entries and saves them to MongoDB database. Let’s summarize what we learned from this blog post.<br /><h3>Summary</h3>This blog post has taught us three things:<br /><ul><li>We can get the required dependencies with Maven by declaring only two dependencies: <em>spring-boot-starter-web</em> and <em>spring-data-mongodb</em>.</li><li>If we are happy with the default configuration of Spring Boot, we can configure our web application by using its auto-configuration support and “dropping” new jars to the classpath.</li><li>We learned to create a simple REST API that saves information to MongoDB database and finds information from it.</li></ul>You can <a href="https://github.com/pkainulainen/java-advent-2014">get the example application of this blog post from Github</a>.  <br/><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></div>