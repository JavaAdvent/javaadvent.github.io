---
id: 55
title: Using Intel Performance Counters To Tune Garbage Collection
date: 2013-12-05T08:00:00+00:00
author: Alexander Turner
layout: post
guid: http://www.javaadvent.com/2013/12/using-intel-performance-counters-to-tune-garbage-collection/
permalink: /2013/12/using-intel-performance-counters-to-tune-garbage-collection.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Alexander Turner
blogger_permalink:
  - /2013/12/using-intel-performance-counters-to.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/8855317980880451253
categories:
  - 2013
  - High performance
  - performance counters
  - performance testing
---
<div dir="ltr" style="text-align: left;"><div dir="ltr" style="text-align: left;"><div dir="ltr" style="text-align: left;"><h1>Introduction</h1>I have to admit that I was shocked. Indeed, quite shaken when I realised this advent calendar post would be about garbage collection. The topic of GC has raised such passion amongst the advocates of Java <i>and</i> those who believe memory management should be manual. Many an article has been written regarding tiny subtle changes in strange looking command line arguments which have fractions of a percentage point performance impact on Java applications. How could I add to this huge body work? I hope this post will not add to the GC hot air but rather be a breath of fresh air instead. Let us not look at the CPU time consumed by the garbage collector or pause times; how about looking at a hidden yet potentially critical aspect of memory management in general and garbage collection in particular: Data caching is one of the major challenges of modern computer software design (the others being instruction caching and multi-core work distribution). Modern CPUs run so fast that main memory has no hope of keeping up. The way that some of this catastrophic performance penalty can be clawed back is caching. Memory is pulled in parallel into high speed cache memory and then the CPU accesses this cache. If we are lucky, and the code causes the CPU to read and write the same memory a few times (inside a loop for example) then the CPU can happily access the cache and be saved from waiting for loads and stores to and from main memory. <i>“How does garbage collection impact on the performance of caches”</i> one might ask? There are many ways, some of them very subtle, however, here is a grab bag of some important ones: The garbage collector traverses references in memory. This causes cache lines (blocks of memory in the cache) to contain the memory surrounding the reference and hence no longer hold other data which the program is using.  Whilst we call it a garbage collector, it is actually an allocator, mover and collector. This really matters when we think about data caching: <br /><ul><li style="text-align: justify;">Allocation: Based on hardware rules, memory addresses are matched to cache lines. If pieces of memory share a cache line but are actually accessed from different threads we get an effect called false sharing. However, if little bits of data are spread out but accessed from the same thread we get poor cache utilisation.</li><li style="text-align: justify;">Moving: Objects are not left in one place throughout their life times. The garbage collector avoids memory fragmentation by moving objects around. This has the interesting effect of guaranteeing that the cache lines associated with the object will no longer be associated with it after a move.</li><li style="text-align: justify;">Collecting: The funny thing is that collecting is the easy bit. It can be as simple as just marking the memory as available for reuse. It is the traversal of the object graphs (multiple roots) to find out what can be collected which is going to cause data cache line loads and thus evict lines from the cache which were being read from or written to by user code.</li></ul>So we can now see that the design of the garbage collector is critical to the operation of the data cache. Swapping which collector we use will not only have a impact on GC pauses and other obvious issues, it will also effect, at a low level and in a fundamental way, all of user code. <br /><h1>An Example</h1>I am not going to present an exhaustive scientific paper on this concept. The purpose of this post is to show an alternative way of approaching JVM tuning. So, I ran a simple, short, multi-threaded patch in my personal synthesiser program Sonic-Field. The patch uses feedback, resonance and a bunch of other concepts to synthesise string instruments and then convolution to place the sounds in an acoustic environment.The reason for picking sonic field is not just because it is of reasonable complexity, highly threaded and uses Spring but because I recently found I could get better performance from it using the CMS garbage collector. Latency with Sonic-Field is of no interest because it is a batch processor. However, the standard Java 7 garbage collector interacted badly with the way Sonic Field writes swap files out to disk when running low on memory. I tried CMS because it keeps the memory down the whole time <i>(in theory – don't flame me)</i> because it constantly attempts to do small garbage collections along side the user threads. If we put all this together we might well come up with a reasonable theory <i>"The CMS garbage collector might give fewer pauses and might be able to keep memory use down but in so doing it will almost certainly cause more data cache misses"</i>. Constantly traversing the reference graph in memory to try and collect dead objects is going to cause cache loads and those loads will cause other data to be flushed from the cache (it has finite size). Thus, when user threads come to read again they will cause more cache misses and so on. Does it matter? That answer will be entirely down to the application and the hardware and the load on the application. I am not, I repeat not, advocating one garbage collector over another! Nevertheless, it is a question I would like to answer so let's answer it for my little test patch. These data cache effects of the garbage collector are not visible from the normal VM profiling tools. This means that they do not get discussed much in the JVM community and they get considered in JVM tuning even less. However, there is a tool (actually several - but I am going to talk about the easiest to use) which can shed some light on the topic. I am talking about Intel's PCM (Performance Counter Monitor). It can be used for code tuning as well, but I thought talking about the GC would be more fun today. <br /><h1>A Worked Example</h1>pcm is just a command line tool. We pass the command line to run Java to it in quotes and it does its measurements. With other tooling, the performance counters can be used to get all sorts of other detail about an application. The benefit of the pcm command line tool is its simplicity and lack of intrusion into the over all application run. The disadvantage is that it will measure the JVM and application warm up phases. However, for server style applications or batch processors (like Sonic Field) these overheads are usually trivial compared to the actual application run. I ran my patch on my personal Macbook Pro Retina (2012) with 16Gig of RAM. The JVM was: <br /><pre style="font-size: 75%;">java version "1.8.0-ea"<br /><br />Java(TM) SE Runtime Environment (build 1.8.0-ea-b61)<br /><br />Java HotSpot(TM) 64-Bit Server VM (build 25.0-b05, mixed mode)<br /></pre>Readings from pcm are simply written to standard out when the application exits. I compared runs with no settings for the garbage collector (the default therefore) and with my currently preferred set of tweaks. To be honest, I am not sure if the tweaks are optimal; I kind of lifted them from a bunch of online articles... Here is the launch script for Java: <br /><pre><code style="font-size: 75%;">/Users/alexanderturner/x/IntelPerformanceCounterMonitorV2.5.1 2/pcm.x "java -Xmx12G -Xms12G  -DsonicFieldTemp=/Users/alexanderturner/temp -DsonicFieldThreads=12 -DsonicFieldSwapLimit=4.0  -XX:+UseConcMarkSweepGC -XX:+UseCompressedOops -XX:ParallelGCThreads=8 -XX:+CMSParallelRemarkEnabled -XX:CMSInitiatingOccupancyFraction=60 -XX:+UseCMSInitiatingOccupancyOnly -classpath bin:spring-framework-3.1.2.RELEASE/dist/org.springframework.asm-3.1.2.RELEASE.jar:spring/spring-framework-3.1.2.RELEASE/dist/org.springframework.beans-3.1.2.RELEASE.jar:spring-framework-3.1.2.RELEASE/dist/org.springframework.core-3.1.2.RELEASE.jar:spring/spring/spring-framework-3.1.2.RELEASE/dist/org.springframework.context-3.1.2.RELEASE.jar:<br />spring/spring-framework-3.1.2.RELEASE/dist/org.springframework.context-support-3.1.2.RELEASE.jar:<br />spring/spring-framework-3.1.2.RELEASE/dist/org.springframework.expression-3.1.2.RELEASE.jar:<br />spring/spring-framework-3.1.2.RELEASE/dist/org.springframework.test-3.1.2.RELEASE.jar:<br />spring/otherJars/commons-logging-1.1.1.jar com.nerdscentral.sfpl.RenderRunner $1"<br /></code><br /></pre>Hopefully it is clear just how simple running Java under <i>Intel Performance Counter Monitor v2</i> really is. So, here is the output:  <br /><h2 style="text-align: justify;">Standard GC</h2><table style="font-size:75%"><tr><th>Core (SKT)</th><th>EXEC</th><th>IPC</th><th>FREQ</th><th>AFREQ</th><th>L3MISS</th><th>L2MISS</th><th>L3HIT</th><th>L2HIT</th><th>L3CLK</th><th>L2CLK</th><th>READ</th><th>WRITE</th><th>TEMP</th></tr><tr><td>0</td>       <td>0.53</td>   <td>0.75</td>   <td>0.70</td>    <td>1.31</td>     <td>422 M</td>    <td>621 M</td>    <td>0.32</td>    <td>0.32</td>    <td>0.14</td>    <td>0.01</td>     <td>N/A</td>     <td>N/A</td>     <td>32</td></tr><td>  2  </td>       <td>   0.56 </td>    <td>  0.77 </td>    <td>  0.73  </td>    <td>  1.31  </td>    <td>   346 M   </td>    <td> 466 M </td>    <td>   0.26  </td>    <td>  0.31 </td>    <td>   0.11  </td>    <td>  0.01  </td>    <td>   N/A   </td>    <td>  N/A</td>    <td>     28</td></tr><tr><td>1</td><td>0.22</td><td>0.69</td><td>0.32</td><td>1.31</td><td>144 M</td><td>192 M</td><td>0.25</td><td>0.28</td><td>0.11</td><td>0.01</td><td>N/A</td><td>N/A</td><td>32</td></tr><tr>    <td>3</td><td>0.21</td><td>0.68</td><td>0.31</td><td>1.31</td><td>135 M</td><td>171 M</td><td>0.21</td><td>0.28</td><td>0.10</td><td>0.01</td><td>N/A</td><td>N/A</td><td>28</td></tr><tr>    <td>4</td><td>0.55</td><td>0.77</td><td>0.71</td><td>1.31</td><td>332 M</td><td>410 M</td><td>0.19</td><td>0.38</td><td>0.11</td><td>0.01</td><td>N/A</td><td>N/A</td><td>22</td></tr><tr>    <td>7</td><td>0.18</td><td>0.68</td><td>0.26</td><td>1.30</td><td>124 M</td><td>134 M</td><td>0.08</td><td>0.30</td><td>0.11</td><td>0.00</td><td>N/A</td><td>N/A</td><td>27</td></tr><tr>    <td>5</td><td>0.19</td><td>0.68</td><td>0.29</td><td>1.31</td><td>133 M</td><td>155 M</td><td>0.14</td><td>0.30</td><td>0.11</td><td>0.00</td><td>N/A</td><td>N/A</td><td>22</td></tr><tr>    <td>6</td><td>0.61</td><td>0.79</td><td>0.78</td><td>1.32</td><td>343 M</td><td>382 M</td><td>0.10</td><td>0.35</td><td>0.10</td><td>0.00</td><td>N/A</td><td>N/A</td><td>27</td></tr></table>    ---------------------------------------------------------------------------------------------------- <br /><table style="font-size: 75%; right-padding: 10px;">  <tbody><tr>    <td>SKT</td>   <td>0</td>   <td>0.38</td>  <td>0.75</td>   <td>0.51</td>    <td>1.31</td>    <td>1982 M</td>   <td>2533 M</td>    <td>0.22</td>    <td>0.33</td>    <td>0.11</td>    <td>0.01</td>     <td>N/A</td>     <td>N/A</td>     <td>22</td>     </tr></tbody></table><span style="font-size: 70%;"> Instructions retired: 2366 G ; Active cycles: 3166 G ; Time (TSC):  773 Gticks ; C0 (active,non-halted) core residency: 39.04 %</span> --------------------------------------------------------------------------------------------------- <br /><table style="font-size: 75%; right-padding: 10px;">  <tbody><tr>    <td>TOTAL</td><td>*</td>   <td>0.38</td>  <td>0.75</td>   <td>0.51</td>    <td>1.31</td>    <td>1982 M</td>   <td>2533 M</td>    <td>0.22</td>    <td>0.33</td>    <td>0.11</td>    <td>0.01</td>     <td>N/A</td>     <td>N/A</td>     <td>N/A</td>     </tr></tbody></table><br /><span style="font-size: 75%;">C: 1.49 =&gt; corresponds to 37.36 % utilization for cores in active state.&nbsp;</span><span style="font-size: 75%;">Instructions per no C1 core residency: 23.92 %;&nbsp;</span><span style="font-size: 75%;">C3 core residency: 0.01 %; C6 core residency: 0.00 %; C7 core residency: 37.02 %  C2 package residency: 0.00 %; C3 package residency: 0.00 %; C6 package residency: 0.00 %; C7 package residency: 0.00 %   PHYSICAL CORE I Pminal CPU cycle: 0.76 =&gt; corresponds to 19.12 % core utilization over time interval</span><br /><h2 style="text-align: justify;">Concurrent Mark Sweep</h2><div style="text-align: justify;">Rather than  </div> <pre><div style="font-size:75%"><br />-XX:+UseConcMarkSweepGC<br />-XX:+UseCompressedOops<br />-XX:+CMSParallelRemark<br />-XX:ParallelGCThreads=Enabled<br />-XX:CMSInitiatingOccupancyFraction=60<br />-XX:+UseCMSInitiatingOccupancyOnly<br /></div><br /></pre> <table style="font-size: 75%;"><tbody><tr><th>Core (SKT)</th><th>EXEC</th><th>IPC</th><th>FREQ</th><th>AFREQ</th><th>L3MISS</th><th>L2MISS</th><th>L3HIT</th><th>L2HIT</th><th>L3CLK</th><th>L2CLK</th><th>READ</th><th>WRITE</th><th>TEMP</th></tr><tr><td>0</td>       <td>0.53</td>   <td>0.69</td>   <td>0.76</td>    <td>1.31</td>     <td>511 M</td>    <td>781 M</td>    <td>0.35</td>    <td>0.35</td>    <td>0.17</td>    <td>0.02</td>     <td>N/A</td>     <td>N/A</td>     <td>26</td></tr><tr><td>2  </td>       <td>0.54 </td>    <td>0.71 </td>    <td>0.75  </td>    <td>1.31  </td>    <td>418 M   </td>    <td>586 M </td>    <td>0.29  </td>    <td>0.40 </td>    <td>0.14  </td>    <td>0.01  </td>    <td>N/A   </td>    <td>N/A</td>    <td>29</td></tr><tr> <td>1</td><td>0.31</td><td>0.66</td><td>0.47</td><td>1.30</td><td>207 M</td><td>285 M</td><td>0.27</td><td>0.26</td><td>0.11</td><td>0.01</td><td>N/A</td><td>N/A</td><td>26</td></tr><tr><td>3</td><td>0.21</td><td>0.68</td> <td>0.31</td>    <td>1.31</td>    <td>135 M</td>    <td>171 M</td>    <td>0.21</td>    <td>0.28</td>    <td>0.10</td>    <td>0.01</td>    <td>N/A</td>    <td>N/A</td>    <td>28</td></tr> <tr>    <td>4</td>    <td>0.55</td>    <td>0.77</td>    <td>0.71</td>    <td>1.31</td>    <td>332 M</td>    <td>410 M</td>    <td>0.19</td>    <td>0.38</td>    <td>0.11</td>    <td>0.01</td>    <td>N/A</td>    <td>N/A</td>    <td>22</td></tr> <tr>    <td>7</td><td>0.18</td><td>0.68</td><td>0.26</td><td>1.30</td><td>124 M</td><td>134 M</td><td>0.08</td><td>0.30</td><td>0.11</td><td>0.00</td><td>N/A</td><td>N/A</td><td>27</td></tr> <tr>    <td>5</td><td>0.19</td><td>0.68</td><td>0.29</td><td>1.31</td><td>133 M</td><td>155 M</td><td>0.14</td><td>0.30</td><td>0.11</td><td>0.00</td><td>N/A</td><td>N/A</td><td>22</td></tr> <tr><td>6</td><td>0.61</td><td>0.79</td><td>0.78</td><td>1.32</td><td>343 M</td><td>382 M</td><td>0.10</td><td>0.35</td><td>0.10</td><td>0.00</td><td>N/A</td><td>N/A</td><td>27</td></tr> <tr><td>3</td><td>0.30</td><td>0.66</td><td>0.46</td><td>1.30</td><td>198 M</td><td>258 M</td><td>0.23</td><td>0.27</td><td>0.11</td><td>0.01</td><td>N/A</td><td>N/A</td><td>29</td></tr> <tr><td>4</td><td>0.59</td><td>0.73</td><td>0.81</td><td>1.31</td><td>397 M</td><td>504 M</td><td>0.21</td><td>0.46</td><td>0.12</td><td>0.01</td><td>N/A</td><td>N/A</td><td>29</td></tr> <tr>    <td>7</td><td>0.30</td><td>0.66</td><td>0.45</td><td>1.30</td><td>186 M</td><td>204 M</td><td>0.09</td><td>0.29</td><td>0.11</td><td>0.00</td><td>N/A</td><td>N/A</td><td>30</td></tr> <tr><td>7</td><td>0.30</td><td>0.66</td><td>0.45</td><td>1.30</td><td>186 M</td><td>204 M</td><td>0.09</td><td>0.29</td><td>0.11</td><td>0.00</td><td>N/A</td><td>N/A</td><td>30</td></tr> <tr>    <td>5</td><td>0.30</td><td>0.66</td><td>0.45</td><td>1.30</td><td>188 M</td><td>225 M</td><td>0.16</td><td>0.28</td><td>0.11</td><td>0.01</td><td>N/A</td><td>N/A</td><td>29</td></tr> <tr>    <td>6</td><td>0.58</td><td>0.73</td><td>0.79</td><td>1.31</td><td>414 M</td><td>466 M</td><td>0.11</td><td>0.49</td><td>0.13</td><td>0.00</td><td>N/A</td><td>N/A</td><td>30</td></tr></tbody></table> ---------------------------------------------------------------------------------------------------- <div style="font-size: 75%;"> SKT    0     0.43   0.70   0.62    1.31    2523 M   3313 M    0.24    0.38    0.13    0.01     N/A     N/A     25 </div><div style="font-size: 70%;"> Instructions retired: 2438 G ; Active cycles: 3501 G ; Time (TSC):  708 Gticks ; C0 (active,non-halted) core residency: 47.22 % </div>---------------------------------------------------------------------------------------------------- <span style="font-size: 75%;"> TOTAL  *     0.43   0.70   0.62    1.31    2523 M   3313 M    0.24    0.38    0.13    0.01     N/A     N/A     N/A </span> <br/><div style="font-size: 75%;">C: 1.39 =&gt; corresponds to 34.83 % utilization for cores in active state. Instructions per no C1 core residency: 17.84 %; C3 core residency: 0.01 %; C6 core residency: 0.01 %; C7 core residency: 34.92 % C2 package residency: 0.00 %; C3 package residency: 0.00 %; C6 package residency: 0.00 %; C7 package residency: 0.00 % </div><br/> PHYSICAL CORE I <br/> <span style="font-size:80%;">Pminal CPU cycle: 0.86 =&gt; corresponds to 21.51 % core utilization over time interval. All the information given here is of interest, however, there is so much of it I figure the best thing to do is cut the the case and test my assertion about the CMS collector. To do that we can look at just two lines form the output for each run: </span></div>  <br/><b>Default:</b><br/><span style="font-size:70%">   SKT    0     0.38   0.75   0.51    1.31    <b>1982 M   2533 M</b>    0.22    0.33    0.11    0.01     N/A     N/A     22</span><br/><span style="font-size:70%">Instructions retired: 2366 G ; Active cycles: 3166 G ; Time (TSC):  773 Gticks ; C0 (active,non-halted) core residency: 39.04 %</span><br/><b>CMS:</b><br/> <span style="font-size:70%">0     0.43   0.70   0.62    1.31   <b> 2523 M   3313 M</b>    0.24    0.38    0.13    0.01     N/A     N/A     25</span><br/><b>SKT:</b> <br/> <span style="font-size:70%">Instructions retired: 2438 G ; Active cycles: 3501 G ; Time (TSC):  708 Gticks ; C0 (active,non-halted) core residency: 47.22 %</span>  <div style="text-align: justify;"><br /></div><h2 style="text-align: justify;">Discussion</h2><div style="text-align: justify;font-size:75%;">We can see that under the CMS collector there were substantially more cache misses. The L2 misses were 30% greater and L2 were up 27% over the default collector. Nevertheless, the total time taken in giga ticks (708CMS/773Default) shows that all this extra data missing has not negatively impacted over all performance at all. I guess this means that a lot more research could and should be done before drawing any conclusions as to the correct approach for this application!</div><div style="text-align: justify;font-size:75%;">If you leave this post thinking that I did not fully discuss the subject, you are correct. My intention here has been to get the reader interested in thinking about this aspect of Java performance and opening the door to a new approach.</div><em style="font-size:75%;">Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></div>