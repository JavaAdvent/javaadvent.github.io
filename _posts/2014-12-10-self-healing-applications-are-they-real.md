---
id: 24
title: 'Self-healing applications: are they real?'
date: 2014-12-10T08:30:00+00:00
author: iNikem
layout: post
permalink: /2014/12/self-healing-applications-are-they-real.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Nikita Salnikov-Tarnovski
blogger_permalink:
  - /2014/12/self-healing-applications-are-they-real.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/5479240643996051783
categories:
  - 2014
  - java
  - Java Advent
  - java advent 2014
  - java self healing
  - jdk
  - self healing
  - skynet
---
<p>This post is an example about an application where the first solution to each and every IT problem - “have you tried turning it off and on again” - can actually do more harm than good. Instead, we have an application that can literally heal itself: it fails at the beginning, but starts running smoothly after some time. To give an example of such application in action, we recreated it in the most simple form possible, gathering inspiration from what is now a <a href="http://www.javaspecialists.eu/archive/Issue174.html">five-year old post from the Heinz Kabutz’ Java Newsletter</a>: </p><pre><br /><code><br />package eu.plumbr.test;<br /><br />public class HealMe {<br />  private static final int SIZE = (int) (Runtime.getRuntime().maxMemory() * 0.6);<br /><br />  public static void main(String[] args) throws Exception {<br />    for (int i = 0; i < 1000; i++) {<br />      allocateMemory(i);<br />    }<br />  }<br /><br />  private static void allocateMemory(int i) {<br />    try {<br />      {<br />        byte[] bytes = new byte[SIZE];<br />        System.out.println(bytes.length);<br />      }<br /><br />      byte[] moreBytes = new byte[SIZE];<br />      System.out.println(moreBytes.length);<br /><br />      System.out.println("I allocated memory successfully " + i);<br /><br />    } catch (OutOfMemoryError e) {<br />      System.out.println("I failed to allocate memory " + i);<br />    }<br />  }<br /><br />}<br /></code><br /></pre><p>The code above is allocating two bulks of memory in a loop. Each of those allocation is equal to 60% of the total available heap size. As the allocations occur sequentially in the same method, then one might expect this code to keep throwing <a href="https://plumbr.eu/outofmemoryerror/java-heap-space">java.lang.OutOfMemoryError: Java heap space</a> errors and never successfully complete the allocateMemory() method. </p><p>Let us start with the static analysis of the source code: <ol><li>From the first fast examination, this code really cannot complete, because we try to allocate more memory than is available to JVM.</li><li>If we look closer we can notice that the first allocation takes place in a scoped block, meaning that the variables defined in this block are visible only to this block. This indicates that the <i>bytes</i> should be eligible for GC after the block is completed. And so our code should in fact run fine right from the beginning, as at the time when it tries to allocate <i>moreBytes</i> the previous allocation <i>bytes</i> should be dead.</li><li>If we now look into the compiled classfile, we will see the following bytecode:  <pre><br /><code><br />private static void allocateMemory(int);<br />    Code:<br />       0: getstatic     #3                  // Field SIZE:I<br />       3: newarray       byte<br />       5: astore_1      <br />       6: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br />       9: aload_1       <br />      10: arraylength   <br />      11: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br />      14: getstatic     #3                  // Field SIZE:I<br />      17: newarray       byte<br />      19: astore_1      <br />      20: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;<br />      23: aload_1       <br />      24: arraylength   <br />      25: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V<br />---- cut for brevity ----<br /></code><br /></pre><p>Here we see, that on offsets 3-5 first array is allocated and stored into local variable with index 1. Then, on offset 17 another array is going to be allocated. But first array is still referenced by local variable and so the second allocation should always fail with OOM. Bytecode interpreter just cannot let GC clean up first array, because it is still strongly referenced.</p></li></ol> <p>Our static code analysis has shown us that for two underlying reasons, the presented code should not run successfully and in one case, it should.  Which one out of those three is the correct one? Let us actually run it and see for ourselves. It turns out that both conclusions were correct. First, application fails to allocate memory. But after some time (on my Mac OS X with Java 8 it happens at iteration #255) the allocations start succeeding:</p> <pre><br /> java -Xmx2g eu.plumbr.test.HealMe<br />1145359564<br />I failed to allocate memory 0<br />1145359564<br />I failed to allocate memory 1<br /><br />… cut for brevity ...<br /><br />I failed to allocate memory 254<br />1145359564<br />I failed to allocate memory 255<br />1145359564<br />1145359564<br />I allocated memory successfully 256<br />1145359564<br />1145359564<br />I allocated memory successfully 257<br />1145359564<br />1145359564<br /></pre><p>Self-healing code is a reality! Skynet is near...</p> <p>In order to understand what is really happening we need to think, what changes during program execution? The obvious answer is, of course, Just-In-Time compilation can occur. If you recall, Just-In-Time compilation is a JVM built-in mechanics to optimize code hotspots. For this, the JIT monitors the running code and when a hotspot is detected, JIT compiles your bytecode into native code, performing different optimizations such as method inlining and dead code elimination in the process.</p> <p>Lets see if this is a case  by turning on the following command line options and relaunching the program</p>  <pre><br /><code><br /> -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation  <br /></code><br /></pre><p>This will generate a log file, in our case named hotspot_pid38139.log, where 38139 was the PID of your java process. In this file the following line can be found:</p><pre><br /><code><br /> &lt;task_queued compile_id='94' method='HealMe allocateMemory (I)V' bytes='83' count='256' iicount='256' level='3' stamp='112.305' comment='tiered' hot_count='256'/><br /></code><br /></pre><p>This means, that after executing “allocateMemory” methods 256 times, C1 compiler has decided to queue this method for C1 tier 3 compilation. You can get more information about tiered compilation’s levels and different thresholds <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/104743074675/src/share/vm/runtime/advancedThresholdPolicy.hpp">here</a>. And so our first 256 iterations were run in interpreted mode, where bytecode interpreter, being a simple stack machine, cannot know in advance, if some variable, <i>bytes</i> in this case, will be used further on or not. But JIT sees the whole method at once and so can deduce than <i>bytes</i> will not be used anymore and is, in fact, GC eligible. Thus the garbage collection can eventually take place and our program has magically self-healed. Now, I can only hope none of the readers should actually be responsible for debugging such a case in production. But in case you wish to make someone’s life a misery, introducing code like this to production would be a sure way to achieve this.</p>  <br /><br /><br /><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em>