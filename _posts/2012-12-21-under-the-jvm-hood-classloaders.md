---
id: 66
title: 'Under the JVM hood &#8211; Classloaders'
date: 2012-12-21T09:24:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/under-the-jvm-hood-classloaders/
permalink: /2012/12/under-the-jvm-hood-classloaders.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Simon Maple
blogger_permalink:
  - /2012/12/under-jvm-hood-classloaders.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/2806510574748054674
categories:
  - Classloader
  - java
  - Java Advent
  - JRebel
  - JVM
  - Simon Maple
  - ZeroTurnaround
---
<span style="font-size: x-small;"><b>By Simon Maple, <a href="http://www.twitter.com/sjmaple">@sjmaple</a> - <span style="color: #38761d;">Zero</span>Turnaround Technical Evangelist</b></span><br /><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Classloaders are a low level and often ignored aspect of the Java language among many developers. At </span><a href="http://www.zeroturnaround.com/"><span style="background-color: transparent; color: #1155cc; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: underline; vertical-align: baseline;">ZeroTurnaround</span></a><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">, our developers have had to live, breathe, eat, drink and almost get intimate with classloaders to produce the&nbsp;</span><a href="http://www.zeroturnaround.com/jrebel"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><span style="background-color: transparent; color: #1155cc; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: underline; vertical-align: baseline;">JRebel</span></a><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"> technology which interacts at a classloader level to provide live  runtime class reloading, avoiding lengthy  rebuilds/repackaging/redeploying cycles. Here are some of the things  we've learnt around classloaders including some debugging tips which  will hopefully save you time and potential headdesking in the future.</span><br /><br /><h2 dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 19px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">A classloader is just a plain java object</span></h2><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Yes,  it's nothing clever, well other than the system classloader in the JVM,  a classloader is just a java object! It's an abstract class,  <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ClassLoader</span>, which can be implemented by a class you create. Here is the  API:</span><br /><pre style="border: solid thin gray;"><code>public abstract class ClassLoader {<br /><br /> public Class loadClass(String name);<br /><br /> protected Class defineClass(byte[] b);<br /><br /> public URL getResource(String name);<br /><br /> public Enumeration getResources(String name);<br /><br /> public ClassLoader getParent()<br /><br />}</code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Looks  pretty straightforward, right? Let's take a look method by method.  The central method is <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">loadClass</span> which just takes a <span style="font-family: Arial,Helvetica,sans-serif;">String</span> class name  and returns you the actual <span style="font-family: Arial,Helvetica,sans-serif;">Class</span> object. This  is the method which if you've used classloaders before is probably the  most familiar as it's the most used in day to day coding. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">defineClass</span> is  a final method in the JVM that takes a byte array from a file or a  location on the network and produces the same outcome, a Class object.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">A  classloader can also find resources from a classpath. It works in a  similar way to the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">loadClass</span> method. There are a couple of methods, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">getResource</span> and <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">getResources</span>,  which return a URL or an Enumeration of URLs which point to the resource  which represents the name passed as input to the method.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Every  classloader has a parent; <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">getParent</span> returns the classloaders parent,  which is not Java inheritance related, rather a linked list style  connection. We will look into this in a little more depth later on.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Classloaders  are lazy, so classes are only ever loaded when they are requested at  runtime. Classes are loaded by the resource which invokes the class, so  a class, at runtime, could be loaded by multiple classloaders depending  on where they are referenced from and which classloader loaded the  classes which referen... oops, I’ve gone cross-eyed! Let's look at some  code.</span><br /><pre style="border: solid thin gray;"><code>public class A {<br /><br /> public void doSmth() {<br /><br />    B b = new B();<br /><br />    b.doSmthElse();<br /><br /> }<br /><br />}<br /></code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Here we have class <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">A</span> calling the constructor of class <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">B</span> within the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">doSmth</span> of it's methods. &nbsp;Under the covers this is what is happening</span><br /><pre style="border: solid thin gray;"><code>A.class.getClassLoader().loadClass(“B”);<br /></code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The classloader which originally loaded class <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">A</span> is invoked to load the class <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">B</span>.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><h2 dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 19px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">Classloaders are hierarchical, but like children, they don't always ask their parents</span></h2><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Every  classloader has a parent classloader. When a classloader is asked for a  class, it will typically go straight to the parent classloader first calling <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">loadClass</span> which may in turn ask it's parent and so on. If two classloaders  with the same parent are asked to load the same class, it would only be  done once, by the parent. It gets very troublesome when two  classloaders load the same class separately, as this can cause problems  which we'll look at later.</span><br /><div style="text-align: left;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /></div><div style="text-align: left;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">When  the JEE spec was designed, the web classloader was designed to work the  opposite way - great. Let's take a look at the figure below as our  example. &nbsp;</span></div><div style="text-align: center;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">&nbsp;</span><img height="235" src="https://lh4.googleusercontent.com/GNXZPzXUftTT0N-Wm1Ys0359R65gJOrFpSuDtJKXZ8erhI6xCS4bYUeKUrwrgw_mnJGdrr6fqyeQugFsx9pFWpP4vA5Ca3I6JP6Vo9d2vw1wGRtAGA-g" width="400" /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span></div><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Module  WAR1 has its own classloader and prefers to load classes itself rather  than delegate to it's parent, the classloader scoped by App1.ear. This  means different WAR modules, like WAR1 and WAR2 cannot see each others  classes. The App1.ear module has its own classloader and is parent to  the WAR1 and WAR2 classloaders. &nbsp;The App1.ear classloader is used by the  WAR1 and WAR2 classloaders when they needs to delegate a request up the  hierarchy i.e. a class is required outside of the WAR  classloader scope. Effectively the WAR classes override the EAR classes where both exist.  Finally the EAR classloader's parent is the container classloader. &nbsp;The  EAR classloader will delegate requests to the container classloader,  but it does not do it in the same way as the WAR classloader, as the EAR  classloader will actually prefer to delegate up rather than prefer  local classes. As you can see this is getting quite hairy and is  different to the plain JSE class loading behaviour.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><h2 dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 19px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">The flat classpath</span></h2><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">We  talked about how the system classloader looks to the classpath to find  classes that have been requested. This classpath could include  directories or JAR files and the order which they are looked through is  actually dependant on the JVM you are using. There may be multiple  copies or versions of the class you require on the classpath, but you  will always get the first instance of the class found on the classpath.  &nbsp;It’s essentially just a list of resources, which is why it’s referred to  as flat. As a result the classpath list can often be relatively slow  to iterate through when looking for a resource.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Problems  can occur when applications who are using the same classpath want to  use different versions of a class, lets use Hibernate as an example.  When two versions of Hibernate JARs exist on the classpath, one version cannot be higher up the  classpath for one application than it is for the other, which means both  will have to use the same version. One way around this is to bloat the  application (WAR) with all the libraries necessary, so that they use  their local resources, but this then leads to big applications which are  hard to maintain. Welcome to JAR hell! OSGi provides a solution here  as it allows versioning of JAR files, or bundles, which results in a mechanism to  allow wiring to particular versions of JAR files avoiding the flat classpath  problems.</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><h2 dir="ltr"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 19px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">How do I debug my class loading errors? </span></h2><h3 dir="ltr"><span style="background-color: transparent; color: #666666; font-family: Arial; font-size: 16px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">NoClassDefFoundError/ClassNotFoundException/ClassNoDefFoundException?</span></h3><h3 dir="ltr"><span style="background-color: transparent; color: #666666; font-family: Arial; font-size: 16px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">&nbsp;</span></h3><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">So,  you’ve got an error/exception like the ones above. Well, does the  class actually exist? Don't bother looking in your IDE, as that’s where  you compiled your class, it must be there otherwise you’ll get a  compile time exception. This is a runtime exception so it’s in the  runtime we want to look for the class which it says we’re missing… but  where do you start? Consider the following piece of code...</span><br /><pre style="border: solid thin gray;"><code>Arrays.toString((((URLClassLoader) Test.class.getClassLoader())<br />                                                   .getURLs()));<br /></code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">This  code returns an array list of all jars and directories on the  classpath of the classloader the class <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> is using. So now we can see if the JAR or location our mystery class should  exist in is actually on the classpath. If it does not exist, add it!  If it does exist, check the JAR/directory to make sure your class  actually exists in that location and add it if it's missing. These are  the two typical problems which result in this error case.</span><br /><br /><h3 dir="ltr"><span style="background-color: transparent; color: #666666; font-family: Arial; font-size: 16px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">NoSuchMethodError/NoSuchFieldError/AbstractMethodError/IllegalAccessError?</span></h3><h3 dir="ltr"><span style="background-color: transparent; color: #666666; font-family: Arial; font-size: 16px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">&nbsp;</span></h3><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Now  it’s getting interesting! These are all subclasses of the  IncompatibleClassChangeError. We know the classloader has found the  class we want (by name), but clearly it hasn't found the right version. </span><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Here we have a class called <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> which is making an invocation to another class, <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span>, but BANG - We get an exception! </span>Lets look at the next snippet of code to debug:</span><br /><pre style="border: solid thin gray;"><code>Test.class.getClassLoader().getResource(Util.class.getName()<br />                                .replace('.', '/') + ".class");<br /></code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">We're calling <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">getResource</span> on the classloader of class <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span>. This returns us the URL of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span> resource. Notice  we've replaced the ‘.’ with a ‘/’ and added a ‘.class’ at the end of  the String. This changes the package and classname of the class we’re  looking for (from the perspective of the classloader) into a  directory structure and filename on the filesystem - neat. This will show us the exact class we have  loaded and we can make sure it's the correct version. We can use <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">javap -private</span> on the class at a command prompt  to see the byte code and check which methods and fields actually exist.  You can easily see the structure of the class and validate whether it’s  you or the Java runtime which is going crazy! Believe me, at one stage  or another you'll question both, and nearly every time it will be  you! :o)</span><br /><br /><h3 dir="ltr"><span style="background-color: transparent; color: #666666; font-family: Arial; font-size: 16px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">LinkageError/ClassCastException/IllegalAccessError</span></h3><h3 dir="ltr"><span style="background-color: transparent; color: #666666; font-family: Arial; font-size: 16px; font-style: normal; font-variant: normal; font-weight: bold; text-decoration: none; vertical-align: baseline;">&nbsp;</span></h3><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">These  can occur if two different classloaders load the same class and they  try to interact… ouch! Yes, it’s now getting a bit hairy. This can  cause problems as we do not know if they will load the classes from the  same place. How can this happen? Lets look at the following code, still in the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> class:</span><br /><pre style="border: solid thin gray;"><code>Factory.instance().sayHello();<br /></code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">The  code looks pretty clean and safe, and it’s not clear how an error could  emerge from this line. We're calling a static factory method to get us an instance of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> class and are invoking a method on it. Lets look at this supporting image to show the  reason why an exception is being thrown.</span><br /><br /><div style="text-align: center;"><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><img height="267" src="https://lh5.googleusercontent.com/sMef1cMqOKh-20aK3zQyiAo2aZ2PuRh_1l1l10HLD4BkHBba3ndPlt3eMz7a-aG7t5Hscc9fA8-D3e_O3zDsWmYIv0NEcNTQi5IgQ5S75YEyexTnJyXX" width="320" /></div><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;"></span><br /><span style="font-family: Arial,Helvetica,sans-serif;"><span style="background-color: transparent; color: black; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Here  we can see a web classloader (which loaded the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> class) will prefer local classes, so when  it makes reference to a class, it will be loaded by the web  classloader, if possible. Fairly straightforward so far.&nbsp; The <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> class uses the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Factory</span> class to  get hold of an instance of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span> class which is fairly typical practice in Java,  but the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Factory</span> class doesn’t exist in the WAR as it is an external library.  &nbsp;This is no problem as the web classloader can delegate to the shared classloader, which can see the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Factory</span> class. Note that the shared classloader is now loading it’s own version of the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span> class  as when the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Factory</span> instantiates the class, it uses the shared classloader (as shown in the first example earlier). The <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Factory</span> class returns the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span> object (created by the shared classloader) back to the WAR, which then tries to use the class, and effectively cast the class to a potentially different version of the same class (the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span> class visible to the web classloader). BOOM!</span></span><br /><span style="font-family: Arial,Helvetica,sans-serif;"><br /></span><span style="font-family: Arial,Helvetica,sans-serif;"><span style="background-color: transparent; color: black; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">We  can run the same code as before from within both places (The <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Factory.instance()</span> method  and the <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Test</span> class) to see where each of our <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Util</span> classes are being  loaded from.</span></span><br /><pre style="border: solid thin gray;"><code>Test.class.getClassLoader().getResource(Util.class.getName()<br />                                .replace('.', '/') + ".class"));<br /></code></pre><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">Hopefully this has given you an insight into the world of classloading, and instead of not understanding the classloader, you can now appreciate it  with a hint of fear and uncertainty! Thanks for reading and making it  to the end. We’d all like to wish you a Merry Christmas and a happy new  year from ZeroTurnaround! &nbsp;Happy coding!</span><br /><span style="background-color: transparent; color: black; font-family: Arial; font-size: 15px; font-style: normal; font-variant: normal; font-weight: normal; text-decoration: none; vertical-align: baseline;">&nbsp;</span> <br /><i>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</i>