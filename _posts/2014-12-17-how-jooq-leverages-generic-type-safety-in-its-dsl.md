---
id: 16
title: How jOOQ Leverages Generic Type Safety in its DSL
date: 2014-12-17T08:30:00+00:00
author: Lukas Eder
layout: post
permalink: /2014/12/how-jooq-leverages-generic-type-safety-in-its-dsl.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Lukas Eder
blogger_permalink:
  - /2014/12/how-jooq-leverages-generic-type-safety.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/6760406783572429620
image: /content/uploads/2014/12/cable-mess-825x510.png
categories:
  - DSL
  - generics
  - java 8
  - Java Advent
  - java advent 2014
  - jooq
  - SQL
  - type safety
---
<div dir="ltr" style="text-align: left;">In this year's Java Advent Calendar, we're thrilled to have been asked to feature a mini-series showing you a couple of advanced and very interesting topics that we've been working on when developing <a href="http://www.jooq.org/" title="jOOQ: The best way to write SQL in Java">jOOQ</a>.<br /><br />The series consists of:<br /><br /><ul><li><a href="http://www.javaadvent.com/2014/12/how-jooq-leverages-generic-type-safety-in-its-dsl/">Dec 17: How jOOQ Leverages Generic Type Safety in its DSL</a></li><li>Dec 18: How jOOQ Allows for Fluent Functional-Relational Interactions in Java 8</li><li>Dec 19: How jOOQ Helps Pretend that Your Stored Procedures are a Part of Java</li></ul><br />Don't miss any of these!<br /><br /><h2 style="font-size: 2em;">How jOOQ leverages generic type safety in its DSL</h2><br />Few Java developers are aware of this, but SQL is a very type safe language. In the Java ecosystem, if you're using JDBC, you're operating on dynamically constructed SQL strings, which are sent to the server for execution - or failure. Some IDEs may have started to be capable of introspecting parts of your static SQL, but often you're concatenating predicates to form a very dynamic query:<br /><br /><code></code><br /><pre><code>String sql = "SELECT a, b, c FROM table WHERE 1 = 1";<br /><br />if (someCondition)<br />    sql += " AND id = 3";<br /><br />if (someOtherCondition)<br />    sql += " AND value = 42";<br /></code></pre><br /><br />These concatenations quickly turn nasty and are one of the reasons why Java developers don't really like SQL<br /><br /><br /><div style="clear: both; text-align: center;"><a href="http://www.flickr.com/photos/grggrssmr/3552692789/in/photostream/" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-ecEaUza0o_E/VImZ-p5BPMI/AAAAAAAABNM/YEFG-PJL3w0/s640/cable-mess.png" /></a></div><br /><br /><sub><a href="http://www.jooq.org/hacking-jdbc">SQL as written via JDBC</a>. <a href="http://www.flickr.com/photos/grggrssmr/3552692789/in/photostream/">Image (c) by Greg Grossmeier. License CC-BY-SA 2.0</a></sub><br /><br />But interestingly, PL/SQL or T-SQL developers never complain about SQL in this way. In fact, they feel quite the opposite. Look at how SQL is nicely embedded in a typical PL/SQL block:<br /><br /><code></code><br /><pre><code>BEGIN<br /><br />    -- The record type of "rec" is inferred by the compiler<br />    FOR rec IN (<br /><br />        -- This compiles only when I have matching<br />        -- degrees and types of both UNION subselects!<br />        SELECT first_name, last_name FROM customers<br />        UNION<br />        SELECT first_name, last_name FROM staff<br />    )<br />    LOOP<br /><br />        -- This compiles only if rec really has<br />        -- first_name and last_name columns<br />        INSERT INTO people (first_name, last_name)<br /><br />        -- Obviously, VALUES must match the above target table<br />        VALUES (rec.first_name, rec.last_name);<br />    END LOOP;<br />END;<br /></code></pre><br /><br />Now, we can most certainly discuss syntax. Whether you like SQL's COBOLesque syntax or not is a matter of taste and a matter of habit, too. But one thing is clear, SQL is absolutely type safe, and most sane people would consider that a very good thing. Read <a href="http://blog.jooq.org/2014/12/11/the-inconvenient-truth-about-dynamic-vs-static-typing/">The Inconvenient Truth About Dynamic vs. Static Typing</a> for more details.<br /><br /><h2 style="font-size: 2em;">The same can be achieved in Java!</h2><br />JDBC's lack of type safety is a brilliant feature for the low-level API that JDBC is. At some point, we need an API that can simply send SQL strings over the wire without knowing anything about the wire protocol, and retrieve back cursors of arbitrary / unknown type. However, if we don't execute our SQL directly via JDBC, but maintain a type safe SQL AST (<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>) prior to query execution, then we might actually anticipate the returned type of our statements.<br /><br />jOOQ's DSL API (<a href="http://en.wikipedia.org/wiki/Domain-specific_language">Domain-specific language</a>) works exactly like that. When you create SQL statements with jOOQ, you're implicitly creating an AST both for your Java compiler, but also for your runtime environment. Here's how that works:<br /><br /><code></code><br /><pre><code>DSL.using(configuration)<br />   .select(CUSTOMERS.FIRST_NAME, CUSTOMERS.LAST_NAME).from(CUSTOMERS)<br />   .union(<br />    select(STAFF.FIRST_NAME,     STAFF.LAST_NAME    ).from(STAFF))<br />   .fetch();<br /></code></pre><br /><br />If we look closely at what the above query really does, we'll see that we're calling one of several overloaded <code>select()</code> methods on jOOQ's <a href="http://www.jooq.org/javadoc/latest/org/jooq/DSLContext.html"><code>DSLContext</code></a> class, namely <a href="http://www.jooq.org/javadoc/latest/org/jooq/DSLContext.html#select-org.jooq.Field-org.jooq.Field-"><code>DSLContext.select(Field, Field)</code>, the one that takes two argument columns</a>.<br /><br />The whole API looks like this, and we'll see immediately after why this is so useful:<br /><br /><code></code><br /><pre><code>&lt;T1&gt; SelectSelectStep&lt;Record1&lt;T1&gt;&gt; <br />     select(Field&lt;T1&gt; field1);<br />&lt;T1, T2&gt; SelectSelectStep&lt;Record2&lt;T1, T2&gt;&gt; <br />         select(Field&lt;T1&gt; field1, Field&lt;T2&gt; field2);<br />&lt;T1, T2, T3&gt; SelectSelectStep&lt;Record3&lt;T1, T2, T3&gt;&gt; <br />             select(Field&lt;T1&gt; field1, Field&lt;T2&gt; field2, Field&lt;T3&gt; field3);<br />// and so on...<br /></code></pre><br /><br />So, by explicitly passing two columns to the <code>select()</code> method, you have chosen the second one of the above methods that returns a DSL type that is parameterised with <code>Record2</code>, or more specifically, with <code>Record2&lt;String, String&gt;</code>. Yes, the <code>String</code> parameter bindings are inferred from the very columns that we passed to the <code>select()</code> call, because <a href="http://www.jooq.org/doc/3.5/manual/code-generation/">jOOQ's code generator</a> reverse-engineers your database schema and generates those classes for you.<br /><br />The generated <code>Customers</code> class really looks like this (simplified):<br /><br /><code></code><br /><pre><code>// All table references are listed here:<br />class Tables {<br />    Customers CUSTOMERS = new Customers();<br />    Staff STAFF = new Staff();<br />}<br /><br />// All tables have an individual class each, with columns inside:<br />class Customers {<br />    final Field&lt;String&gt; FIRST_NAME = ...<br />    final Field&lt;String&gt; LAST_NAME = ...<br />}<br /></code></pre><br /><br />As you can see, all type information is already available to you, automatically, as you have defined those types only once in the database. No need to define them again in Java.<br /><br /><h2 style="font-size: 2em;">Generic type information is ubiquitous</h2><br />The interesting part is the <code>UNION</code>. The <a href="http://www.jooq.org/javadoc/latest/org/jooq/SelectUnionStep.html#union-org.jooq.Select-"><code>union()</code></a> method on the DSL API simply looks like this:<br /><br /><code></code><br /><pre><code>public interface SelectUnionStep&lt;R extends Record&gt; {<br />    SelectOrderByStep&lt;R&gt; union(Select&lt;? extends R&gt; select);<br />}<br /></code></pre><br /><br />If we go back to our statement, we can see that the type of the object upon which we call <code>union()</code> is really this type:<br /><br /><code></code><br /><pre><code>SelectUnionStep&lt;Record2&lt;String, String&gt;&gt;<br /></code></pre><br /><br />... thus, the method <code>union()</code> that we're calling is really expecting an argument of this type:<br /><br /><code></code><br /><pre><code>union(Select&lt;? extends Record2&lt;String, String&gt;&gt; select);<br /></code></pre><br /><br />... which essentially means that we'll get a compilation error if we don't provide two string columns also in the second subselect:<br /><br /><code></code><br /><pre><code>DSL.using(configuration)<br />   .select(CUSTOMERS.FIRST_NAME, CUSTOMERS.LAST_NAME).from(CUSTOMERS)<br />   .union(<br />//  ^^^^^ doesn't compile, wrong argument type!<br />    select(STAFF.FIRST_NAME).from(STAFF))<br />   .fetch();<br /></code></pre><br /><br />or also:<br /><br /><code></code><br /><pre><code>DSL.using(configuration)<br />   .select(CUSTOMERS.FIRST_NAME, CUSTOMERS.LAST_NAME).from(CUSTOMERS)<br />   .union(<br />//  ^^^^^ doesn't compile, wrong argument type!<br />    select(STAFF.FIRST_NAME, STAFF.DATE_OF_BIRTH).from(STAFF))<br />   .fetch();<br /></code></pre><br /><br /><h2 style="font-size: 2em;">Static type checking helps finding bugs early</h2><br />... indeed! All of the above bugs can be found at compile-time because your Java compiler will not accept the wrong SQL statements. When writing dynamic SQL, this can be incredibly subtle, as the different <code>UNION</code> subselects may not be created all at the same place. You may have a complex DAO that generates the SQL across several methods. With this kind of generic type safety, you can continue to do so, safely.<br /><br />As mentioned before, this extends through the whole API. Check out...<br /><br /><strong>IN predicates</strong><br /><br />This compiles:<br /><br /><code></code><br /><pre><code>// Get all customers whose first name corresponds to a staff first name<br />DSL.using(configuration)<br />   .select().from(CUSTOMERS)<br />   .where(CUSTOMERS.FIRST_NAME.in(<br />        select(STAFF.FIRST_NAME).from(STAFF)<br />   ))<br />   .fetch();<br /></code></pre><br /><br />This doesn't compile:<br /><br /><code></code><br /><pre><code>DSL.using(configuration)<br />   .select().from(CUSTOMERS)<br />   .where(CUSTOMERS.FIRST_NAME.in(<br />//                             ^^ wrong argument type!<br />        select(STAFF.FIRST_NAME, STAFF.LAST_NAME).from(STAFF)<br />   ))<br />   .fetch();<br /></code></pre><br /><br />But this compiles:<br /><br /><code></code><br /><pre><code>// Get all customers whose first and last names both correspond<br />// to a staff first and last names<br />DSL.using(configuration)<br />   .select().from(CUSTOMERS)<br />   .where(row(CUSTOMERS.FIRST_NAME, CUSTOMERS.LAST_NAME).in(<br />        select(STAFF.FIRST_NAME, STAFF.LAST_NAME).from(STAFF)<br />   ))<br />   .fetch();<br /></code></pre><br />Notice the use of <code>row()</code> to construct a <a href="http://blog.jooq.org/2013/05/03/sql-query-transformation-fun-predicates-with-row-value-expressions/">row value expression, an extremely useful but little known SQL feature</a>.<br /><br /><br /><strong>INSERT statements</strong><br /><br />This compiles:<br /><br /><code></code><br /><pre><code>DSL.using(configuration)<br />   .insertInto(CUSTOMERS, CUSTOMERS.FIRST_NAME, CUSTOMERS.LAST_NAME)<br />   .values("John", "Doe")<br />   .execute();<br /></code></pre><br /><br />This doesn't compile:<br /><br /><code></code><br /><pre><code>DSL.using(configuration)<br />   .insertInto(CUSTOMERS, CUSTOMERS.FIRST_NAME, CUSTOMERS.LAST_NAME)<br />   .values("John")<br />//  ^^^^^^ Invalid number of arguments<br />   .execute();<br /></code></pre><br /><br /><h2 style="font-size: 2em;">Conclusion</h2><br />Internal domain-specific languages can express a lot of type safety in Java, almost as much as the external language really implements. In the case of SQL - which is a very type safe language - this is particularly true and interesting.<br /><br /><a href="http://www.jooq.org/">jOOQ</a> has been designed to create as little cognitive friction as possible for any Java developer who wants to write embedded SQL in Java, i.e. the Java code will look and feel exactly like the SQL code that it represents. At the same time, jOOQ has been designed to offer as much compile-time type safety as possible in the Java language (or also in Scala, Groovy, etc.).<br /><br />jOOQ is free and Open Source for use with Open Source databases, and it offers commercial licensing for use with commercial databases.<br /><br /><div style="clear: both; text-align: center;"><a href="http://www.jooq.org/"><img src="http://www.jooq.org/img/jooq-the-best-way-to-write-sql-in-java-small.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;" /></a></div><br />For more information about jOOQ or jOOQ's DSL API, consider these resources:<br /><br /><ul><li><a href="http://www.jooq.org/learn/">The jOOQ documentation page</a></li><li><a href="http://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/">The Java Fluent API Designer Crash Course</a></li><li><a href="https://www.youtube.com/watch?v=ZQ2Y5Z0ju3c">A webinar with Arun Gupta from Red Hat about jOOQ and JavaEE</a></li><li><a href="http://vimeo.com/99526433">A presentation about jOOQ at GeeCON Krakow</a></li></ul><br /><strong>Stay tuned for tomorrow's article "How jOOQ allows for fluent functional-relational interactions in Java 8"</strong> <br /><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></div>