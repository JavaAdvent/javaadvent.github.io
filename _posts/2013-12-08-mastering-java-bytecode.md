---
id: 52
title: Mastering Java Bytecode
date: 2013-12-08T08:01:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/mastering-java-bytecode/
permalink: /2013/12/mastering-java-bytecode.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Simon Maple
blogger_permalink:
  - /2013/12/mastering-java-bytecode.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/7703923994451346005
dsq_thread_id:
  - 4962579242
categories:
  - 2013
  - bytecode
  - class file
  - JVM
---
<div dir="ltr" style="text-align: left;">Hey! Happy Advent :D I'm Simon Maple (<a href="http://twitter.com/sjmaple">@sjmaple)</a>, the Technical Evangelist for ZeroTurnaround. You know, the <a href="http://jrebel.com/">JRebel</a> guys! We'll as a result of writing a product like JRebel which interacts with bytecode, more often than you care to imagine, there are many things we've learned about it which we'd love to share.<br /><br />Let's start at the start… Java was a language designed to run on a virtual machine so that it only needed to be compiled once to run everywhere (yes, yes, write once, test everywhere). As a result, the JVM which you install onto your system would be native, allowing the code that runs on it to be platform agnostic. Java bytecode is the intermediate representation of the Java code you write as source and is the result of you compiling your code. So your class files are the bytecode. <br /><br />To be more succinct, Java bytecode is the code set used by the Java Virtual Machine that is JIT-compiled into native code at runtime.<br /><br />Have you ever played about with assembler or machine code? Bytecode is  kind of similar, in a way, but many people in the industry don't really  play with it that much, more out of the lack necessity. However it is  important to understand what's going on, and useful if you want to  out-geek someone in the pub.<br /><br />Firstly, let's take a look at some  bytecode basics. We'll take the expression '1+2' first and see how this  gets executed as Java bytecode. 1+2 can be written in reverse Polish  notation as 1 2 +. Why? Well when we put it on a stack it all becomes  clear…<br /><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-HNsd-WCLB-Q/UqBt53BR3EI/AAAAAAAAAIw/3JKeW_boQp4/s1600/Screen+Shot+2013-12-05+at+10.43.14.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-HNsd-WCLB-Q/UqBt53BR3EI/AAAAAAAAAIw/3JKeW_boQp4/s320/Screen+Shot+2013-12-05+at+10.43.14.png" width="260" /></a></div><br />OK, in bytecode we'd actually see opcodes (iconst_1 and iconst_2) and an instruction (iadd) rather than push and add, but the flow is the same. The actual instructions are one byte in length, hence bytecode. There are 256 possible opcodes as a result, but only 200 or so are used. Opcodes are prefixed with a type followed by the operation name. So what we saw previously with iconst and iadd, are constants of integer type and an add instruction for integer types.<br /><br />This is all very well and good, but how about reading class files. Typically, all you normally see in a class file when opened, in your editor of choice, is a bunch of smiley faces and some squares, dots and other weird characters, right? The answer is in javap, a code utility you actually get with your JDK. Let's look at a code example to see javap in action.<br /><br /><pre><code>public class Main {<br /><br />&nbsp;&nbsp;&nbsp; public static void main(String[] args){<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MovingAverage app = new MovingAverage();<br /><br />&nbsp;&nbsp;&nbsp; }<br /><br />}</code></pre><br />Once this class is compiled into a Main.class file, we can use the following command to extract the bytecode: javap -c Main<br /><br /><pre><code>Compiled from "Main.java"<br /><br />public class algo.Main {<br />&nbsp; public algo.Main();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Code:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: aload_0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: invokespecial #1<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4: return<br />// Method java/lang/Object."&lt;init&gt;":()V<br />public static void main(java.lang.String[]);<br />&nbsp;&nbsp;&nbsp;&nbsp; Code:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: dup<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4: invokespecial #3<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7: astore_1<br />&nbsp;&nbsp;&nbsp; &nbsp; 8: return <br />}</code></pre><br /><br />We can see we have our default constructor and main method in the byte code straight away. By the way, this is how Java gives you a default constructor for constructor-less classes! The bytecode in the constructor is simply a call to super(), while our main method creates a new instance of the MovingAverage&nbsp; and returns. The #n characters actually refer to constants which we can view using the -verbose argument as follows: javap -c -verbose Main. The interesting part of what is returned is shown below:<br /><br /><pre><code>public class algo.Main<br /><br />&nbsp; SourceFile: "Main.java"<br /><br />&nbsp; minor version: 0<br /><br />&nbsp; major version: 51<br /><br />&nbsp; flags: ACC_PUBLIC, ACC_SUPER<br /><br />Constant pool:<br /><br />&nbsp;&nbsp; #1 = Methodref&nbsp;&nbsp;&nbsp; #5.#21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; java/lang/Object."&lt;init&gt;":()V<br /><br />&nbsp;&nbsp; #2 = Class&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; algo/MovingAverage<br /><br />&nbsp;&nbsp; #3 = Methodref&nbsp;&nbsp;&nbsp; #2.#21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; algo/MovingAverage."&lt;init&gt;":()V<br /><br />&nbsp;&nbsp; #4 = Class&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #23 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; algo/Main<br /><br />&nbsp;&nbsp; #5 = Class&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #24 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp; java/lang/Object</code></pre><br />Now we can match our instructions to our constants and we can piece together what's actually happening much easier. Is anything still bugging you about the example above? No? What about the numbers in front of each instruction…<br /><br /><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #2<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: dup<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4: invokespecial #3<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7: astore_1<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 8: return </code></pre>Now it's really bugging you, right? :) Here's what we've got if we visualise this method body as an array:<br /><br /><br /><div style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-U5r41ec5LIM/UqBwTVMsncI/AAAAAAAAAJM/XxrfCgLrhvE/s1600/Screen+Shot+2013-12-05+at+10.43.26.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="90" src="http://1.bp.blogspot.com/-U5r41ec5LIM/UqBwTVMsncI/AAAAAAAAAJM/XxrfCgLrhvE/s640/Screen+Shot+2013-12-05+at+10.43.26.png" width="640" /></a></div><br />Note that every instruction has a HEX representation, so using that we actually see this: <br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/--Y1ImlncOf8/UqBvuGAe0zI/AAAAAAAAAI8/jWxia7Rzads/s1600/Screen+Shot+2013-12-05+at+10.43.31.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="96" src="http://2.bp.blogspot.com/--Y1ImlncOf8/UqBvuGAe0zI/AAAAAAAAAI8/jWxia7Rzads/s640/Screen+Shot+2013-12-05+at+10.43.31.png" width="640" /></a></div>&nbsp;We can actually see this in the class file if we open it in a HEX editor:<br /><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-4OP4rv0iGmE/UqBv8tRDEwI/AAAAAAAAAJE/A6ncUg77bO4/s1600/Screen+Shot+2013-12-05+at+10.43.44.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="201" src="http://2.bp.blogspot.com/-4OP4rv0iGmE/UqBv8tRDEwI/AAAAAAAAAJE/A6ncUg77bO4/s640/Screen+Shot+2013-12-05+at+10.43.44.png" width="640" /></a></div><br />We could actually change the bytecode here in our HEX editor, but let's be honest, it's not something you'd really want to do, particularly on a Friday afternoon after the obligatory pub trip. Better ways to do this would be using ASM or javassist.<br /><br />Let's move on from our basic example and add some local variables that store state and interact directly with our stack. Check out the following code:<br /><br /><pre><code>public static void main(String[] args) {<br /><br />&nbsp; MovingAverage ma = new MovingAverage();<br /><br /><br /><br />&nbsp; int num1 = 1;<br /><br />&nbsp; int num2 = 2;<br /><br /><br /><br />&nbsp; ma.submit(num1);<br /><br />&nbsp; ma.submit(num2);<br /><br /><br /><br />&nbsp; double avg = ma.getAvg();<br /><br />}</code></pre><br />Lets see what we get this time in our bytecode:<br /><br /><pre><code>Code: 0: new&nbsp; #2&nbsp;&nbsp;&nbsp; // class algo/MovingAverage<br /><br />3: dup<br /><br />4: invokespecial #3&nbsp; // Method algo/MovingAverage."&lt;init&gt;":()V<br /><br />7: astore_1<br /><br />8: iconst_1<br /><br />9: istore_2<br /><br />10: iconst_2<br /><br />11: istore_3<br /><br />12: aload_1<br /><br />13: iload_2<br /><br />14: i2d<br /><br />15: invokevirtual #4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Method algo/MovingAverage.submit:(D)V<br /><br />18: aload_1<br /><br />19: iload_3<br /><br />20: i2d<br /><br />21: invokevirtual #4&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Method algo/MovingAverage.submit:(D)V<br /><br />24: aload_1<br /><br />25: invokevirtual #5&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Method algo/MovingAverage.getAvg:()D<br /><br />28: dstore&nbsp;&nbsp;&nbsp;&nbsp; 4<br /><br /><br /><br />LocalVariableTable:<br /><br />Start&nbsp; Length&nbsp; Slot&nbsp; Name&nbsp;&nbsp; Signature<br /><br /><br /><br />0 &nbsp;&nbsp;&nbsp; &nbsp; 31 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; args&nbsp;&nbsp; [Ljava/lang/String;<br /><br />8 &nbsp;&nbsp;&nbsp; &nbsp; 23&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 1&nbsp; &nbsp;&nbsp;&nbsp; ma&nbsp;&nbsp;&nbsp;&nbsp; Lalgo/MovingAverage;<br /><br />10 &nbsp;&nbsp;&nbsp;&nbsp; 21 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2 &nbsp;&nbsp;&nbsp; num1&nbsp;&nbsp; I<br /><br />12 &nbsp;&nbsp;&nbsp; &nbsp; 19 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 3&nbsp; &nbsp;&nbsp;&nbsp; num2&nbsp;&nbsp; I<br /><br />30 &nbsp;&nbsp;&nbsp; &nbsp; 1&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; avg&nbsp;&nbsp;&nbsp; &nbsp;D</code></pre>This looks a lot more interesting… We can see that we create an object of type MovingAverage which is stored in local variable, ma, via the astore_1 instruction (1 is the slot number in the LocalVariableTable). Instructions iconst_1 and iconst_2 are there to load constants 1 and 2 to the stack and store them in LocalVariableTable slots 2 and 3 respectively by instructions istore_2 and istore_3. A load instruction pushed a local variable onto the stack, which a store instruction pops the next item from the stack and stores it in the LocalVariableTable. It's important to realise that when a store instruction is used, the item is taken off of the stack and if you want to use it again, you'll need to load it.<br /><br />How about the flow of execution? All we've seen is a simple progression from one line to the next. I want to see some BASIC style GOTO 10 in the mix! Let's take another example:<br /><br /><pre><code>MovingAverage ma = new MovingAverage();<br /><br />for (int number : numbers) {<br /><br />&nbsp;&nbsp;&nbsp; ma.submit(number);<br /><br />}</code></pre><br />In this case the flow of execution will jump around many times as we traverse the for loop. This bytecode, assuming that the numbers variable is a static field in the same class is shown as the following:<br /><br /><pre><code>0: new #2 // class algo/MovingAverage<br /><br />3: dup<br /><br />4: invokespecial #3 // Method algo/MovingAverage."&lt;init&gt;":()V<br /><br />7: astore_1<br /><br />8: getstatic #4 // Field numbers:[I<br /><br />11: astore_2<br /><br />12: aload_2<br /><br />13: arraylength<br /><br />14: istore_3<br /><br />15: iconst_0<br /><br />16: istore 4<br /><br />18: iload 4<br /><br />20: iload_3<br /><br />21: if_icmpge 43<br /><br />24: aload_2<br /><br />25: iload 4<br /><br />27: iaload<br /><br />28: istore 5<br /><br />30: aload_1<br /><br />31: iload 5<br /><br />33: i2d<br /><br />34: invokevirtual #5 // Method algo/MovingAverage.submit:(D)V<br /><br />37: iinc 4, 1<br /><br />40: goto 18<br /><br />43: return<br /><br /><br /><br />LocalVariableTable:<br /><br />Start&nbsp; Length&nbsp; Slot&nbsp; Name&nbsp;&nbsp; Signature<br /><br />30 &nbsp;&nbsp;&nbsp; &nbsp; 7 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; number I <br /><br />12 &nbsp;&nbsp;&nbsp; &nbsp; 31&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; arr$&nbsp;&nbsp;&nbsp; &nbsp;[I<br /><br />15 &nbsp;&nbsp;&nbsp; &nbsp; 28&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp; len&nbsp;&nbsp;&nbsp; &nbsp;$I <br /><br />18 &nbsp;&nbsp;&nbsp; &nbsp; 25 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 4 &nbsp;&nbsp;&nbsp; i$ &nbsp;&nbsp;&nbsp; &nbsp;I<br /><br />0 &nbsp;&nbsp;&nbsp; &nbsp; 49 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp; args&nbsp; [Ljava/lang/String;<br /><br />8 &nbsp;&nbsp;&nbsp; &nbsp; 41 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; ma &nbsp;&nbsp;&nbsp; Lalgo/MovingAverage; <br /><br />48&nbsp;&nbsp;&nbsp; &nbsp; 1 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; avg&nbsp;&nbsp;&nbsp; D</code></pre>The instructions from position 8 through 17 are used to setup the loop. There are three variables in the LocalVariable table that aren't really mentioned in the source, arr$, len$ and i$. These are the loop variables. arr$ stores the reference value of the numbers field from which the length of the loop, len$ is derived. i$ is the loop counter which is incremented by the iinc instruction.<br /><br />First we need to test our loop expression, which is performed by a comparison instruction:<br /><br /><pre><code>18: iload 4<br /><br />20: iload_3<br /><br />21: if_icmpge 43</code></pre>We're loading 4 and 4 onto the stack, which are the loop counter and the loop length. We're checking id i$ is greater than or equal to len$. If it is, we jump to statement 43, otherwise we proceed. We can then perform our logic in the loop and at the end, we increment our counter and jump back to our code that checks the loop condition on statement 18.<br /><br /><pre><code>37: iinc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // increment i$<br /><br />40: goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // jump back to the beginning of the loop</code></pre><br />There are a bunch of arithmetical opcodes and type command combinations that can be used in bytecode, including the following:<br /><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Zike6JyFX18/UqB7Hb8anzI/AAAAAAAAAJc/uN0dhrdLWAQ/s1600/Screen+Shot+2013-12-05+at+11.29.13.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="220" src="http://2.bp.blogspot.com/-Zike6JyFX18/UqB7Hb8anzI/AAAAAAAAAJc/uN0dhrdLWAQ/s400/Screen+Shot+2013-12-05+at+11.29.13.png" width="400" /></a></div><br />As well as a number of type conversion opcodes which are important when assigning say an integer to a variable of type long.<br /><div style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-D7Zvc17U5-8/UqB7OQpO-aI/AAAAAAAAAJk/Sl2cY1ZUOiQ/s1600/Screen+Shot+2013-12-05+at+11.31.19.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="201" src="http://1.bp.blogspot.com/-D7Zvc17U5-8/UqB7OQpO-aI/AAAAAAAAAJk/Sl2cY1ZUOiQ/s400/Screen+Shot+2013-12-05+at+11.31.19.png" width="400" /></a></div><br />In our precious example we pass an integer to a submit method which takes a double. Java syntax does this for us, but in bytecode, you'll see the i2d opcode is used:<br /><br /><pre><code>31: iload 5<br /><br /> 33: i2d <br /><br />34: invokevirtual #5 // Method algo/MovingAverage.submit:(D)V</code></pre>So, you've made it this far. Well done, you've earned a coffee! Is any of this actually useful to know or is it just geek fodder? Well, it's both! Firstly now, you can tell your friends that you're a JVM that can process bytecode, and secondly you can better understand what you're doing when writing bytecode. For example, when using ObjectWeb ASM, which is one of the most widely used bytecode manipulation tools, you'll find yourself constructing instructions and this knowledge will prove invaluable!<br /><br />If you found this interesting and want to know more, then checkout our <a href="http://zeroturnaround.com/labs/rebel-labs-report-mastering-java-bytecode-at-the-core-of-the-jvm/">free Mastering Java Bytecode report</a> from Anton Arhipov, the JRebel Product Lead at ZeroTurnaround. (JRebel uses javassist and we have had lots of fun learning and interactive with Java bytecode!) This report goes into more depth and touches on how to use ASM.<br /><br />Thanks for reading! Let me know what you thought! (<a href="http://twitter.com/sjmaple">@sjmaple</a>)<br /><br /><i>Meta: this post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</i></div>