---
id: 45
title: WebSocket and Java
date: 2013-12-15T09:35:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/websocket-and-java/
permalink: /2013/12/websocket-and-java.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Glamdring
blogger_permalink:
  - /2013/12/websocket-and-java.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/429723347426876634
categories:
  - 2013
  - java
---
<div dir="ltr" style="text-align: left;"><div>WebSocket is a cool new(ish) technology that allows real-time, two-way communication between the browser and the server, with almost no overhead. What I want to do here, is to provide a very succint, but sufficient overview of how to start using the technology. So, a few things to start with:<br /><br /><ul style="text-align: left;"><li>a tcp socket connection is opened between the browser and the server, and each party can send messages to the other (i.e. the server can push data whenever it has it available - no need for polling, long polling, iframes, etc.)</li></ul></div><ul style="text-align: left;"><li>not all browsers support it - IE 10 is the first IE version to support it, Android still has issues. Fortunately, there's <a href="https://github.com/sockjs/sockjs-client" target="_blank">SockJS</a>, which falls back to other push-emulations, if WebSocket is not supported.</li><li>not all proxy servers support it / allow it, so again fallback might be needed</li><li>suitable for games, trading applications, and in fact anything that requires the server to push data to the browser</li><li>Java has a <a href="http://docs.oracle.com/javaee/7/tutorial/doc/websocket.htm" target="_blank">standard API (JSR-356)</a>, which you can use on the server to handle WebSocket connections.</li><li><a href="http://spring.io/blog/2013/05/23/spring-framework-4-0-m1-websocket-support" target="_blank">Spring provides an API ontop</a> of the Java API. The good thing about the spring support is that it has server-side support for SockJS and you can use dependency injection effortlessly. <a href="http://assets.spring.io/wp/WebSocketBlogPost.html" target="_blank">Spring also provides STOMP support</a> for a message-driven architecture. Both spring articles include links to GitHub sample projects, which I recommend. </li></ul><br />Before proceeding to some sample code, here is the socket lifecycle, including client and server (assuming one of the above APIs):<br /><ol style="text-align: left;"><li>The browser sends an HTTP request with a special Upgrade header, with value "websocket".&nbsp;</li><li>If the server "speaks" weboscket, it replies with status 101 - switching protocols. From now on we are no longer using HTTP</li><li>When the server accepts the tcp socket connection, an initialization method is invoked, where the current websocket session is passed. Each socket has a unique session id.</li><li>Whenever a browser sends a message over to the server, another method is invoked where you get the session and the message payload.</li><li>Based on some payload parameter, the application code performs one of several actions. The payload format is entirely up to the developer. Normally, though, it is a JSON-serialized object.</li><li>Whenever the server needs to send a message, it needs to obtain the session object, and use it to send a message.</li><li>When the browser closes the connection, the server is notified, so that it can cleanup any resources, associated with the particular session.</li></ol><br />Currently no API or framework supports annotation-based routing. The Java API supports annotation-based endpoint handlers, but it gives you one class per connection URL, and normally you want to perform multiple operations on a single connection. I.e., you connect to ws://yourserver.com/game/ and then you want to pass "joinGame", "leaveGame" message. Likewise, the server needs to send more than one type of messages back. The way I implemented this, is via an enum, containing all possible types of actions/events, and using a switch construct to determine what to invoke.<br /><br />So I decided to make a <a href="http://computoser.com/game" target="_blank">simple game</a> for my <a href="http://computoser.com/" target="_blank">algorithmic music composer</a>. It is using the Spring API. <a href="http://www.slideshare.net/Bozho/websockets-and-java" target="_blank">Here are the slides</a> for a relevant presentation I did in the company I'm working for. And below is some sample code:<br /><br /><pre style="border: solid thin gray;"><code><br />@Component<br />public class GameHandler extends WebSocketHandlerAdapter {<br />   private Map<string, Player> players = new ConcurrentHashMap<>();<br />   private Map<string, Game> playerGames = new ConcurrentHashMap<>();<br />   <br />   @Override<br />   public void afterConnectionEstablished(WebSocketSession session) throws Exception {<br />       Player player = new Player(session);<br />       players.put(session.getId(), player);<br />   }<br /><br />@Override<br />public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {<br />    leaveGame(session.getId());<br />}<br /><br />@Override<br />protected void handleTextMessage(WebSocketSession session, TextMessage textMessage) throws Exception {<br />   try {<br />      GameMessage message = getMessage(textMessage); //deserializes the JSON payload<br /><br />      switch(message.getAction()) { <br />        case INITIALIZE: initialize(message, session); break;<br />        case JOIN: join(message.getGameId(), message.getPlayerName(), session); break;<br />        case LEAVE: leave(session.getId()); break;<br />        case START: startGame(message); break;<br />        case ANSWER: answer(message, session.getId()); break;<br />      }<br />    } catch (Exception ex) {<br />    logger.error("Exception occurred while handling message", ex);<br />  }<br />}<br /></code></pre><br /><br /><br /><br /><br />Let's see a sample secnario, where the server needs to send messages to clients. Lets take the case when a player joins the game, and all other players need to be notified of the new arrival. The central class in the system is Game, which has a list of players, and as you can see, a Player contains a reference to a WebSocket session. So, when a player joins, the following method of Game is invoked:<br /><br /><pre style="border: solid thin gray;"><code><br />public boolean playerJoined(Player player) {<br />   for (Player otherPlayer : players.values()) {<br />      otherPlayer.playerJoined(player);<br />   }<br />   players.put(player.getSession().getId(), player);<br />   return true;<br />}<br /></code></pre><br />And player.playerJoined(..) sends a message over the underlying connection, notifying the browser that a new player has joined:<br /><br /><pre style="border: solid thin gray;"><code><br />public void playerJoined(Player player) {<br />   GameEvent event = new GameEvent(GameEventType.PLAYER_JOINED);<br />   event.setPlayerId(player.getSession().getId()); <br />   event.setPlayerName(player.getName());<br />   try {<br />      session.sendMessage(new TextMessage(event.toJson()));<br />   } catch (IOException e) {<br />      new IllegalStateException(e);<br />   }<br />  }<br /></code></pre><br />Sending messages from the server to the browser may also be triggered by a scheduled job.<br /><br />The point is that you keep a list of all connected browsers, so that you can send information back. The list can be a static field, but in the case of a singleton spring bean it doesn't need to be.<br /><br /><br /><br /><br /><br />Now, two important aspects - security and authentication. Here's a <a href="https://devcenter.heroku.com/articles/websocket-security" target="_blank">nice article by Heroku</a>, discussing both. You should prefer wss (which is websocket over TLS) if there is anything sensitive. You should also validate your input on both ends, and you should not rely on the Origin header, because an attacker may spoof the browser very easily.<br />Authentication can rely on the HTTP session cookie, but apparently some people prefer to implement their own cookie-like workflow in order to obtain a short-lived token, which can be used to perform authenticated operations.<br /><br />WebSocket makes DDD come naturally. You no longer work with anemic objects - your objects have their respective state and operations are performed on that state. Related to that, a websocket application is more easily testable.<br /><br />That's the general set of things to have in mind when developing a WebSocket application. Note that you don't have to use WebSocket everywhere - I'd limit it only to features where "push" is needed.<br /><br />Overall, WebSocket is a nice and interesting technology that hopefully obsoletes all hacky push emulations.<br /><br /></div>