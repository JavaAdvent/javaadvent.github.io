---
id: 38
title: 'Reactive Cassandra &#8230;'
date: 2013-12-22T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/reactive-cassandra/
permalink: /2013/12/reactive-cassandra.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - gciuloaica
blogger_permalink:
  - /2013/12/reactive-cassandra_22.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/409957536931717375
geo_latitude:
  - 46.56628
geo_longitude:
  - 23.79064
geo_public:
  - 1
geo_address:
  - Turda, Romania
categories:
  - 2013
---
Or an adventure on reading data reactively from Cassandra.<br /><br /><b>Overview</b><br />Let's first try to define what reactive means from programming point of view.<br /><br /><span style="font-family: Arial;"><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">Functional reactive programming </a>is programming paradigm for reactive programming using the building blocks of functional programming.&nbsp;</span><br /><br /><span style="font-family: Arial;"><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">Functional programming</a> is a programming paradigm, a style of building the structure and the elements of computer programs, that treats computation, as the evaluation of mathematical functions thats avoids state and mutable data. Functional programming emphasises functions that produce results that depend only on &nbsp;their inputs and not on program state.</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">How can we do functional programming in Java? Java is Object Oriented Programming language where mutable state is present everywhere.</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">Any java developer around the world have used any of the interfaces: java.lang.Runnable, java.util.Comparator, java.util.concurrent.Callable or java.awt.event.ActionListener. All of this interfaces are having only single method declared. These interfaces are known as Single Abstract Methods or SAM. A popular way as these are used is by creating Anonymous inner classes.&nbsp;</span><br /><span style="font-family: Arial;"></span><br /><span style="color: #042eee; font-family: Arial;"><u><code></code></u></span><br /><pre>public class RunnableTest {<br />  public static void main(Sting[] args){<br />    new Thread(new Runnable(){<br />      @Override<br />      public void run(){<br />        System.out.println("A new thread is running ...");<br />      }<br />    }).start();<br />  }<br />}</pre></code><span style="font-family: Arial;">&nbsp;</span><br /><span style="font-family: Arial;"></span><br /><span style="font-family: Arial;">Functional Programming in Java is hard since function is not included in the language specification. It will become simpler in Java 8 with introduction of “lambda’s”. But how can we do functional programming in Java?</span><br /><span style="font-family: Arial;">Let’s see a simple example.</span><br /><span style="font-family: Arial;"></span><br /><span style="color: #042eee; font-family: Arial;"><u><code></code></u></span><br /><pre><span style="color: #042eee; font-family: Arial;"><code><br />@FunctionalInterface<br />public interface Worker {<br />   public void doWork();<br />}<br />public class FunctionalWorker {<br />  public static void main(String[] args){<br />    // anonymous inner class way<br />    execute( new Worker(){<br />      @Override<br />      public void doWork() {<br />        System.out.println ("working ...");<br />      }<br />    });<br />    // lambda's way<br />    execute(() -> System.out.println("working in lambda's way ..."));<br />  }<br />  <br />  public static void execute(Worker worker){<br />    worker.doWork();<br />  }<br />}<br /></code></span></pre><br /><span style="font-family: Arial;"></span><br /><span style="font-family: Arial;"></span><br /><span style="font-family: Arial;"><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">Reactive programming</a> is a programming paradigm oriented around data flows and the propagation of changes. For example, in imperative programming setting, <span style="color: orange;">a := b+c</span>, would mean that <span style="color: orange;">a</span> is being assigned the result of &nbsp;<span style="color: orange;">b +c</span> in the instant the expression is evaluated. Later values of <span style="color: orange;">b</span> or <span style="color: orange;">c</span> can be changed without effect on <span style="color: orange;">a</span>. In reactive programming, the value of <span style="color: orange;">a </span>will be automatically updated based on the new values.</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">So, we should have a good understanding of what Functional Reactive Programming is, so let's go and build a prototype...</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;"><b>Reading data&nbsp;reactively&nbsp;from Cassandra</b></span><br /><span style="font-family: Arial;"><b><br /></b></span><span style="font-family: Arial;">Cassandra is one of the NoSql storage out there is quite popular.&nbsp;</span><br /><span style="font-family: Arial;">Let's imagine that we have to build an Avatar service. This service will store avatars meta information and the content directly in cassandra.&nbsp;</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">The java driver that we are using is providing us support to query cassandra asynchronous, through the <a href="http://www.datastax.com/drivers/java/1.0/com/datastax/driver/core/Session.html#executeAsync(java.lang.String)" target="_blank">executeAsync()</a> method. The invocation of this method will return a Future. As we all know java Futures are block-able and could not be composed.</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">Ok, so we have async support but we still need a way to be able to read it reactively...</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">Netflix built and later open sourced the <a href="https://github.com/Netflix/RxJava" target="_blank">RxJava</a> library that is providing Functional Reactive Programming for Java (plus other JVM languages).</span><br /><span style="font-family: Arial;"><br /></span><br /><div><span style="font-family: Arial, Helvetica, sans-serif;">Functional reactive offers efficient execution and composition by providing a collection of operators capable of filtering, selecting, transforming, combining and composing Observable's.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">The Observable data type can be thought of as a "push" equivalent to <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html"><span>Iterable</span></a> which is "pull". With an Iterable, the consumer pulls values from the producer and the thread blocks until those values arrive. By contrast with the Observable type, the producer pushes values to the consumer whenever values are available. This approach is more flexible, because values can arrive synchronously or asynchronously.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">The <a href="https://github.com/Netflix/RxJava/wiki/Observable" target="_blank">Observable</a> type adds two missing semantics to the Gang of Four's <a href="http://en.wikipedia.org/wiki/Observer_pattern"><span>Observer</span></a> pattern, which are available in the Iterable type:</span></div><ol><li><span style="font-family: Arial, Helvetica, sans-serif;">The ability for the producer to signal to the consumer that there is no more data available.</span></li><li><span style="font-family: Arial, Helvetica, sans-serif;">The ability for the producer to signal to the consumer that an error has occurred.</span></li></ol><br /><div><span style="font-family: Arial, Helvetica, sans-serif;">With these two simple additions, we have unified the Iterable and Observable types. The only difference between them is the direction in which the data flows. This is very important because now any operation we perform on an Iterable, can also be performed on an Observable.&nbsp;</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br /></span></div><div><span style="font-family: Arial, Helvetica, sans-serif;">Let's see how we can combine the RxJava and Cassandra async query execution to build an Observable.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br /></span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><code><pre><br />package net.devsprint.reactive.cassandra;<br /> <br />import java.util.concurrent.ExecutorService;<br /> <br />import rx.Observable;<br />import rx.Observer;<br />import rx.Subscription;<br />import rx.subscriptions.Subscriptions;<br /> <br />import com.datastax.driver.core.ResultSet;<br />import com.datastax.driver.core.Session;<br />import com.google.common.util.concurrent.FutureCallback;<br />import com.google.common.util.concurrent.Futures;<br /> <br />/**<br /> * Wraps an async execution of Datastax Java driver into an observable.<br /> * <br /> */<br />public class ObservableCassandra {<br /> <br /> public static Observable<resultSet> executeAsync(final Session execution,<br />   final String query, final ExecutorService executorService) {<br />  return Observable.create(new Observable.OnSubscribeFunc<resultSet>() {<br /> <br />   @Override<br />   public Subscription onSubscribe(final Observer<? super ResultSet> observer) {<br />    try {<br />     Futures.addCallback(execution.executeAsync(query),<br />      new FutureCallback<resultSet>() {<br /> <br />      @Override<br />      public void onSuccess(ResultSet result) {<br />       observer.onNext(result);<br />       observer.onCompleted();<br />      }<br /> <br />      @Override<br />      public void onFailure(Throwable t) {<br />       observer.onError(t);<br />      }<br />      }, executorService);<br />    } catch (Throwable e) {<br />     // If any Throwable can be thrown from<br />     // executeAsync<br />     observer.onError(e);<br />    }<br />    return Subscriptions.empty();<br />   }<br />  });<br /> }<br /> <br />}<br /></pre></code></span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br /></span></div><div><a href="http://www.datastax.com/drivers/java/1.0/com/datastax/driver/core/Session.html#executeAsync(java.lang.String)" style="font-family: Arial;" target="_blank">executeAsync()</a><span style="font-family: Arial;">&nbsp;method is returning a <a href="https://code.google.com/p/guava-libraries/wiki/ListenableFutureExplained" target="_blank">Guava Listenable Future</a>. Adding a callback on this future allows us to properly implement the <a href="http://netflix.github.io/RxJava/javadoc/rx/Observer.html" target="_blank">Observer</a> interface.</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">A simple service could be implemented as following:</span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;"><code><pre><br />package net.devsprint.reactive.cassandra;<br /> <br />import java.util.concurrent.ExecutorService;<br />import java.util.concurrent.Executors;<br /> <br />import rx.Observable;<br /> <br />import com.datastax.driver.core.ResultSet;<br />import com.datastax.driver.core.Session;<br /> <br />public class AvatarService {<br /> private static final String QUERY = "select * avatars";<br /> private static final ExecutorService executorService = Executors<br />   .newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br /> <br /> private final Session session;<br /> <br /> public AvatarService(Session session) {<br />  this.session = session;<br /> }<br /> <br /> Observable<resultSet> getAvatars() {<br />  return ObservableCassandra<br />    .executeAsync(session, QUERY, executorService);<br /> }<br /> <br />}<br /></pre></code></span><br /><span style="font-family: Arial;"><br /></span><span style="font-family: Arial;">Assuming that the query is heavy, we are providing a separate execution context where the callback will be executed.</span><br /><br /><span style="font-family: Arial;">With these two classes we have an Avatar service that could be started but it will not do any thing. It will start fetching the data from Cassandra only when there will be at least one subscriber.</span></div><div><span style="font-family: Arial, Helvetica, sans-serif;"><br /></span></div><span style="font-family: Arial;">A complete example could be found at <a href="https://github.com/devsprint/reactive-cassandra" target="_blank">Reactive Cassandra</a>.</span><br /><br />  <br /><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em>