---
id: 58
title: Using Matchers in Tests
date: 2013-12-02T08:06:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/using-matchers-in-tests/
permalink: /2013/12/using-matchers-in-tests.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Stefan Bulzan
blogger_permalink:
  - /2013/12/using-matchers-in-tests.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/5471488089688337704
dsq_thread_id:
  - 4962579257
categories:
  - 2013
  - junit
  - testing
---
<div>Gone are the days when we were forced to write way too many assertion lines in our testing code. There is a new sheriff in town: assertThat and his deputy: the matchers. Well, not that new, but anyway I’d like to present to you shortly how matchers are used and after that an extension to matchers concept that I found to be very useful when developing unit tests for my code.<o:p></o:p><br /><br /></div><div>First of all I’ll present the basic use of the matchers. Of course you can have a complete presentation of hamcrest matchers capabilities directly from its authors: <a href="https://code.google.com/p/hamcrest/wiki/Tutorial">https://code.google.com/p/hamcrest/wiki/Tutorial</a>.<o:p></o:p></div><br /><div>Basically a matcher is an object that defines when two objects match. The first question usually is why wouldn’t you use equals? Well, sometimes you don’t want to match two objects on all their fields, just on some of them and if you work with legacy code you’ll find that the equals implementation is not present or is not as you would’ve expected. Another reason is the fact that using assertThat gives you a more consistent way of “asserting the assertions” and arguably a more readable code. So, for example, instead of writing:<o:p></o:p></div><div><br /><pre style="border: solid thin gray;"><code><br />int expected, actual;<br />assertEquals(expected, actual);</code></pre><br /><div>you will write<o:p></o:p></div><div><br /></div><pre style="border: solid thin gray;"><code><br />assertThat(expected, is(actual));<br /></code></pre></div><br /><div>where “<span style="font-family: &quot;Courier New&quot;;">is</span>” is the statically imported <span style="font-family: &quot;Courier New&quot;;">org.hamcrest.core.Is.is<o:p></o:p></span></div><div>Not that much of a difference… yet. But Hamcrest offers you a lot of very useful matchers:</div><div></div><ul><li><span style="text-indent: -0.25in;">For arrays and maps : hasItem, hasKey, hasValue</span></li><li><span style="text-indent: -0.25in;">Numbers: closeTo – a way to specify equality with an error of margin, greaterThan, lessThan…</span></li><li><span style="text-indent: -0.25in;">Objects: nullValue, sameInstance</span></li></ul><div>Now we're making progress… still the power of Hamcrest matchers is that you have the possibility to write your own matchers for your objects. You just have to extend BaseMatcher&lt;T&gt; class. Here is an example of a simple custom matcher:<o:p></o:p></div><div><br /></div><pre style="border: solid thin gray;"><code><br />public class OrderMatcher extends BaseMatcher&lt;Order&gt;<order> {<br />    private final Order expected;<br />    private final StringBuilder errors = new StringBuilder();<br /><br />    private OrderMatcher(Order expected) {<br />        this.expected = expected;<br />    }<br /><br />    @Override<br />    public boolean matches(Object item) {<br />        if (!(item instanceof Order)) {<br />            errors.append("received item is not of Order type");<br />            return false;<br />        }<br />        Order actual = (Order) item;<br />        if (actual.getQuantity() != (expected.getQuantity())) {<br />            errors.append("received item had quantity ").append(actual.getQuantity()).append(". Expected ").append(expected.getQuantity());<br />            return false;<br />        }<br />        return true;<br />    }<br /><br />    @Override<br />    public void describeTo(Description description) {<br />        description.appendText(errors.toString());<br />    }<br /><br />    @Factory<br />    public static OrderMatcher isOrder(Order expected) {<br />        return new OrderMatcher(expected);<br />    }<br />}<br /></order></code></pre><br /><div>This is a completely new league compared to the old assertion methods. <o:p></o:p><br /><br /></div><div style="margin-left: 0in; mso-add-space: auto;">So this is in a nutshell the usage of the Hamcrest’s matchers. <o:p></o:p></div><div style="margin-left: 0in; mso-add-space: auto;"><br />But, when I started using it in real life, especially when working with legacy code, I realized that there is more to the story. Here are some issues that I’ve encountered when using matchers:</div><div style="margin-left: 0in; mso-add-space: auto;"></div><ol><li><span style="text-indent: -0.25in;">Matcher construction can be very repetitive and boring. I needed a way to apply DRY principle to matcher code.</span></li><li><span style="text-indent: -0.25in;">I needed an unified way to access the matchers. The correct matcher should be chosen by the framework by default.</span></li><li><span style="text-indent: -0.25in;">I needed to compare objects that had reference to another objects which should have been compared with matchers (the object referencing can go as deep as you want)</span></li><li><span style="text-indent: -0.25in;">I needed to check a collection of objects</span><span style="text-indent: -0.25in;">&nbsp; </span><span style="text-indent: -0.25in;">using matchers without iterating that collection (doable also with the array matchers… but I wanted more </span><span style="font-family: Wingdings; text-indent: -0.25in;">J</span><span style="text-indent: -0.25in;">)</span></li><li><span style="text-indent: -0.25in;">I needed to have a more flexible matcher. For example, for the same object I needed to check one set of fields, but in another case another one. The out-of-box solution is to have a matcher for each case. Didn’t like that.</span></li></ol><div style="mso-list: l0 level1 lfo1; text-indent: -.25in;"><o:p></o:p></div><div>I’ve overcome these issues using a matcher hierarchy that some conventions and which knew which matcher to apply and which field to compare or ignore. At the root of this hierarchy is the RootMatcher&lt;T&gt; that extends BaseMatcher&lt;T&gt;.<o:p></o:p></div><br />To deal with the #1 issue (repetitive code), the RootMatcher class contains the common code for all the matchers like methods for checking if the actual is null, or it has the same type with the expected object, or even if they are the same instance: <br /><pre style="border: solid thin gray;"><code><br />    public boolean checkIdentityType(Object received) {<br />        if (received == expected) {<br />            return true;<br />        }<br />        if (received == null || expected == null) {<br />            return false;<br />        }<br />        if (!checkType(received)){<br />            return false;<br />        }<br />        return true;<br />    }<br />    private boolean checkType(Object received) {<br />        if (checkType &amp;&amp; !getClass(received).equals(getClass(expected))) {<br />            error.append("Expected ").append(expected.getClass()).append(" Received : ").append(received.getClass());<br />            return false;<br />        }<br />        return true;<br />    }<br /></code></pre><br /><div>This will simplify the way the matchers are written, I don’t have to take into account null or identity corner cases; it’s all been taken care of in the root class. <o:p></o:p></div><br /><div>Also the expected object and the errors reside in the root class:<span style="font-family: &quot;Courier New&quot;;"><o:p></o:p></span></div><div><br /></div><pre style="border: solid thin gray;"><code><br />public abstract class RootMatcher<t> extends BaseMatcher<t> {<br />    protected T expected;<br />    protected StringBuilder error = new StringBuilder("[Matcher : " + this.getClass().getName() + "] ");<br /></t></t></code></pre><br /><div>This allows you to get to the matches method implementation as soon as you extend RootMatcher and for errors you just put the messages in the StringBuilder; RootMatcher will handle sending them to the JUnit framework to be presented to the user.<span style="font-family: &quot;Courier New&quot;;"><o:p></o:p></span></div><br /><div>For issue #2 (automatic matcher finding) the solution was in its factory method:<o:p></o:p></div><div><br /></div><pre style="border: solid thin gray;"><code><br />    @Factory<br />    public static <t> Matcher<t> is(Object expected) {<br />        return getMatcher(expected, true);<br />    }<br />    public static <t> RootMatcher<t> getMatcher(Object expected, boolean checkType) {<br />        try {<br />            Class matcherClass = Class.forName(expected.getClass().getName() + "Matcher");<br />            Constructor constructor = matcherClass.getConstructor(expected.getClass());<br />            return (RootMatcher<t>) constructor.newInstance(expected);<br />        } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {<br />        }<br />        return (RootMatcher<t>) new EqualMatcher(expected);<br />    }<br /></t></t></t></t></t></t></code></pre><br /><div>As you can see the factory method tries to find out which matcher should it return by using two conventions</div><div></div><ol><li><span style="text-indent: -0.25in;">The matcher for an object has the name of the object + the string Matcher</span></li><li><span style="text-indent: -0.25in;">The matcher is in the same package as the object to be matched (recommendable to be in the same package, but in the test directory)</span></li></ol>Using this strategy I succeeded in using a single matcher: RootMatcher.is that will&nbsp; provide me the exact matcher that I need<br /><div style="margin-left: 0in; mso-add-space: auto;"><o:p></o:p></div><div style="margin-left: 0in; mso-add-space: auto;"><br /></div><div style="margin-left: 0in; mso-add-space: auto;">And to solve the recursive nature of the object relations (issue #3), when checking object fields I used the method from RootManager to check equality that will use matchers:<o:p></o:p></div><pre style="border: solid thin gray;"><code><br />    public boolean checkEquality(Object expected, Object received) {<br />        String result = checkEqualityAndReturnError(expected, received);<br />        return result == null || result.trim().isEmpty();<br />    }<br /><br />    public String checkEqualityAndReturnError(Object expected, Object received) {<br />        if (isIgnoreObject(expected)) {<br />            return null;<br />        }<br />        if (expected == null &amp;&amp; received == null) {<br />            return null;<br />        }<br />        if (expected == null || received == null) {<br />            return "Expected or received is null and the other is not: expected " + expected + " received " + received;<br />        }<br />        RootMatcher matcher = getMatcher(expected);<br />        boolean result = matcher.matches(received);<br />        if (result) {<br />            return null;<br />        } else {<br />            StringBuilder sb = new StringBuilder();<br />            matcher.describeTo(sb);<br />            return sb.toString();<br />        }<br />    }<br /></code></pre><br /><div style="margin-left: 0in; mso-add-space: auto;">But how about collections (issue #4). To solve that, all you have to do is to implement matchers for collections that extend RootMatcher.<o:p></o:p></div><br /><div>So the only remaining issue is #5: to make the matcher more flexible, to be able to tell the matcher which field should it ignore and which should it take into account. For this I introduced the concept of “ignoreObject”. This is an object that the matcher will ignore when it will find a reference to it in a template (expected object). How does it work? First of all, in RootMatcher I offer methods to return the ignore object for any Java type:<o:p></o:p></div><div><br /></div><pre style="border: solid thin gray;"><code><br />    private final static Map<class object=""> ignorable = new HashMap<class object="">();<br /><br />    static {<br />        ignorable.put(String.class, "%%%%IGNORE_ME%%%%");<br />        ignorable.put(Integer.class, new Integer(Integer.MAX_VALUE - 1));<br />        ignorable.put(Long.class, new Long(Long.MAX_VALUE - 1));<br />        ignorable.put(Float.class, new Float(Float.MAX_VALUE - 1));<br />    }<br /><br />    /**<br />     * we will ignore mock objects in matchers<br />     */<br />    private boolean isIgnoreObject(Object object) {<br />        if (object == null) {<br />            return false;<br />        }<br />        Object ignObject = ignorable.get(object.getClass());<br />        if (ignObject != null) {<br />            return ignObject.equals(object);<br />        }<br />        return Mockito.mockingDetails(object).isMock();<br />    }<br /><br />    @SuppressWarnings("unchecked")<br />    public static <m> M getIgnoreObject(Class<m> clazz) {<br />        Object obj = ignorable.get(clazz);<br />        if (obj != null) {<br />            return (M) obj;<br />        }<br />        return (M) Mockito.mock(clazz);<br />    }<br /><br />    @SuppressWarnings("unchecked")<br />    public static <m> M getIgnoreObject(Object obj) {<br />        return (M) getIgnoreObject(obj.getClass());<br />    }<br /></m></m></m></class></class></code></pre><br /><div>As you can see, the ignored object will be the one which is mocked. But for classes that cannot be mocked (final classes) I provided some arbitrary fixed values that are very improbable to appear(this part can be improved <span style="font-family: Wingdings; mso-ascii-font-family: Calibri; mso-ascii-theme-font: minor-latin; mso-char-type: symbol; mso-hansi-font-family: Calibri; mso-hansi-theme-font: minor-latin; mso-symbol-font-family: Wingdings;">J</span>). For this to work the developer has to use the equality methods provided in RootMatcher: checkEqualityAndReturnError which will check for ignored objects. Using this strategy and the builder pattern which I presented last year (<a href="http://www.javaadvent.com/2012/12/using-builder-pattern-in-junit-tests.html">http://www.javaadvent.com/2012/12/using-builder-pattern-in-junit-tests.html</a>) I can easily make my assertions for a complex object:<o:p></o:p></div><div><br /></div><pre style="border: solid thin gray;"><code><br />import static […]RootMatcher.is;<br />Order expected = OrderBuilder.anOrder().withQuantity(2)<br />                                       .withTimestamp(RootManager.getIgnoredObject(Long.class))<br />                                       .withDescription(“specific description”).build()<br />assertThat(order, is(expected);<br /></code></pre><br /><div>As you can see I could easily specify that the timestamp should be ignored and which allowed me to use the same matcher with a completely different set of fields to be verified.<o:p></o:p><br /><br /></div><div>Indeed, this strategy requires pretty much preparation, making all the builders and the matchers. But if we want to have a code that is tested, if we want to make testing a job that has the primary focus on the test flow that should be covered, we need such a foundation and these tools that help us easily establish our precondition and build our expected state.<o:p></o:p><br /><br />Of course that the implementation can be improved using annotation, but the core concepts still remain.<br /><br /></div><div>I hope this article helps you improve your testing style, and if there’s enough interest I will do my best to put the complete code on a public repository.<o:p></o:p></div><div><br />Thank you.<o:p></o:p></div><br /><div><br /></div> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></p>