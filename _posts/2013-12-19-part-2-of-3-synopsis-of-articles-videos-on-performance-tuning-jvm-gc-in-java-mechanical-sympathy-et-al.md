---
id: 41
title: '(Part 2 of 3): Synopsis of articles &#038; videos on Performance tuning, JVM, GC in Java, Mechanical Sympathy, et al'
date: 2013-12-19T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/part-2-of-3-synopsis-of-articles-videos-on-performance-tuning-jvm-gc-in-java-mechanical-sympathy-et-al/
permalink: /2013/12/part-2-of-3-synopsis-of-articles-videos-on-performance-tuning-jvm-gc-in-java-mechanical-sympathy-et-al.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Mani Sarkar
blogger_permalink:
  - /2013/12/part-2-of-3-synopsis-of-articles-videos.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/8161607200679315844
categories:
  - 2013
  - Atomic I/O
  - CPU
  - GC
  - hotspot
  - java
  - JIT
  - JVM
  - Linux
  - low latency
  - mechanical sympathy
  - Memory Barriers
  - performance tuning
---
<div style="text-align: justify;"><div style="text-align: start;"><div><i><span style="font-family: inherit;">This is a continuation of the previous post titled&nbsp;<a href="http://www.javaadvent.com/2013/12/part-1-of-3-synopsis-of-articles-videos.html" target="_blank">(Part 1 of 3): Synopsis of articles &amp; videos on Performance tuning, JVM, GC in Java, Mechanical Sympathy, et al</a>.</span></i><br /><span style="font-family: inherit;"><br /></span><br /><div style="text-align: justify;"><span style="font-family: inherit;">Without any further ado, lets get started with our next set of blogs and videos, chop...chop...! This time its Martin Thompson's blog posts and talks. Martin's first post on Java Garbage collection distilled basically distils the GC process and the underlying components including throwing light on a number of interesting GC flags (<b>-XX:...</b>). In his next talk he does his myth busting <i>shaabang</i> about mechanical sympathy, what people correctly believe in and also some of the misconceptions they have bought into. In the talk on performance testing, Martin takes it further and fuses Java, OS and the hardware to show how understanding&nbsp;</span>aspects&nbsp;<span style="font-family: inherit;">of all these can help write better programs.&nbsp;</span><br /><span style="font-family: inherit;"><br /></span></div><span style="font-family: inherit;"><strong><br /></strong><strong><a href="http://www.infoq.com/articles/Java_Garbage_Collection_Distilled" target="_blank">Java Garbage Collection Distilled</a> by Martin Thompson</strong></span></div><div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">There are too many flags to allow tuning the GC to achieve the throughput and latency your application requires. There's plenty of documentation on the specifics of the bells and whistles around them but none to guide you through them.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><div style="text-align: left;"><div style="text-align: justify;"><div style="text-align: left;"><span style="font-family: inherit;">- The Tradeoffs - throughput (<b>-XX:GCTimeRatio=99</b>), latency (<b>-XX:MaxGCPauseMillis=&lt;n&gt;</b>) and memory (<b>-Xmx&lt;n&gt;</b>) are the key variables that the collectors depend upon. It is important to note that Hotspot&nbsp;<i>often </i>cannot achieve the above targets. If a low-latency application goes unresponsive for more than a few seconds it can spill disaster. Tradeoffs play out as they</span></div></div></div></div><div style="text-align: justify;"><div style="text-align: left;"><span style="font-family: inherit;">* provide more memory to GC algorithms</span></div></div><div style="text-align: justify;"><div style="text-align: left;"><span style="font-family: inherit;">* GC can be reduced by containing the live set and keeping heap size small</span></div></div><div style="text-align: left;"><span style="font-family: inherit;">* frequency of pauses can be reduced by managing heap and generation sizes &amp; controlling application's object allocation rate</span></div><div style="text-align: justify;"><div style="text-align: left;"><span style="font-family: inherit;">* frequency of large pauses can be reduced by running GC concurrently</span></div></div><div style="text-align: justify;"><div style="text-align: left;"><span style="font-family: inherit;"><br /></span></div></div><div style="text-align: justify;"><span style="font-family: inherit;">- Object Lifetimes</span></div><div style="text-align: justify;"><span style="font-family: inherit;">GC algorithms are often optimised with the expectation that most objects live for a very short period of time, while relatively few live for very long. Experimentation has shown that generational garbage collectors support much better throughput than non-generational ones - hence used in server JVMs.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Stop-The-World Events</span></div><div style="text-align: justify;"><span style="font-family: inherit;">For GC to occur it is necessary that all the threads of a running application must pause - garbage collectors do this by&nbsp;</span>signalling<span style="font-family: inherit;">&nbsp;the threads to stop when they come to a safe-point. Time to safe-point is an&nbsp;important consideration in low-latency applications and can be found using the&nbsp;</span><strong style="font-family: inherit;">‑XX:+PrintGCApplicationStoppedTime</strong><span style="font-family: inherit;"> flag in addition to the other GC flags.&nbsp;When a STW event occurs a system will undergo significant scheduling pressure as the threads resume when released from safe-points, hence <i>less</i> STWs makes an application <i>more</i> efficient.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Heap Organisation in Hotspot</span></div><div style="text-align: justify;"><span style="font-family: inherit;">Java heap is divided in various regions, an object is created in Eden, and moved into the survivor spaces, and eventually into tenured. PermGen was used to store runtime objects such as classes and static strings. Collectors take help of Virtual spaces to meet throughput &amp; latency targets, and adjusting the region sizes to reach the targets.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Object Allocation</span></div><div style="text-align: justify;"><span style="font-family: inherit;">TLAB (Thread Local Allocation Buffer) is used to allocate objects in Java, which is cheaper than using <i>malloc</i> (takes 10 instructions on most platforms). Rate of minor collection is directly proportional to the rate of object allocation.&nbsp;</span><span style="font-family: inherit;">Large objects (</span><b style="font-family: inherit;">-XX:PretenureSizeThreshold=n</b><span style="font-family: inherit;">) may have to be allocated in Old Gen, but if the threshold is set below the TLAB size, then they will <i>not</i> be created in old gen - (note) does not apply to the <b>G1</b> <b>collector</b>.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Minor Collections</span></div><div style="text-align: justify;"><span style="font-family: inherit;">Minor collection occurs when Eden becomes full, objects are promoted to the tenured space from Eden once they get old i.e. cross the threshold (<b>-XX:MaxTenuringThreshold</b>). &nbsp;In minor collection, live reachable objects with known GC roots are copied to the survivor space. Hotspot maintains cross-generational references using a card table. Hence size of the old generation is also a factor in the cost of minor collections. Collection efficiency can be achieved by adjusting the size of Eden to the number of objects to be promoted. These are prone to STW and hence problematic in recent times.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Major Collections</span></div><div style="text-align: justify;"><span style="font-family: inherit;">Major collections collect the old generation so that objects from the young gen can be promoted. Collectors track a fill threshold for the old generation and begin collection when the threshold is passed. To avoid promotion failure you will need to tune the padding that the old generation allows to accommodate promotions (<b>-XX:PromotedPadding=&lt;n&gt;</b>). Heap resizing can be avoided using the -<b>Xms</b> and <b>-Xmx</b> flags. Compaction of old gen causes one of the largest STW pauses an application can experience and directly proportion to the number of live objects in old gen. Tenure space can be filled up slower, by adjusting the survivor space sizes and tenuring threshold but this in turn can cause longer minor collection pause times as a result of increased copying costs between the survivor spaces.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Serial Collector</span></div><div style="text-align: justify;"><span style="font-family: inherit;">It is the simplest collector with the smallest footprint (<b>-XX:+UseSerialGC</b>) and uses a single thread for both minor and major collections.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Parallel Collector</span></div><div style="text-align: justify;"><span style="font-family: inherit;">Comes in two forms (<b>-XX:+UseParallelGC</b>) and (<b>-XX:+</b><b>UseParallelOld</b><b>GC</b>) and uses multiple threads for minor collections and a single thread for major collections - since Java 7u4 uses multiple threads for both type of collections. Parallel Old performs very well on a multi-processor system, suitable for batch applications. This collector can be helped by providing more memory, larger but fewer collection pauses. Weigh your bets between the Parallel Old and Concurrent collector depending on how much pause your application can withstand (expect 1 to 5 seconds pauses per GB of live data on modern hardware while old gen is compacted).</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Concurrent Mark Sweep (CMS) Collector</span></div><div style="text-align: justify;"><span style="font-family: inherit;">CMS (<b>-XX:+UseConcMarkSweepGC</b>) collector runs in the Old generation  collecting tenured objects that are no longer reachable during a <i>major</i> collection. CMS is not a compacting collector causing fragmentation in Old gen over time. Promotion failure will trigger FullGC when a large object cannot fit in Old gen. CMS runs alongside your application taking CPU time. CMS can suffer "concurrent mode failures" when it fails to collect at a sufficient rate to keep up with promotion.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Garbage First (G1) Collector</span></div><div style="text-align: justify;"><span style="font-family: inherit;">G1 (<b>-XX:+UseG1GC</b>) is a new collector introduced in Java 6 and now officially supported in Java 7. It is a generational collector with a partially concurrent collecting algorithm, compacts the Old gen with smaller incremental STW pauses. It divides the heap into fixed sized regions of variable purpose. G1 is target driven on latency (<strong>–XX:MaxGCPauseMillis=&lt;n&gt;</strong>, default value = 200ms). Collection on the humongous regions can be very costly. It uses "Remembered Sets" to keep track of references to objects from other regions. There is a lot of cost involved with book keeping and maintaining "Remembered Sets". Similar to CMS, G1 can suffer from an evacuation failure (to-space overflow).</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Alternative Concurrent Collectors</span></div><div style="text-align: justify;"><span style="font-family: inherit;">Oracle JRockit Real Time, IBM Websphere Real Time, and Azul Zing are alternative concurrent collectors. &nbsp;Zing according to the author is the only Java collector that strikes a balance between collection, compaction, and maintains a high-throughput rate for all generations. Zing is concurrent for all phases including during minor collections, irrespective of heap size. For all the concurrent collectors targeting latency you have to give up throughput and gain footprint. Budget for heap size at least 2 to 3 times the live set for efficient operation.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">- Garbage Collection Monitoring &amp; Tuning</span></div></div><div><div style="text-align: justify;"><span style="font-family: inherit;">Important flags to always have enabled to collect optimum GC details:</span></div><pre><div style="text-align: justify;"><br /><span style="font-family: inherit;">-verbose:gc<br />-Xloggc:&lt;filename&gt;<br />-XX:+PrintGCDetails<br />-XX:+PrintGCDateStamps<br />-XX:+PrintTenuringDistribution<br />-XX:+PrintGCApplicationConcurrentTime <br />-XX:+PrintGCApplicationStoppedTime</span></div><br /><span style="font-family: inherit;"><br /></span></pre><pre></pre><div style="text-align: justify;"><span style="font-family: inherit;">Use applications like <a href="https://github.com/chewiebug/GCViewer" target="_blank">GCViewer</a>, <a href="http://visualvm.java.net/" target="_blank">JVisualVM</a> (with Visual GC plugin) to study the behaviour of your application as a result of GC actions. Run representative load tests that can be executed repeatedly (as you gain knowledge of the various collectors), keep experimenting with different configuration until you reach your throughput and latency targets. <a href="http://www.jhiccup.com/" target="_blank">jHiccup</a> helps track pauses within the JVM. &nbsp;As known to us it's a difficult challenge to strike a balance between latency requirements, high object allocation and promotion rates combined, and that sometimes choosing a commercial solution to achieve this might be a more sensible idea.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;"><b>Conclusion:</b> GC is a big subject by itself and has a number of components, some of them are constantly replaced and it's important to know what each one stands for. The GC flags are as much important as the component to which they are related and it's important to know them and how to use them. Enabling some standard GC flags to record GC logs does not have any significant impact on the performance of the JVM. Using third-party freeware or commercial tools help as long as you follow the authors methodology.</span><br /><span style="font-family: inherit;"><br /></span></div><em><span style="font-family: inherit;">--- Highly reading the article multiple times, as Martin has covered lots of details about GC and the collectors which requires close inspection and good understanding. &nbsp;---</span></em><br /><div><em><span style="font-family: inherit;"><br /></span></em></div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;"><strong>Martin Thompson's:&nbsp; Mythbusting modern hardware to gain "Mechanical Sympathy"&nbsp;</strong><a href="http://www.youtube.com/watch?v=MC1EKLQ2Wmg" target="_blank">Video</a>&nbsp;*&nbsp;<a href="http://gotocon.com/dl/goto-aar-2012/slides/MartinThompson_MythbustingModernHardwareToGainMechanicalSympathy.pdf" target="_blank">Slides</a></span></div><div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">He classifies myth into three categories - <i>possible</i>, <i>plausible</i> and <i>busted</i>! In order to get the best out of the hardware you own, you need TO KNOW your hardware. Make tradeoffs as you go along, changing knobs ;), it's not as scary as you may think.</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;">Good question: do normal developers understand the hardware they program on? Or cannot understand what's going on? Or do we have the discipline and make the effort to understand the platform we work with?</span></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;"><b>Myth 1</b> - <i>CPUs are not getting faster - </i>clock speed isn't everything, Sandy bridge architecture is the faster breed. 6 ports to support parallelism (6 ops/cycle). Haswell has 8 ports! Code doing <i>division operations</i> perform slower than any other arithmetic operations. CPUs have both front-end and back-end cycles. It's getting faster as we are feeding them faster! - <i>PLAUSIBLE</i></span></div><div style="text-align: justify;"><b><span style="font-family: inherit;"><br /></span></b></div><div style="text-align: justify;"><span style="font-family: inherit;"><b>Myth 2</b>&nbsp;-&nbsp;<i>Memory provides us random access - </i>CPU registers and buffers, internal caches (L1, L2, L3) and memory - mentioned in the order in of speed of access to these areas respectively. Manufacturers have been doing things to CPUs to bring down its operational temperature by performing direct access operations. Writes are less hassle than reads - buffer misses are costly. L1 is organised into cache-lines containing code that the processor will execute - efficiency is achieved by not having cache-line misses. Pre-fetchers help reduce latency and help during reading streaming and predictable data. TLB misses can also cost efficiency (size of TLB = 4K = size of memory page). In short reading memory isn't anywhere close to reading it randomly but SEQUENTIALLY due to the way the underlying hardware works. Writing highly branched code can cause slow down in execution of the program - keep things together that is, cohesive is the key to efficiency. - <i>BUSTED</i></span><br /><span style="font-family: inherit;">Note: TLAB and TLB are two different concepts, <i>google to find out the difference</i>!</span></div><div style="text-align: justify;"><i><span style="font-family: inherit;"><br /></span></i></div><div><div style="text-align: justify;"><span style="font-family: inherit;"><b>Myth 3</b>&nbsp;-&nbsp;<i>HDD provides random access - </i>spinning disc and an arm moves about reading data. More sectors are placed in the outer tracks than the inner tracks (zone bit recording). Spinning the discs faster isn't the way to increase HDD performance. 4K is the minimum you can read or write at a time. Seek time in the best disc is 3-6 ms, laptop drives are slower (15 ms). Data transfers take 100-220 Mbytes/sec. Adding a cache can improve writing data into the disc, not so much for reading data from disks. -&nbsp;<i>BUSTED</i></span></div></div><div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px;"></div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px;"><div style="margin: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><b>Myth 4</b>&nbsp;-&nbsp;<i>SSDs provides random access -&nbsp;</i>Reads and writes are great, works very fast (4K at a time). Delete is not like the real deletes, it's marked deleted and not really deleted - as you can't erase at &nbsp;high resolution hence a whole block needs to be erased at a time (hence marked deleted). All this can cause fragmentation, and GC and compaction is required. Reads are smooth, writes are hindered by fragmentation, GC, compaction, etc..., also to be ware of write-amplification. A few disadvantages when using SSD but overall quite performant. -&nbsp;<i>PLAUSIBLE</i></span></div></div></div></div><span style="font-family: inherit;"><br /></span><br /><div style="text-align: justify;"><span style="font-family: inherit;">Can we understand all of this and write better code?</span></div><br /><div style="text-align: justify;"><br /></div><span style="font-family: inherit;"><b style="text-align: justify;">Conclusion: </b><span style="text-align: justify;">do not take everything in the space for granted just because it's on the tin, examine, inspect and investigate for yourself the internals where possible before considering it to be possible, or plausible - in order to write good code and take advantage of these features.</span></span><br /><span style="font-family: inherit;"><span style="text-align: justify;"><br /></span><em>--- Great talk and good coverage of the mechanical sympathy topic with some good humour, watch the video for performance statistics gathered on each of the above hardware components &nbsp;---</em></span><br /><span style="font-family: inherit;"><strong><br /></strong><strong><a href="http://parleys.com/play/518f08ece4b0549489a4a398/chapter0/about" target="_blank">"Performance Testing Java Applications"</a> by Martin Thompson</strong></span></div><div><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">"How to use a profiler?" or&nbsp;</span>"How to use a debugger?"&nbsp;</div></div><div><div style="text-align: justify;"><br />What is Performance? Could mean two things like throughput or bandwidth (how much can you get through) and latency (how quickly the system responds).</div></div><div style="orphans: auto; text-align: start; text-indent: 0px; widows: auto;"><div style="margin: 0px;"><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">Response time changes as we apply more load on the system. Before we design any system, we need to gather performance requirements i.e. what is the throughput of the system or how fast you want the system to respond (latency)? Does your system scale economically with your business?</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">Developer time is expensive, hardware is cheap! For anything, you need a transaction budget (with a good break-down of the different components and processes the system is going to go through or goes through).</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="-webkit-text-stroke-width: 0px; color: black; font-family: inherit; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;">How can we do performance testing? Apply load to a system and see if the throughput goes up or down? And what is the response time of the system as we apply load. Stress testing is different from <i>load testing</i> (see&nbsp;</span><a href="http://en.wikipedia.org/wiki/Load_testing" target="_blank">Load testing</a><span style="font-family: inherit;">) , <i>stress testing </i>(see&nbsp;</span><a href="http://en.wikipedia.org/wiki/Stress_testing" target="_blank">Stress testing</a>)<i>&nbsp;</i><span style="font-family: inherit;">is a point where things break (collapse of a system), an ideal system will continue with a flat line. Also it's important to perform load testing not just from one point but from multiple points and concurrently. Most importantly high duration testing is very important - which bring a lot of anomalies to the surface i.e. memory leaks, etc...</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;">Building up a test suite is a good idea, a suite made up of smaller parts. We need to know the basic building blocks of the system we use and what we can get out of it. Do we know the different threshold points of our systems and how much its components can handle? Very important to know the algorithms we use, know how to measure them and use it accordingly.</div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;">When should we test performance?&nbsp;</div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;">"Premature optimisation is the root of all evil" - Donald Knuth / Tony Hoare</div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">What does optimisation mean? Knowing and choosing your data and working around it for performance. <i><b>New development practices: we need to test early and often!</b></i></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">From a Performance perspective, "test first" practice is very important, and then design the system gradually as changes can cost a lot in the future.</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;"><span style="font-family: inherit;"><span style="color: red;">Red</span> - <span style="color: #274e13;">Green</span> - </span><i style="-webkit-text-stroke-width: 0px; color: black; font-family: inherit; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;">Debug</i><span style="font-family: inherit;"> - </span><i style="-webkit-text-stroke-width: 0px; color: black; font-family: inherit; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;">Profile</i><span style="font-family: inherit;"> - <span style="color: blue;">Refactor</span>, a new way of "test first"&nbsp;</span>performance<span style="font-family: inherit;">&nbsp;methodology as opposed to <span style="color: red;">Red</span>-<span style="color: #274e13;">Green</span>-<span style="color: blue;">Refactor</span> methodology only! Earlier and shorter feedback cycle is better than finding something out in the future.</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><i>Use "like live" pairing stations, Mac is a bad example to work on if you are working in the Performance space - a Linux machine is a better option.</i>&nbsp;</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: justify; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit; font-style: normal;">Performance tests can fail the build - and it should fail a build in your CI system! What should a micro benchmark look like (i.e. calliper)?&nbsp;</span><i>Division&nbsp;operations</i> in your code can be very expensive, instead use <i style="font-style: normal;">a </i><i>mask operator</i>!</div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;">What about concurrency testing? Is it just about performance? Invariants? Contention?&nbsp;</span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;">What about system performance tests? Should we be able to test big and small clients with different ranges. It's fun to know deep-dive details of the system you work on. A business problem is the core and the most important one to solve and NOT to discuss on what&nbsp;<u>frameworks to use to build it</u>. Please do not use Java serialisation as it is not designed for on the-wire-protocol! Measure performance of a system using a observer rather than measure it from inside the system only.</div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><br /></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;">Performance Testing Lessons - lots of technical stuff and lots of cultural stuff. Technical Lessons - learn how to measure, check out histograms! Do not sample a system, we miss out when things when the system go strange, outliers, etc... - histograms help! Knowing what is going on around the areas where the system takes a long time is important! Capturing time from the OS is a very important as well.&nbsp;</div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><br /></div><div style="text-align: justify;">With time you get - accuracy, precision and resolution, and most people mix all of these up. On machines with dual sockets, <i>time</i> might not be synchronised. Quality of the time information is very dependent on the OS you are using. Time might be an issue on <i>virtualised</i> systems, or between two machines. This issue can be resolved, do round-trip times between two systems (note the start and stop clock times) and half them to get a more accurate time. Time can go backwards on you on certain OSes (possibly due to NTP) - instead use monotonic time.</div></div><div style="text-align: justify;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;">Know your system, its underlying components - get the metrics and study them ! Use a Linux tool like <i>perstat</i>, will give lots of performance and statistics related information on your CPU and OS - branch predictions and cache-misses!</span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div><div style="text-align: justify;">RDTSC is not an ordered-instructions execution system, x86 is an ordered instruction systems and operations do not occur in a unordered fashion.</div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;">Theory of constraints! - Always start with number 1 problem on the list, the one that takes most of the time - the bottleneck of your system, the remaining sequence of issues might be dependent on the number 1 issue and are not separate issues!</span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;">Trying to create a performance team is an anti-pattern - make the experts help bring the skills out to the rest of the team, and stretch-up their abilities!</span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="font-weight: normal;"><div style="text-align: justify;">Beware of <i>YAGNI</i> - about doing performance tests - smell of excuse!</div></div><div style="font-weight: normal;"><div style="text-align: justify;"><br /></div></div><div style="font-weight: normal;"><div style="text-align: justify;">Commit builds &gt; 3.40 mins = worrying, same for acceptance test build &gt; 15 mins = lowers team confidence.</div></div><div style="font-weight: normal;"><div style="text-align: justify;"><br /></div></div><div style="font-weight: normal;"><div style="text-align: justify;">Test environment <u>should equal</u> to production environment! Easy to get exactly similar hardware these days!</div></div><div style="font-weight: normal;"><div style="text-align: justify;"><br /></div></div><div style="text-align: justify;"><b>Conclusion: </b>Start with a "test first" performance testing approach when writing applications that are low latency dependent. Know your targets and work towards it. Know your underlying systems all the way from hardware to the development environment. Its not just technical things that matter, cultural things matter as much, when it comes to performance testing. Share and spread the knowledge across the team rather than isolating it to one or two people i.e. so called experts in the team. Its everyone's responsibility not just a few seniors in the team. Learn more about time across various hardware and operating systems, and between systems.</div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;"><br /></span></div></div></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><div style="text-align: justify;"><span style="font-family: inherit;">As it is not practical to review all such videos and articles, a number of them have been provided in the links below for further study. In many cases I have paraphrased or directly quoted what the authors have to say to preserve the message and meaning they wished to convey. A follow-on to this blog post will appear in the same space under the title&nbsp;<i><a href="http://www.javaadvent.com/2013/12/part-3-of-3-synopsis-of-articles-videos.html" target="_blank">(Part 3 of 3): Synopsis of articles &amp; videos on Performance tuning, JVM, GC in Java, Mechanical Sympathy, et al</a>&nbsp;on&nbsp;</i></span><i>23rd Dec 2013.</i></div><div style="text-align: justify;"><span style="font-family: inherit;"><i><br /></i></span><br /><span style="text-align: start;">Feel free to post your comments below or tweet&nbsp;</span><span style="text-align: start;"></span><span style="text-align: start;">at&nbsp;</span><a href="http://twitter.com/theNeomatrix369" style="text-align: start;" target="_blank">@theNeomatrix369</a><span style="text-align: start;">!</span></div><h2><strong>Useful resources</strong></h2><h2><div style="text-align: justify;"><div style="text-align: start;"><ul><li style="font-size: medium; font-weight: normal;"><i>Are your GC logs speaking to you, the G1GC edition by Kirk Pepperdine -&nbsp;<a href="http://www.parleys.com/play/51643b58e4b09b60aec89cf4/chapter0/about" target="_blank">Slides</a>&nbsp;-&nbsp;<a href="http://parleys.com/play/517f2503e4b0c6dcd95464ad/chapter0/about" target="_blank">Video</a></i></li><li style="font-size: medium; font-weight: normal;"><i><a href="http://skillsmatter.com/podcast/home/performance-special-interest-group" target="_blank">Performance Special Interest Group discussion</a>&nbsp;- moderated by Richard Warburton</i><i>&nbsp;(video)</i></li><li style="font-size: medium; font-weight: normal;"><i><a href="http://parleys.com/play/517fb1c9e4b0c2a859eb9ecb/chapter0/about" target="_blank">Caching in: understand, measure and use your CPU Cache more effectively"</a>&nbsp;by @RichardWarburto -</i><i>&nbsp;(video &amp; slides)</i></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://lwn.net/Articles/552095/" target="_blank">Article on Atomic I/O operations (Linux)</a>&nbsp;by Jonathan Corbet</em></li><li style="font-size: medium; font-weight: normal;"><i><a href="http://www.azulsystems.com/resources/presentations" target="_blank">Articles and Presentations about Azul Zing, Low Latency GC &amp; OpenJDK</a>&nbsp;by Gil Tene (videos &amp; slides)</i></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/presentations/Lock-Free-Algorithms" target="_blank">Lock-Free Algorithms For Ultimate Performance</a>&nbsp;by Martin Thompson</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="https://plus.google.com/communities/107178245817384004088" target="_blank">Performance Java User's Group - "For expert Java developers who want to push their systems to the next level"</a></em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/articles/Java-Thread-Pool-Performance-Tuning" target="_blank">Tuning the Size of your thread pool</a>&nbsp;by Kirk Pepperdine</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/presentations/latency-pitfalls" target="_blank">How NOT to measure Latency</a>&nbsp;by Gil Tene</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.infoq.com/presentations/Java-GC-Azul-C4" target="_blank">Understanding Java Garbage Collection and What You Can Do about It</a>&nbsp;by Gil Tene</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://vanillajava.blogspot.co.uk/search/label/Performance" target="_blank">Vanilla #Java Understanding how Core Java really works can help you write simpler, faster applications</a>&nbsp;by Peter Lawrey</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.youtube.com/watch?v=Yg6_ulhwLw0" target="_blank">Profiling Java In Production</a>&nbsp;- by Kaushik Srenevasan</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://blog.ragozin.info/2013/11/hotspot-jvm-garbage-collection-options.html" target="_blank">HotSpot JVM garbage collection options cheat sheet (v3)</a>&nbsp;by Alexey Ragozin</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/40696.pdf" target="_blank">Optimizing Google’s Warehouse Scale Computers: The NUMA Experience</a>&nbsp;-&nbsp; authors from Univ. of Cal (SD) &amp; Google!</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="https://docs.google.com/viewer?a=v&amp;pid=forums&amp;srcid=MDUxODU4OTA1NTU1MzUxODE5MDQBMTA5MDUzNTI5Mzg2ODk0MjY5NjUBYWM5cnR1MEY4Z1FKATQBAXYy" target="_blank">MegaPipe: A New Programming Interface for Scalable Network I/O</a>&nbsp;by several authors!</em></li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.akkadia.org/drepper/cpumemory.pdf" target="_blank">What Every Programmer Should Know About Memory</a>&nbsp;by Ulrich Drepper</em>&nbsp;</li><li style="font-size: medium; font-weight: normal;"><em><a href="http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2009.04.05a.pdf" target="_blank">Memory Barriers: a Hardware View for Software Hackers</a>&nbsp;- Paul E. McKenney (Linux Technology Center - IBM Beaverton)</em></li></ul></div></div></h2></div></div></div></div><em><span style="font-family: inherit;">This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</span></em>