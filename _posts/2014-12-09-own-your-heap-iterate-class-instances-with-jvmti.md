---
id: 25
title: 'Own your heap: Iterate class instances with JVMTI'
date: 2014-12-09T08:01:00+00:00
author: gpanther
layout: post
permalink: /2014/12/own-your-heap-iterate-class-instances-with-jvmti.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Oleg Shelajev
blogger_permalink:
  - /2014/12/own-your-heap-iterate-class-instances.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/6664933667978218801
categories:
  - 2014
  - java
  - Java Advent
  - java advent 2014
  - java agent
  - javaagent
  - JVM
  - thread
---
Today I want to talk about a different Java that most of us don’t see and use every day, to be more exact about lower level bindings, some native code and how to perform some small magic. Albeit we won’t get to the true source of magic on JVM, but performing some small miracles is within a reach of a single post. <br /><br />I spend my days researching, writing and coding on the <a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a> team at <a href="http://zeroturnaround.com/">ZeroTurnaround</a>, a company that creates tools for Java developers that mostly run as javaagents. It’s often the case that if you want to enhance the JVM without rewriting it or get any decent power on the JVM you have to dive into the beautiful world of Java agents.  These come in two flavors: Java javaagents and native ones. In this post we’ll concentrate on the latter.  <br /> <blockquote>Note, this GeeCON Prague presentation by <a href="https://twitter.com/antonarhipov">Anton Arhipov</a>, who is an <a href="http://zeroturnaround.com/software/xrebel/">XRebel</a> product lead, is a good starting point to learn about javaagents written entirely in Java: <a href="https://speakerdeck.com/antonarhipov/geecon-prague-2014-having-fun-with-javassist">Having fun with Javassist</a>.</blockquote><br />In this post we’ll create a small native JVM agent, explore the possibility of exposing native methods into the Java application and find out how to make use of the <a href="http://download.oracle.com/javase/8/docs/technotes/guides/jvmti/">Java Virtual Machine Tool Interface</a>.  <br /><br />If you’re looking for a practical takeaway from the post, we’ll be able to, spoiler alert, count how many instances of a given class are present on the heap.  <br /><br /> Imagine that you are Santa's trustworthy hacker elf and the big red has the following challenge for you:<br /><b>Santa:</b> <em> My dear Hacker Elf, could you write a program that will point out how many Thread objects are currently hidden in the JVM’s heap?</em><br /><b>Another elf that doesn’t like to challenge himself would answer:</b> <em>It’s easy and straightforward, right?</em> <pre><code><br />return Thread.getAllStackTraces().size();<br /></code></pre> But what if we want to over-engineer our solution to be able to answer this question about any given class? Say we want to implement the following interface?   <pre><code><br />public interface HeapInsight {<br />  int countInstances(Class klass);<br />}<br /></code></pre> Yeah, that’s impossible, right? What if you receive <i>String.class</i> as an argument?  Have no fear, we’ll just have to go a bit deeper into the internals on the JVM. One thing that is available to JVM library authors is <a href="http://download.oracle.com/javase/8/docs/technotes/guides/jvmti/">JVMTI</a>, a Java Virtual Machine Tool Interface. It was added ages ago and many tools, that seem magical, make use of it. JVMTI offers two things:  <ul><li>a native API  <li>an instrumentation API to monitor and transform the bytecode of classes loaded into the JVM. </ul><br />For the purpose of our example, we’ll need access to the native API. What we want to use is the <a href="http://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#IterateThroughHeap">IterateThroughHeap</a> function, which lets us provide a custom callback to execute for every object of a given class. <br /><br />First of all, let’s make a native agent that will load and echo something to make sure that our infrastructure works.  <br /><br />A native agent is something written in a C/C++ and compiled into a dynamic library to be loaded before we even start thinking about Java. If you’re not proficient in C++, don’t worry, plenty of elves aren’t, and it won’t be hard. My approach to C++ includes 2 main tactics: programming by coincidence and avoiding segfaults. So since I managed to write and comment the example code for this post, collectively we can go through it. Note: the paragraph above should serve as a disclaimer, don’t put this code into any environment of value to you.  <br /><br />Here’s how you create your first native agent:  <pre><code><br />#include <jvmti.h><br />#include <iostream><br /> <br />using namespace std;<br /> <br />JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved)<br />{<br />  cout << "A message from my SuperAgent!" << endl;<br />  return JNI_OK;<br />}<br /></code></pre> The important part of this declaration is that we declare a function called <i>Agent_OnLoad</i>, which follows <a href="http://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#starting">the documentation for the dynamically linked agents</a>. <br /><br />Save the file as, for example a <i>native-agent.cpp</i> and let’s see what we can do about turning into a library.  <br /><br />I’m on OSX, so I use <a href="http://clang.llvm.org/">clang</a> to compile it, to save you a bit of googling, here’s the full command:  <pre><code><br />clang -shared -undefined dynamic_lookup -o agent.so -I /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include/ -I /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/include/darwin native-agent.cpp<br /></code></pre> This creates an <i>agent.so</i> file that is a library ready to serve us. To test it, let’s create a dummy hello world Java class.   <pre><code><br />package org.shelajev;<br />public class Main {<br />   public static void main(String[] args) {<br />       System.out.println("Hello World!");<br />   }<br />}<br /></code></pre> When you run it with a correct <b>-agentpath</b> option pointing to the <i>agent.so</i>, you should see the following output:   <pre><code><br />java -agentpath:agent.so org.shelajev.Main<br />A message from my SuperAgent!<br />Hello World!<br /></code></pre> Great job! We now have everything in place to make it actually useful. First of all we need an instance of <b>jvmtiEnv</b>, which is available through a <i>JavaVM *jvm</i> when we are in the <i>Agent_OnLoad</i>, but is not available later. So we have to store it somewhere globally accessible. We do it by declaring a global struct to store it.   <pre><code><br />#include <jvmti.h><br />#include <iostream><br /> <br />using namespace std;<br /> <br />typedef struct {<br /> jvmtiEnv *jvmti;<br />} GlobalAgentData;<br /> <br />static GlobalAgentData *gdata;<br /> <br />JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved)<br />{<br />  jvmtiEnv *jvmti = NULL;<br />  jvmtiCapabilities capa;<br />  jvmtiError error;<br />  <br />  // put a jvmtiEnv instance at jvmti.<br />  jint result = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);<br />  if (result != JNI_OK) {<br />    printf("ERROR: Unable to access JVMTI!n");<br />  }<br />  // add a capability to tag objects<br />  (void)memset(&capa, 0, sizeof(jvmtiCapabilities));<br />  capa.can_tag_objects = 1;<br />  error = (jvmti)->AddCapabilities(&capa);<br /> <br />  // store jvmti in a global data<br />  gdata = (GlobalAgentData*) malloc(sizeof(GlobalAgentData));<br />  gdata->jvmti = jvmti;<br />  return JNI_OK;<br />}<br /></code></pre> We also updated the code to add a capability to tag objects, which we’ll need for iterating through the heap. The preparations are done now, we have the JVMTI instance initialized and available for us. Let's offer it to our Java code via a JNI.  <br /><br />JNI stands for <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/">Java Native Interface</a>, a standard way to include native code calls into a Java application. The Java part will be pretty straightforward, add the following <i>countInstances</i> method definition to the Main class:  <pre><code><br />package org.shelajev;<br /><br />public class Main {<br />   public static void main(String[] args) {<br />       System.out.println("Hello World!");<br />       int a = countInstances(Thread.class);<br />       System.out.println("There are " + a + " instances of " + Thread.class);<br />   }<br /><br />   private static native int countInstances(Class klass);<br />}<br /></code></pre> To accommodate the native method, we must change our native agent code. I’ll explain it in a minute, but for now add the following function definitions there:  <pre><code><br />extern "C"<br />JNICALL jint objectCountingCallback(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) <br />{<br /> int* count = (int*) user_data;<br /> *count += 1; <br /> return JVMTI_VISIT_OBJECTS;<br />}<br /> <br />extern "C"<br />JNIEXPORT jint JNICALL Java_org_shelajev_Main_countInstances(JNIEnv *env, jclass thisClass, jclass klass) <br />{<br /> int count = 0;<br />   jvmtiHeapCallbacks callbacks;<br />(void)memset(&callbacks, 0, sizeof(callbacks));<br />callbacks.heap_iteration_callback = &objectCountingCallback;<br /> jvmtiError error = gdata->jvmti->IterateThroughHeap(0, klass, &callbacks, &count);<br /> return count;<br />}<br /></code></pre> <i>Java_org_shelajev_Main_countInstances</i> is more interesting here, its name follows the convention, starting with <b>Java_</b> then the _ separated fully qualified class name, then the method name from the Java code. Also, don’t forget the <i>JNIEXPORT</i> declaration, which says that the function is exported into the Java world.  <br /><br />Inside the <i>Java_org_shelajev_Main_countInstances</i> we specify the <i>objectCountingCallback</i> function as a callback and call <i>IterateThroughHeap</i> with the parameters that came from the Java application. <br /><br />Note that our native method is static, so the arguments in the C counterpart are: <pre><code> <br />JNIEnv *env, jclass thisClass, jclass klass<br /></code></pre>for an instance method they would be a bit different: <pre><code> <br />JNIEnv *env, jobj thisInstance, jclass klass<br /></code></pre> where <i>thisInstance</i> points to the <b>this</b> object of the Java method call.  <br /><br />Now the definition of the <i>objectCountingCallback</i> comes directly from the <a href="http://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#jvmtiHeapIterationCallback">documentation</a>. And the body does nothing more than incrementing an int.  <br /><br />Boom! All done! Thank you for your patience. If you’re still reading this, you’re ready to test all the code above.  <br /><br />Compile the native agent again and run the <i>Main</i> class. This is what I see:  <pre><code><br />java -agentpath:agent.so org.shelajev.Main<br />Hello World!<br />There are 7 instances of class java.lang.Thread<br /></code></pre> If I add a <i>Thread t = new Thread();</i> line to the main method, I see <b>8</b> instances on the heap. Sounds like it actually works. Your thread count will almost certainly be different, don’t worry, it’s normal because it does count JVM bookkeeping threads, that do compilation, GC, etc. <br /><br />Now, if I want to count the number of String instances on the heap, it’s just a matter of changing the argument class. A truly generic solution, Santa would be happy I hope.  <br /><br />Oh, if you’re interested, it finds 2423 instances of String for me. A pretty high number for such as small application. Also,   <pre><code><br />return Thread.getAllStackTraces().size();<br /></code></pre>gives me 5, not 8, because it excludes the bookkeeping threads! Talk about trivial solutions, eh?  <br /><br />Now you’re armed with this knowledge and this tutorial I’m not saying you’re ready to write your own JVM monitoring or enhancing tools, but it is definitely a start. <br /><br />In this post we went from zero to writing a native Java agent, that compiles, loads and runs successfully. It uses the JVMTI to obtain the insight into the JVM that is not accessible otherwise. The corresponding Java code calls the native library and interprets the result.<br />This is often the approach the most miraculous JVM tools take and I hope that some of the magic has been demystified for you.   <br /><br />What do you think, does it clarify agents for you? Let me know! Find me and chat with me on twitter: <a href="https://twitter.com/shelajev">@shelajev</a>.   <br /><br /><br /><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em>