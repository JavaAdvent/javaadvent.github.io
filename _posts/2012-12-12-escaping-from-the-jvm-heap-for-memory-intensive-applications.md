---
id: 77
title: Escaping from the JVM heap for memory intensive applications
date: 2012-12-12T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/escaping-from-the-jvm-heap-for-memory-intensive-applications/
permalink: /2012/12/escaping-from-the-jvm-heap-for-memory-intensive-applications.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Ruben Badaro
blogger_permalink:
  - /2012/12/escaping-jvm-heap-for-memory-intensive.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/7567793493626308916
dsq_thread_id:
  - 4962579199
categories:
  - 2012
  - Buffer
  - garbage collection
  - unsafe
---
<div dir="ltr" style="text-align: left;"> <p>If you've ever allocated large Java heaps, you know that at some point - typically starting at around 4 GiB - you will start having issues with your garbage collection pauses.<br/>I won't go into detail about why pauses happen in the JVM, but in short it happens when the JVM does full collections and you have a large heap. As the heap increases, those collections might become longer.</p> <p>The simplest way to overcome this is to tune your JVM garbage collection parameters to match the memory allocation and deallocation behaviour of your particular application. It is a bit of a dark art and requires careful measurements, but it's possible to have very large heaps while avoiding mostly old generation garbage collections. If you want to learn more about Garbage Collection tuning, check out this <a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">JVM GC tuning guide</a>.<br/>If you get really interested about GC in general, this is an excellent book: <a href="http://www.amazon.com/The-Garbage-Collection-Handbook-Management/dp/1420082795/ref=sr_1_1?ie=UTF8&amp;qid=1355225237&amp;sr=8-1">The Garbage Collection Handbook</a>. </p> <p>There are JVM implementations that guarantee much lower pause times than the Sun VM, such as the <a href="http://www.azulsystems.com/products/zing/virtual-machine">Zing JVM</a> - but normally at other costs in your system, such as increased memory usage and single threaded performance. The ease of configuration and low gc guarantees is still very appealing.</p>  <p>For the purpose of this article, I will use the example of an in-memory cache or store in Java, mainly because I've built a couple in the past while using some of these techniques.</p> <p>We'll assume we have a basic cache interface definition like so:</p> <code><pre><br />import java.io.Externalizable;<br /><br />public interface Cache&lt;K extends Externalizable, V extends Externalizable&gt; {<br />    public void put(K key, V value);<br />    public V get(K key);<br />}<br /></pre></code> <p>We're requiring that keys and values are Externalizable just for this simple example, wouldn't be like this IRL.</p> <p>We will show how to have different implementations of this cache that store data in memory in different ways. The simplest way to implement this cache would be using Java collections:</p> <code><pre><br />import java.io.Externalizable;<br />import java.util.HashMap;<br />import java.util.Map;<br /><br />public class CollectionCache&lt;K extends Externalizable, V extends Externalizable&gt; implements Cache&lt;K, V&gt; {<br />    private final Map&lt;K, V&gt; backingMap = new HashMap&lt;K, V&gt;();<br />    <br />    public void put(K key, V value) {<br />        backingMap.put(key, value);<br />    }<br /><br />    public V get(K key) {<br />        return backingMap.get(key);<br />    }<br />}<br /></pre></code> <p>This implementation is straighforward. However, as the map size increases, we will be allocating a large number of objects (and deallocating), we are using boxed primitives which takes more space in memory that primitives and the map needs to be resized from time to time.<br/>We could certainly improve this implementation simply by using a primitive-based map. It would use less memory and objects but would still take space in the heap and possibly partition the heap, leading to longer pauses if for other reasons we do full GCs.</p> <p>Let's look at other ways to store similar data without using the heap:</p><ul><li><strong>Use a separate process to store the data</strong>. Could be something like a Redis or Memcached instance that you connect through sockets or unix sockets. It's fairly straightforward to implement.</li><li><strong>Offload data to disk, using memory mapped files</strong>. The OS is your friend and will do a lot of heavy work predicting what you'll read next from the file and your interface to it is just like a big blob of data.</li><li><strong>Use native code and access it through JNI or JNA</strong>. You'll get better performance with JNI and ease of use with JNA. Requires you to write native code.</li><li><strong>Use direct allocated buffers</strong> from the NIO package.</li><li><strong>Use the Sun specific Unsafe class</strong> to access memory directly from your Java code.</li></ul> <p>I will focus on the solutions that use exclusively Java for this article, direct allocated buffers and the Unsafe class.</p> <strong>Direct Allocated Buffers</strong> <p>Direct Allocated Buffers are extremely useful and used extensively when developing high-performance network applications in Java NIO. By allocating data directly outside the heap, in a number of cases you can write software where that data actually never touches the heap.</p> <p>Creating a new direct allocated buffer is as simple as it gets:</p> <code><pre><br />int numBytes = 1000;<br />ByteBuffer buffer = ByteBuffer.allocateDirect(numBytes);<br /></pre></code> <p>After creating a new buffer, you can manipulate the buffer in a few different ways. If you've never used Java NIO buffers you should definitely take a look as they are really cool. </p><p>Besides ways to fill, drain and mark different points in the buffer, you can opt to have different view on the buffer instead of a ByteBuffer - e.g. <code>buffer.asLongBuffer()</code> gives you a view on the ByteBuffer where you manipulate elements as longs.</p> <p>So how could these be used in our Cache example? There are a number of ways, the most straightforward way would be to store the serialized/externalized form of the value record in a big array along with a map of keys to offsets and sizes of the record in that array.</p><p>It could look like this (very liberal approach, missing implementations and assuming fixed size records):</p> <code><pre><br />import java.io.Externalizable;<br />import java.nio.ByteBuffer;<br />import java.util.HashMap;<br />import java.util.Map;<br /><br />public class DirectAllocatedCache&lt;K extends Externalizable, V extends Externalizable&gt; implements Cache&lt;K,V&gt; {<br />    private final ByteBuffer backingMap;<br />    private final Map&lt;K, Integer&gt; keyToOffset;<br />    private final int recordSize;<br />    <br />    public DirectAllocatedCache(int recordSize, int maxRecords) {<br />        this.recordSize = recordSize;<br />        this.backingMap = ByteBuffer.allocateDirect(recordSize * maxRecords);<br />        this.keyToOffset = new HashMap&lt;K, Integer&gt;();<br />    }<br /><br />    public void put(K key, V value) {<br />        if(backingMap.position() + recordSize &lt; backingMap.capacity()) {<br />            keyToOffset.put(key, backingMap.position());<br />            store(value);<br />        }   <br />    }<br /><br />    public V get(K key) {<br />        int offset = keyToOffset.get(key);<br />        if(offset &gt;= 0)<br />            return retrieve(offset);<br />            <br />        throw new KeyNotFoundException();<br />    }<br />    <br />    public V retrieve(int offset) {<br />        byte[] record = new byte[recordSize];<br />        int oldPosition = backingMap.position();<br />        backingMap.position(offset);<br />        backingMap.get(record);<br />        backingMap.position(oldPosition);<br />        <br />        //implementation left as an exercise<br />        return internalize(record);<br />    }<br />    <br />    public void store(V value) {<br />        byte[] record = externalize(value);<br />        backingMap.put(record);<br />    }<br />}<br /></pre></code> <p>As you can see, this code has a number of limitations: fixed record size, fixed backing map size, limited way in which externalization is done, difficult to delete and reuse space, etc. While some of these are possible to overcome with clever ways to represent the record in byte arrays (and representing the keyToOffset map in direct allocated buffers also) or dealing with deletions (we could implement our own SLAB allocator) others such as resizing the backing map are difficult to overcome.<br/>An interesting improvement is to implement records as offsets to records and fields, thus reducing the amount of data we copy and do so only on demand.</p> <p>Be aware that the JVM imposes a limit to the amount of memory used by direct allocated buffers. You can tune this with the -XX:MaxDirectMemorySize option. Check out the <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html">ByteBuffer javadocs</a></p>  <strong>Unsafe</strong> <p>Another way to manage memory directly from Java is using the hidden Unsafe class. Technically we're not supposed to use this and it is implementation specific as it lives in a sun package, but the possibilities offered are endless.<br/>What Unsafe gives us is the ability to allocate, deallocate and manage memory directly from Java code. We can also get the actual pointers and pass them between native and java code interchangebly.</p> <p>In order to get an Unsafe instance, we need to cut a few corners:</p> <code><pre><br />private Unsafe getUnsafeBackingMap() {<br />    try {<br />        Field f = Unsafe.class.getDeclaredField("theUnsafe");<br />        f.setAccessible(true);<br />        return (Unsafe) f.get(null);<br />    } catch (Exception e) { }<br />    return null;<br />}<br /></pre></code> <p>Once we have the unsafe, we can apply this to our previous Cache example:</p> <code><pre><br />import java.io.Externalizable;<br />import java.lang.reflect.Field;<br />import java.util.HashMap;<br />import java.util.Map;<br /><br />import sun.misc.Unsafe;<br /><br />public class UnsafeCache&lt;K extends Externalizable, V extends Externalizable&gt; implements Cache&lt;K, V&gt; {<br />    private final int recordSize;<br />    private final Unsafe backingMap;<br />    private final Map&lt;K, Integer&gt; keyToOffset;<br />    private long address;<br />    private int capacity;<br />    private int currentOffset;<br />    <br />    public UnsafeCache(int recordSize, int maxRecords) {<br />        this.recordSize = recordSize;<br />        this.backingMap = getUnsafeBackingMap();<br />        this.capacity = recordSize * maxRecords;<br />        this.address = backingMap.allocateMemory(capacity);<br />        this.keyToOffset = new HashMap&lt;K, Integer&gt;();<br />    }<br />    <br />    public void put(K key, V value) {<br />        if(currentOffset + recordSize &lt; capacity) {<br />            store(currentOffset, value);<br />            keyToOffset.put(key, currentOffset);<br />            currentOffset += recordSize;<br />        }<br />    }<br /><br />    public V get(K key) {<br />        int offset = keyToOffset.get(key);<br />        if(offset &gt;= 0)<br />            return retrieve(offset);<br />            <br />        throw new KeyNotFoundException();<br />    }<br />    <br />    public V retrieve(int offset) {<br />        byte[] record = new byte[recordSize];<br />        <br />        //Inefficient<br />        for(int i=0; i&lt;record.length; i++) {<br />            record[i] = backingMap.getByte(address + offset + i);<br />        }<br />        <br />        //implementation left as an exercise<br />        return internalize(record);<br />    }<br />    <br />    public void store(int offset, V value) {<br />        byte[] record = externalize(value);<br />        <br />        //Inefficient<br />        for(int i=0; i&lt;record.length; i++) {<br />            backingMap.putByte(address + offset + i, record[i]);<br />        }<br />    }<br /><br />    private Unsafe getUnsafeBackingMap() {<br />        try {<br />            Field f = Unsafe.class.getDeclaredField("theUnsafe");<br />            f.setAccessible(true);<br />            return (Unsafe) f.get(null);<br />        } catch (Exception e) { }<br />        return null;<br />    }<br />}<br /></pre></code> <p>There's a lot of space for improvement and you need to do a number of things manually, but it's very powerful. You can also explicitly free and reallocate memory that you've allocated in this way, which allows you to write some code in the same way you would to with C.</p><p>Check out the <a href="http://j7a.ru/classsun_1_1misc_1_1_unsafe.html">javadocs for Unsafe</a></p> <strong>Conclusion</strong> <p>There's a number of ways to avoid using the heap in Java and in this way, use a lot more memory. You don't need to do this and I've personally seen properly tuned JVMs with 20GiB-30GiB running with no long garbage collection pauses, but it is fairly interesting.</p><p>If you want to check out how some projects use this for the basic (and honestly untested, almost written on a napkin) cache code I wrote here, have a look at EHCache's BigMemory or Apache Cassandra which uses Unsafe also for this type of approach.</p><p>&nbsp;</p><p>&nbsp;</p> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a>to contribute!</em></p>  </div>