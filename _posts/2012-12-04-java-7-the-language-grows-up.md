---
id: 85
title: 'Java 7 &#8211; The Language Grows Up'
date: 2012-12-04T09:00:00+00:00
author: Alexander Turner
layout: post
guid: http://www.javaadvent.com/2012/12/java-7-the-language-grows-up/
permalink: /2012/12/java-7-the-language-grows-up.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Alexander Turner
blogger_permalink:
  - /2012/12/java-7-language-grows-up.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/3995741387440460952
categories:
  - 2012
---
<h2>Java was side stepped by C# some years ago - but with the newly invigorated roadmap, Java is back in the game!</h2> <p>Java 6 had a few very (very) annoying features which have been fixed in Java 7. It is easy not to realise how powerful these new yet small aspects of the language are. They point to a bright future where Java grows up slowly into a ever easier language to use.</p> <p>My first insight into the annoying features in Java did not come form writing Java but from creating a COBOL compiler which could compile to the JVM. Some features were asked for by fellow developers which I would not have thought about otherwise:</p> <ol><li>Some way to make variable definitions easier in the face of generics syntax.</li><li>Something like the using syntax in C#.</li><li>Lambdas and delegates (these are coming to Java 8).</li></ol> <p>In this post I am going to take a quick look at 1 and 2. These two features make my every day life much easier as a Java programmer, so I am happy to talk about them!</p> <h3>Diamond Syntax:</h3> <p>Even with excellent tools like Eclipse, writing the following is a pain:</p> <pre><code>ArrayList&lt;string&gt; list = new ArrayList&lt;string&gt;();</code></pre> <p>But it gets worse, how about:</p> <pre><code>ArrayList&lt;ArrayList&lt;string&gt;&gt; list = new ArrayList&lt;ArrayList&lt;string&gt;&gt;();</code></pre> <p>The compiler know that the type on the right is the same as the type on the left; that is how it does the type reconciliation. So, why not allow programmers to let the compiler do a bit of work for them:</p> <pre><code>ArrayList&lt;ArrayList&lt;string&gt;&gt; list = new ArrayList&lt;&gt;();</code></pre> <p>This exactly what the diamond operator does. In simple terms &lt;&gt; means "Take the generic type of the l-value to which the r-value is being assigned.</p> <p>It is easy to say this sort of change does not matter. Using auto-complete on an IDE developers do not need to do all that typing and what does a few characters matter anyhow? The difference comes in readability as much as in the rate of typing. Code with frequent redefinitions of the same type requires more effort to read and is easier to misunderstand. Misunderstandings cause bugs, need I say more?</p> <h3>Try With Resources:</h3> <p>On the subject of bugs, here is a construct which can cause rather a lot of them:</p> <pre><code>static String readFirstLineFromFile(String path) throws IOException {<br />    BufferedReader br = new BufferedReader(new FileReader(path));<br />    try {<br />        return br.readLine();<br />    } finally {<br />        if (br != null) br.close();<br />    }<br />}<br /></code></pre> <p>Three things tend to happen here:</p> <ol><li>Someone forgets to put in the finally clause and the system runs out of file handles.</li><li>Someone forgets to put in the null check and null pointer exceptions get thrown when the FileReader fails.</li><li>The code gets edited for some change and the above two things happen in the new version.</li></ol> <p>This is another case of the Java language being complete and competent but prone to bugs by relying on the developer a little too much. Java 1.7 brings in the new Try-With-Resources syntax. It looks a little odd to start with but it is straight forward and works really well.</p> <pre><code>static String readFirstLineFromFile(String path) throws IOException  {<br />    try (<br />        BufferedReader br = new BufferedReader(new FileReader(path));<br />    ) {<br />        return br.readLine();<br />    }<br />}<br /></code></pre> <p>Now, what ever objects are defined in the () clause after the try will be closed automatically. This is a much better approach in that, just like the the diamond operator, we only need to think about the issue once, in one place. For more information on <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resources</a> see the Oracle Page.</p> <p><strong>By:</strong> Dr Alexander J Turner: I would like to thank Attila for contacting me and organising this interesting project. Feel free to pop over to my blog at <a href="http://nerds-central.blogspot.com/" target="_blank">Nerds-Central</a> at any time :)</p> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</em></p>