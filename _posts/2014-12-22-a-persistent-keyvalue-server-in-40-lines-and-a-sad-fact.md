---
id: 11
title: A persistent KeyValue Server in 40 lines and a sad fact
date: 2014-12-22T08:32:00+00:00
author: gpanther
layout: post
permalink: /2014/12/a-persistent-keyvalue-server-in-40-lines-and-a-sad-fact.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Rudiger Moller
blogger_permalink:
  - /2014/12/a-persistent-keyvalue-server-in-40.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/4059719668015939290
image: /content/uploads/2014/12/user.png
categories:
  - Actors
  - bananas
  - Java Advent
  - java advent 2014
  - messaging
  - other stuff
  - random rage
  - serialization
  - unsafe
---
Advent time again .. picking up Peters <a href="http://www.javaadvent.com/2014/12/how-and-why-is-unsafe-used-in-java/" target="_blank">well written overview</a> on the uses of Unsafe, i'll have a <strike>short</strike> fly-by on how low level techniques in Java can save development effort by enabling a higher level of abstraction&nbsp;<b>or</b> allow for Java performance levels probably unknown to many.<br /><br />My major point is to show that conversion of Objects to bytes and vice versa is an important fundamental, affecting virtually any modern java application.<br /><br />Hardware enjoys to process streams of bytes, not object graphs connected by pointers as&nbsp;<i>"All memory is tape"<b>&nbsp;</b></i><span style="font-size: x-small; font-weight: bold;">(M.Thompson if I remember correctly ..).</span><br /><span style="font-size: x-small; font-weight: bold;"><br /></span>Many basic technologies are therefore hard to use with vanilla Java heap objects:<br /><div><ul><li><b>Memory Mapped Files</b>&nbsp;- a great and simple technology to persist application data safe, fast &amp; easy.</li><li><b>Network communication</b>&nbsp;is based on sending packets of bytes</li><li><b>Interprocess communication</b>&nbsp;(shared memory)</li><li><b>Large main memory</b>&nbsp;of today's servers (64GB to 256GB). (GC issues)</li><li>CPU caches work best on data stored as a continuous stream of bytes in memory</li></ul></div>so use of the Unsafe class in most cases boil down in helping to transform a java object graph into a continuous&nbsp;memory region and vice versa either using<br /><ul><li>[performance enhanced]&nbsp;<b>object serialization</b>&nbsp;or</li><li><b>wrapper classes</b>&nbsp;to ease access to data stored in a continuous memory region.</li></ul>(<b>source</b> of examples used in this post can be found <b><a href="https://github.com/RuedigerMoeller/advcalendar2014" target="_blank">here</a>, </b>messaging<b>&nbsp;</b>latency test <a href="https://github.com/RuedigerMoeller/fast-cast/tree/3.0/examples/src/main/java/org/nustaq/fastcast/examples/latency" target="_blank"><b>here</b></a>)<br /><ul></ul><span style="font-size: x-large;"><br /></span><b><span style="font-size: x-large;">Serialization based Off-Heap</span></b><br /><div><br />Consider a retail WebApplication where there might be millions of registered users. We are actually not interested in representing data in a relational database as all needed is a quick retrieve of user related data once he logs in. Additionally one would like to traverse the social graph quickly.<br /><br />Let's take a simple user class holding some attributes and a list of 'friends' making up a social graph.<br /><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-ko41Bd7TWxE/VI9xMGIs5_I/AAAAAAAAAYE/CW_7XOTepPs/s1600/user.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-ko41Bd7TWxE/VI9xMGIs5_I/AAAAAAAAAYE/CW_7XOTepPs/s1600/user.png" /></a></div><br />easiest way to store this on heap, is a simple huge HashMap.<br /><div style="clear: both; text-align: center;"></div>Alternatively one can use <b>off heap maps</b>&nbsp;to store large amounts of data. An off heap map stores its keys and values inside the native heap, so garbage collection does not need to track this memory. In addition, native heap can be told to automagically get synchronized to disk (memory mapped files). This even works in case your application crashes, as the OS manages write back of changed memory regions.<br /><div><br /></div>There are some open source off heap map implementations out there with various feature sets (e.g. <a href="https://github.com/OpenHFT/Chronicle-Map#complex-types">ChronicleMap</a>), for this example I'll use a plain and simple implementation featuring fast iteration (optional full scan search) and ease of use.<br /><br />Serialization is used to store objects, deserialization is used in order to pull them to the java heap again. Pleasantly I have written the (afaik) <a href="https://github.com/RuedigerMoeller/fast-serialization" target="_blank">fastest fully JDK compliant object serialization</a> on the planet, so I'll make use of that.<br /><br /><div style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-22QrzOq-L9g/VJCceMM_MzI/AAAAAAAAAY0/vFZb_4ItgDY/s1600/omap.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-22QrzOq-L9g/VJCceMM_MzI/AAAAAAAAAY0/vFZb_4ItgDY/s1600/omap.png" /></a></div><br />&nbsp;Done:<br /><div style="clear: both; text-align: center;"></div><ul><li>persistence by memory mapping a file (map will reload upon creation).&nbsp;</li><li>Java Heap still empty to serve real application processing with Full GC &lt; 100ms.&nbsp;</li><li>Significantly less&nbsp;overall&nbsp;memory consumption. A user record serialized is ~60 bytes, so in theory 300 million records fit into 180GB of server memory. No need to raise the big data flag and run 4096 hadoop nodes on AWS ;).</li></ul><div><br />Comparing a regular in-memory java HashMap and a fast-serialization based persistent off heap map holding&nbsp;<b>15 millions</b>&nbsp;user records, will show following results (on a 3Ghz older XEON 2x6):<br /><br /><table border="1" cellpadding="0" cellspacing="0" dir="ltr" style="border-collapse: collapse; border: 1px solid rgb(204, 204, 204); font-family: arial, sans, sans-serif; font-size: 13px; table-layout: fixed;"><colgroup><col width="209"></col><col width="165"></col><col width="79"></col><col width="115"></col><col width="115"></col><col width="112"></col></colgroup><tbody><tr style="height: 21px;"><td style="background-color: #d9d9d9; border-left-color: rgb(0, 0, 0); border-left-style: solid; border-left-width: 1px; border-top-color: rgb(0, 0, 0); border-top-style: solid; border-top-width: 1px; padding: 2px 3px; vertical-align: bottom;"></td><td data-sheets-value="[null,2,&quot;consumed Java Heap (MB)&quot;]" style="background-color: #d9d9d9; border-top-color: rgb(0, 0, 0); border-top-style: solid; border-top-width: 1px; padding: 2px 3px; vertical-align: bottom;">consumed Java Heap (MB)</td><td data-sheets-value="[null,2,&quot;Full GC (s)&quot;]" style="background-color: #d9d9d9; border-top-color: rgb(0, 0, 0); border-top-style: solid; border-top-width: 1px; padding: 2px 3px; vertical-align: bottom;">Full GC (s)</td><td data-sheets-value="[null,2,&quot;Native Heap (MB)&quot;]" style="background-color: #d9d9d9; border-top-color: rgb(0, 0, 0); border-top-style: solid; border-top-width: 1px; padding: 2px 3px; vertical-align: bottom;">Native Heap (MB)</td><td data-sheets-value="[null,2,&quot;get/put ops per s&quot;]" style="background-color: #d9d9d9; border-top-color: rgb(0, 0, 0); border-top-style: solid; border-top-width: 1px; padding: 2px 3px; vertical-align: bottom;">get/put ops per s</td><td data-sheets-value="[null,2,&quot;required VM size&quot;]" style="background-color: #d9d9d9; border-right-color: rgb(0, 0, 0); border-right-style: solid; border-right-width: 1px; border-top-color: rgb(0, 0, 0); border-top-style: solid; border-top-width: 1px; padding: 2px 3px; vertical-align: bottom;">required VM size (MB)</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;HashMap&quot;]" style="background-color: #d9d9d9; border-left-color: rgb(0, 0, 0); border-left-style: solid; border-left-width: 1px; padding: 2px 3px; vertical-align: bottom;">HashMap</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,6865]" style="padding: 2px 3px; text-align: right; vertical-align: bottom;">6.865,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.000&quot;,1]" data-sheets-value="[null,3,null,26.039]" style="padding: 2px 3px; text-align: right; vertical-align: bottom;">26,039</td><td data-sheets-value="[null,3,null,0]" style="padding: 2px 3px; text-align: right; vertical-align: bottom;">0</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,3800000]" style="padding: 2px 3px; text-align: right; vertical-align: bottom;">3.800.000,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,12000]" style="border-right-color: rgb(0, 0, 0); border-right-style: solid; border-right-width: 1px; padding: 2px 3px; text-align: right; vertical-align: bottom;"><div style="text-align: right;">12.000,00</div></td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;OffheapMap (Serialization based)&quot;]" style="background-color: #d9d9d9; border-bottom-color: rgb(0, 0, 0); border-bottom-style: solid; border-bottom-width: 1px; border-left-color: rgb(0, 0, 0); border-left-style: solid; border-left-width: 1px; padding: 2px 3px; vertical-align: bottom;">OffheapMap (Serialization based)</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,63]" style="border-bottom-color: rgb(0, 0, 0); border-bottom-style: solid; border-bottom-width: 1px; padding: 2px 3px; text-align: right; vertical-align: bottom;"><div style="text-align: right;">63,00</div></td><td data-sheets-numberformat="[null,2,&quot;#,##0.000&quot;,1]" data-sheets-value="[null,3,null,0.026]" style="border-bottom-color: rgb(0, 0, 0); border-bottom-style: solid; border-bottom-width: 1px; padding: 2px 3px; text-align: right; vertical-align: bottom;"><div style="text-align: right;">0,026</div></td><td data-sheets-numberformat="[null,2,&quot;#,###&quot;,1]" data-sheets-value="[null,3,null,3050]" style="border-bottom-color: rgb(0, 0, 0); border-bottom-style: solid; border-bottom-width: 1px; padding: 2px 3px; text-align: right; vertical-align: bottom;"><div style="text-align: right;">3.050</div></td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,750000]" style="border-bottom-color: rgb(0, 0, 0); border-bottom-style: solid; border-bottom-width: 1px; padding: 2px 3px; text-align: right; vertical-align: bottom;"><div style="text-align: right;">750.000,00</div></td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,500]" style="border-bottom-color: rgb(0, 0, 0); border-bottom-style: solid; border-bottom-width: 1px; border-right-color: rgb(0, 0, 0); border-right-style: solid; border-right-width: 1px; padding: 2px 3px; text-align: right; vertical-align: bottom;"><div style="text-align: right;">500,00</div></td></tr></tbody></table><br />[<a href="https://github.com/RuedigerMoeller/advcalendar2014/blob/master/src/main/java/keyvalue/OffHeapMapExample.java" target="_blank">test source / blog project</a>] Note: You'll need at least 16GB of RAM to execute them.<br /><br /><div style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-3zdF-3eVk2Q/VJYxMWURZuI/AAAAAAAAAbs/Muh1UrE6q6w/s1600/offheap.jpg" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-3zdF-3eVk2Q/VJYxMWURZuI/AAAAAAAAAbs/Muh1UrE6q6w/s1600/offheap.jpg" height="133" width="200" /></a></div>As one can see, even with fast serialization there is a heavy penalty (~factor 5) in access performance, anyway: compared to other persistence alternatives, its still superior (1-3 microseconds per "get" operation, "put()" very similar).<br /><br />Use of JDK serialization would perform at least 5 to 10 times slower (direct comparison below) and therefore render this approach useless.<br /><br /><br /></div><b><span style="font-size: x-large;">Trading performance gains against higher level of abstraction: "Serverize me"</span></b><br /><span style="font-size: large;"><br /></span><br /><div style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-whWSINSD8aE/VJYueU4yaQI/AAAAAAAAAbc/qsrfl-8SQ-g/s1600/parking-like-a-mini-boss-bike.gif" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-whWSINSD8aE/VJYueU4yaQI/AAAAAAAAAbc/qsrfl-8SQ-g/s1600/parking-like-a-mini-boss-bike.gif" height="112" width="200" /></a></div>A single server won't be able to serve (hundreds of) thousands of users, so we somehow need to share data amongst processes, even better: across machines.<br /><br />Using a fast implementation, its possible to generously use (fast-) serialization for over-the-network messaging. Again: if this would run like 5 to 10 times slower, it just wouldn't be viable. Alternative approaches require an order of magnitude more work to achieve similar results.<br /><br />By wrapping the persistent off heap hash map by an Actor implementation (async ftw!), some lines of code make up a persistent KeyValue server with a TCP-based and a HTTP interface (uses&nbsp;<a href="https://github.com/RuedigerMoeller/kontraktor" target="_blank">kontraktor actors</a>). Of course the Actor can still be used in-process if one decides so later on.<br /><br /><div style="clear: both; text-align: center;"></div><div style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-mDMLeaHyXhM/VJNAtBcwC5I/AAAAAAAAAac/GfXHtq07s8E/s1600/kvs.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-mDMLeaHyXhM/VJNAtBcwC5I/AAAAAAAAAac/GfXHtq07s8E/s1600/kvs.png" height="640" width="604" /></a></div><br />Now that's a micro service. Given it lacks any attempt of optimization and is <b>single threaded</b>, its reasonably fast [same XEON machine as above]:<br /><ul><li>280_000 successful remote lookups per second&nbsp;</li><li>800_000 in case of fail lookups (key not found)</li><li>serialization based TCP interface (1 liner)</li><li>a stringy webservice for the REST-of-us (1 liner).</li></ul>[<a href="https://github.com/RuedigerMoeller/advcalendar2014/tree/master/src/main/java/keyvalue" target="_blank">source: KVServer, KVClient</a>] Note: You'll need at least 16GB of RAM to execute the test.<br /><br />A real world implementation might want to double performance by directly putting received serialized object byte[] into the map instead of encoding it twice (encode/decode once for transmission over wire, then decode/encode for offheaping map).<br /><br />"RestActorServer.Publish(..);" is a one liner to also expose the KVActor as a webservice in addition to raw tcp:<br /><br /><div style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-7NWFVbFKaf0/VJC9gIoAWII/AAAAAAAAAZE/iDJVmcbqhxg/s1600/Screenshot%2Bfrom%2B2014-12-17%2B00%3A19%3A18.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-7NWFVbFKaf0/VJC9gIoAWII/AAAAAAAAAZE/iDJVmcbqhxg/s1600/Screenshot%2Bfrom%2B2014-12-17%2B00%3A19%3A18.png" height="304" width="320" /></a></div><br /><br /><br /><b><span style="font-size: x-large;">C like performance using flyweight wrappers / structs</span></b><br /><b><br /></b>With serialization, regular Java Objects are transformed to a byte sequence. One can do the opposite: Create &nbsp;wrapper classes which read data from fixed or computed positions of an underlying byte array or native memory address. (E.g. see&nbsp;<a href="http://mechanical-sympathy.blogspot.de/2012/10/compact-off-heap-structurestuples-in.html" target="_blank">this blog post</a>).<br /><br />By moving the base pointer its possible to access different records by just moving the the wrapper's offset. Copying such a "packed object" boils down to a memory copy. In addition, its pretty easy to write allocation free code this way. One downside is, that reading/writing single fields has a performance penalty compared to regular Java Objects. This can be made up for by using the Unsafe class.<br /><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-i7mNlwJPIBs/VJYpY4A7HRI/AAAAAAAAAbI/juoGEsrsygA/s1600/structs.gif" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-i7mNlwJPIBs/VJYpY4A7HRI/AAAAAAAAAbI/juoGEsrsygA/s1600/structs.gif" height="200" width="169" /></a></div>"flyweight" wrapper classes can be implemented manually as shown in the blog post cited, however as code grows this starts getting unmaintainable.<br />Fast-serializaton provides a byproduct "struct emulation" supporting creation of flyweight wrapper classes from regular Java classes at runtime. Low level byte fiddling in application code can be avoided for the most part this way.<br /><br /><br /><br /><div style="text-align: center;"><i>How a regular Java class can be mapped to flat memory (fst-structs):</i></div><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-i7mNlwJPIBs/VJYpY4A7HRI/AAAAAAAAAbE/idSm4MQthgE/s1600/structs.gif" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"></a><a href="http://1.bp.blogspot.com/-74SMGg32yEI/VJHE0i-LxBI/AAAAAAAAAZ0/PXKC2D4-PXQ/s1600/Capture.PNG" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-74SMGg32yEI/VJHE0i-LxBI/AAAAAAAAAZ0/PXKC2D4-PXQ/s1600/Capture.PNG" height="208" width="640" /></a></div><br />Of course there are simpler tools out there to help reduce manual programming of encoding &nbsp;(e.g.&nbsp;<a href="https://github.com/RichardWarburton/slab" target="_blank">Slab</a>)&nbsp;which might be more appropriate for many cases and use less "magic".<br /><br /><b>What kind of performance can be expected using the different approaches (sad fact incoming) ?</b><br /><br />Lets take the following struct-class consisting of a price update and an embedded struct denoting a tradable instrument (e.g. stock) and encode it using various methods:<br /><br /><div style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-GGPqggr-B40/VJDN3DK0fUI/AAAAAAAAAZU/qHO8eZZLhEc/s1600/struct.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-GGPqggr-B40/VJDN3DK0fUI/AAAAAAAAAZU/qHO8eZZLhEc/s1600/struct.png" height="640" width="532" /></a></div><div style="clear: both; text-align: center;"><i>a 'struct' in code</i></div><div style="clear: both; text-align: center;"><br /></div><div style="clear: both; text-align: left;"><b>Pure encoding performance:</b></div><div style="clear: both; text-align: left;"><br /></div><table border="1" cellpadding="0" cellspacing="0" dir="ltr" style="border-collapse: collapse; border: 1px solid #ccc; font-family: arial,sans,sans-serif; font-size: 13px; table-layout: fixed;"><colgroup><col width="100"></col><col width="155"></col><col width="97"></col><col width="130"></col><col width="86"></col></colgroup><tbody><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;Structs&quot;]" style="background-color: #d9d9d9; border-left: 1px solid #000000; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">Structs</td><td data-sheets-value="[null,2,&quot;fast-Ser (no shared refs)&quot;]" style="background-color: #d9d9d9; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">fast-Ser (no shared refs)</td><td data-sheets-value="[null,2,&quot;fast-Ser&quot;]" style="background-color: #d9d9d9; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">fast-Ser</td><td data-sheets-value="[null,2,&quot;JDK Ser (no shared)&quot;]" style="background-color: #d9d9d9; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">JDK Ser (no shared)</td><td data-sheets-value="[null,2,&quot;JDK Ser&quot;]" style="background-color: #d9d9d9; border-right: 1px solid #000000; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">JDK Ser</td></tr><tr style="height: 21px;"><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,26315000]" style="border-bottom: 1px solid #000000; border-left: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">26.315.000,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,7757000]" style="border-bottom: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">7.757.000,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,5102000]" style="border-bottom: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">5.102.000,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,649000]" style="border-bottom: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">649.000,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,644000]" style="border-bottom: 1px solid #000000; border-right: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">644.000,00</td></tr></tbody></table><b><br /></b><br /><div style="clear: both; text-align: center;"></div><div style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-wWlqMg6sDkU/VJVbDBWfW7I/AAAAAAAAAas/oegUyK3sNyg/s1600/adv1.PNG" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-wWlqMg6sDkU/VJVbDBWfW7I/AAAAAAAAAas/oegUyK3sNyg/s1600/adv1.PNG" /></a></div><b><br /></b><b><br /></b><b>Real world test with messaging throughput:</b><br /><br />In order to get a basic estimation of differences in a real application, i do an experiment how different encodings perform when used to send and receive messages at a high rate via <a href="https://github.com/RuedigerMoeller/fast-cast" target="_blank">reliable UDP messaging</a>:<br /><br /><i>The Test:</i><br /><i>A sender encodes messages as fast as possible and publishes them using reliable multicast, a subscriber receives and decodes them.</i><br /><br /><table border="1" cellpadding="0" cellspacing="0" dir="ltr" style="border-collapse: collapse; border: 1px solid #ccc; font-family: arial,sans,sans-serif; font-size: 13px; table-layout: fixed;"><colgroup><col width="100"></col><col width="155"></col><col width="97"></col><col width="130"></col><col width="86"></col></colgroup><tbody><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;Structs&quot;]" style="background-color: #d9d9d9; border-left: 1px solid #000000; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">Structs</td><td data-sheets-value="[null,2,&quot;fast-Ser (no shared refs)&quot;]" style="background-color: #d9d9d9; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">fast-Ser (no shared refs)</td><td data-sheets-value="[null,2,&quot;fast-Ser&quot;]" style="background-color: #d9d9d9; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">fast-Ser</td><td data-sheets-value="[null,2,&quot;JDK Ser (no shared)&quot;]" style="background-color: #d9d9d9; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">JDK Ser (no shared)</td><td data-sheets-value="[null,2,&quot;JDK Ser&quot;]" style="background-color: #d9d9d9; border-right: 1px solid #000000; border-top: 1px solid #000000; padding: 2px 3px 2px 3px; vertical-align: bottom;">JDK Ser</td></tr><tr style="height: 21px;"><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,6644107]" style="border-bottom: 1px solid #000000; border-left: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">6.644.107,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,4385118]" style="border-bottom: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">4.385.118,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,3615584]" style="border-bottom: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">3.615.584,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,81582]" style="border-bottom: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">81.582,00</td><td data-sheets-numberformat="[null,2,&quot;#,##0.00&quot;,1]" data-sheets-value="[null,3,null,79073]" style="border-bottom: 1px solid #000000; border-right: 1px solid #000000; padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">79.073,00</td></tr></tbody></table><br /><div style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-FVtCrYYJ8b8/VJVcCF6jOfI/AAAAAAAAAa0/1-gV5PdS-Sg/s1600/adv2.PNG" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-FVtCrYYJ8b8/VJVcCF6jOfI/AAAAAAAAAa0/1-gV5PdS-Sg/s1600/adv2.PNG" /></a></div>(Tests done on I7/Win8, XEON/Linux scores slightly higher, msg size ~70 bytes for structs, ~60 bytes serialization).<br /><br /><div style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-UyPdeiSj68k/VJYrPMuxchI/AAAAAAAAAbQ/o_2dyoW0GHU/s1600/omg.gif" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-UyPdeiSj68k/VJYrPMuxchI/AAAAAAAAAbQ/o_2dyoW0GHU/s1600/omg.gif" height="120" width="200" /></a></div>Slowest compared to fastest: factor of 82. The test highlights an issue not covered by micro-benchmarking: Encoding and Decoding should perform similar, as factual throughput is determined by Min(Encoding performance, Decoding performance). For unknown reasons JDK serialization manages to encode the message tested like 500_000 times per second, decoding performance is only 80_000 per second so in the test the receiver gets dropped quickly:<br /><span style="font-family: Courier New, Courier, monospace;"><br /></span><span style="font-family: Courier New, Courier, monospace;">"</span><br /><span style="font-family: Courier New, Courier, monospace;">...</span><br /><span style="font-family: Courier New, Courier, monospace;">***** Stats for receive rate: &nbsp; 80351 &nbsp; per second *********</span><br /><span style="font-family: Courier New, Courier, monospace;">***** Stats for receive rate: &nbsp; 78769 &nbsp; per second *********</span><br /><span style="font-family: Courier New, Courier, monospace;">SUB-ud4q has been dropped by PUB-9afs on service 1</span><br /><span style="font-family: Courier New, Courier, monospace;">fatal, could not keep up. exiting</span><br /><span style="font-family: Courier New, Courier, monospace;">"</span><br />(Creating backpressure here probably isn't the right way to address the issue ;-) &nbsp;)<br /><br /><b>Conclusion</b>:<br /><ul><li>a fast serialization allows for a level of abstraction in distributed applications impossible if serialization implementation is either<br />- too slow<br />- incomplete. E.g. cannot handle any serializable object graph<br />- requires manual coding/adaptions. (would put many restrictions on actor message types, Futures, Spore's, Maintenance nightmare)</li><li>Low Level utilities like Unsafe enable different representations of data resulting in extraordinary throughput or guaranteed latency boundaries (allocation free main path) for particular workloads. These are impossible to achieve by a large margin with JDK's public tool set.</li><li>In distributed systems, communication performance is of fundamental importance. Removing Unsafe is &nbsp;not the biggest fish to fry looking at the numbers above .. JSON or XML won't fix this ;-).</li><li>While the HotSpot VM has reached an extraordinary level of performance and reliability, CPU is wasted in some parts of the JDK like there's no tomorrow. Given we are living in the age of distributed applications and data, moving stuff over the wire should be easy to achieve (not manually coded) and as fast as possible.&nbsp;</li></ul><div><br /></div><div><b>Addendum: bounded latency</b></div><div><br /></div>A quick <a href="https://github.com/RuedigerMoeller/fast-cast/tree/3.0/examples/src/main/java/org/nustaq/fastcast/examples/latency" target="_blank">Ping Pong RTT latency benchmark</a> showing that java can compete with C solutions easily, as long the main path is allocation free and techniques like described above are employed:<br /><br /><div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-NGkVC-b1VZs/VJMd-KHuwFI/AAAAAAAAAaE/Ee6qf1dY9w8/s1600/lat1.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-NGkVC-b1VZs/VJMd-KHuwFI/AAAAAAAAAaE/Ee6qf1dY9w8/s1600/lat1.png" height="233" width="640" /></a></div><br /><div style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/--O29mfUvsaQ/VJMd-XihA-I/AAAAAAAAAaI/AuFPYFujNV0/s1600/lat2.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/--O29mfUvsaQ/VJMd-XihA-I/AAAAAAAAAaI/AuFPYFujNV0/s1600/lat2.png" height="243" width="640" /></a></div><br /><i>[credits: charts+measurement done with HdrHistogram]</i><br /><br />This is an "experiment" rather than a benchmark (so do not read: '<i>Proven: Java faster than C'</i>), it shows low-level-Java can compete with C in at least this low-level domain.<br />Of course its not exactly <i>idiomatic </i>Java code, however its still easier to handle, port and maintain compared to a JNI or pure C(++) solution. Low latency C(++) code won't be that idiomatic either ;-)<br /><br /><b>About me:</b> I am a solution architect freelancing at an exchange company in the area of realtime GUIs, middleware, and low latency CEP (Complex Event Processing).<br />I am blogging at&nbsp;<a href="http://java-is-the-new-c.blogspot.de/">http://java-is-the-new-c.blogspot.de/</a>,<br />hacking at&nbsp;<a href="https://github.com/RuedigerMoeller">https://github.com/RuedigerMoeller</a>.<br /><br /><em style="background-color: #fcffee; color: #222222; font-family: Verdana, Geneva, sans-serif; font-size: 18px; line-height: 24.6399993896484px;">This post is part of the&nbsp;<a href="http://javaadvent.com/" style="color: #888888; text-decoration: none;">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/" style="color: #888888; text-decoration: none;">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em><br /><br /></div>