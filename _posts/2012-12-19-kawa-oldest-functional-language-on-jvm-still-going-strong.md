---
id: 70
title: 'Kawa &#8211; oldest functional language on JVM still going strong'
date: 2012-12-19T16:11:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/kawa-oldest-functional-language-on-jvm-still-going-strong/
permalink: /2012/12/kawa-oldest-functional-language-on-jvm-still-going-strong.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Attila-Mihaly Balazs
blogger_permalink:
  - /2012/12/kawa-oldest-functional-language-on-jvm.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/3652344050551197082
categories:
  - 2012
  - kawa
---
<h2>by <a href="http://per.bothner.com/">Per Bothner</a></h2> <p>So-called <q>scripting languages</q> are now very visible, but they have a long history, even on the Java platform. Of languages still in use and active development today, <a href="http://www.gnu.org/software/kawa/" target="_blank">Kawa</a> and <a href="http://www.netrexx.org/" target="_blank">Netrexx</a> are (to my knowledge) the oldest, both created in 1996. (Java was publicly launched in 1995.) Kawa appears to have been the first scripting language to be compiled directly to Java bytescodes, and is the oldest still-active functional language on the JVM. Kawa was based on a simple Scheme interpreter written by Alex Milowski, but I re-wrote it as a compiler while I worked for Cygnus Solutions, probably the first company to commercialize Free Software. Kawa is now GNU software, available under an MIT license.</p> <p>Kawa is still used for a number of projects. As an example <a href="http://appinventor.mit.edu/" target="_blank">MIT App Inventor</a>(previously Google App Inventor) for Android is built on top of Kawa.</p> <h3>Scripting vs programming languages</h3><p>Kawa tries to combine the advantages of scripting languages with those of Java-like <q>programming languages</q>.</p> <p>Like other scripting languages, Kawa avoids boilerplate such as having to define a class and <code>main</code> method. Since Kawa is an expression language, the minimal <q>Hello, world</q>program is just:</p> <pre><code>&quot;Hello, world!&quot;</code></pre> <p>Macros allow syntactic extension, and can be defined in libraries just like functions. It is trivial to implement a <q>domain-specific language</q>on top of Scheme, at least as long as you use the core <a href="http://www.gnu.org/software/kawa/Datum-syntax.html" target="_blank">S-expression <q>datum</q> syntax</a>. Kawa has convenient syntactic short-hands like <a href="http://www.gnu.org/software/kawa/Colon-notation.html" target="_blank">colon notation</a>.</p> <p>Kawa is quite dynamic: It has <code>eval</code>, and a read-eval-print-loop. If you type in an expression or load a file to be evaluated, it is automatically(and quickly) compiled down to bytecode.</p> <p>You don&#39;t need to specify the types of variables - but you can: Doing so helps document your program, may allow the compiler to generate faster code, and may allow the compiler to catch errors and inconsistencies.</p> <p>Kawa also has the advantages a more conventional <q>programming</q> language, like Java or Scala. You can compile to a <code>class</code> file, which can be an application (with an automatically-generated <code>main</code>), an applet, a servlet, or other specified class. It has an optimizing compiler which does decent data-flow analysis and type interface.  This combined with optional type declarations make it straightforward to write code that is as efficient as Java or Scala - and <a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/" target="_blank">many times faster than languages like JRuby or Clojure</a>. The compiler is good at detecting and reporting errors, which avoids many painful debugging sessions. Kawa&#39;s primary visibility boundary is a sourcefile modules, which is natural and easy for both human readers and compilers.</p> <p><em>In the rest of this article I will touch on some cool features of Kawa; maybe one of them will inspire you to try it out.</em></p> <h3>Object construction</h3> <p>Kawa has a convenient terse syntax for object construction.  For example, this creates a Swing <code>JButton</code> that calls <code>do-it</code>when pressed:</p> <pre><code>(javax.swing.JButton<br />  text: &quot;Do it!&quot;<br />  action-listener:<br />   (lambda (e) (do-it)))<br /></code></pre> <p>Groovy has a <a href="http://groovy.codehaus.org/Swing+Builder" target="_blank">SwingBuilder</a> that allows similar compact object construction.  However, Kawa&#39;s is built in: It works for any <q>bean</q>-like class with standard <code>set</code> or <code>add</code> methods. Kawa is also more efficient, since it doesn&#39;t create a helper object.  Instead the compiler translates the constructor call to code like what you&#39;d write by hand in Java.</p> <h3>Android</h3><p>Of course sometimes just using the <q>beans</q> naming convention isn&#39;t quite enough to yield a pleasant constructor API.  For example, in the Android API you construct a tree of <code>View</code> objects. Each <code>View</code> constructor requires a parameter which is the current <code>Activity</code>, which looks like this:</p><pre><code>(TextView (this) text: &quot;Hello world!&quot;)</code></pre> <p>The reference <code>(this)</code> to the current <code>Activity</code>is tedious boiler-plate.  That is why Kawa defines some special handling so you can leave out the <code>(this)</code>:</p> <pre><code>(TextView text: &quot;Hello world!&quot;)</code></pre> <p>This special handling for <code>View</code> classes is not hard-wired but is defined in an Android-specific library.</p> <p>Read how to <a href="http://www.gnu.org/software/kawa/Building-for-Android.html" target="_blank">build and run Android applications</a>and <a href="http://www.gnu.org/software/kawa/Android-view-construction.html" target="_blank">more about Android <code>View</code> expressions</a>.</p> <h3>JavaFX</h3> <p>Kawa also has some special handling to ease <a href="http://www.oracle.com/technetwork/java/javafx/overview/index.html" target="_blank">JavaFX</a> programming. <a href="http://www.gnu.org/software/kawa/Building-JavaFX-applications.html" target="_blank">This page</a> has a simple example and up-to-date instructions. Also check out two slightly older blog articles: <a href="http://per.bothner.com/blog/2011/JavaFX-using-Kawa-intro/" target="_blank">an introduction</a>, and <a href="http://localhost/per/blog/2011/JavaFX-using-Kawa-animation/" target="_blank">about animation</a>.</p> <h3>Self-configuring web server</h3> <p>It is easy to write web services using Kawa. No setup or additional software is needed if using the server built in to JDK (version 6 or later).  Just start Kawa like this:</p> <pre><code>kawa --http-auto-handler / appdir --http-start 8888</code></pre> <p>Here is a <a href="http://www.gnu.org/software/kawa/Server-side-scripts.html" target="_blank">web page script</a>that replies back with the name of the requesting (client) host:</p> <pre><code>;; Hello world page script written in -*- scheme -*-<br />#&lt;p&gt;Hello, &lt;b&gt;&amp;(request-remote-host)&lt;/b&gt;!<wbr>&lt;/p&gt;</code></pre>  <p>The script uses an <a href="http://www.gnu.org/software/kawa/XML-literals.html" target="_blank">XML literal</a> with an embedded expression. Put this file in <code>appdir/path</code>, and point your browser to <code>http://localhost:8888/path</code>. Kawa will find the file, recognize the string <q><code>-*- scheme -*-</code></q>in the first line and realize it is a Scheme script, then compile (if necessary) and evaluate it, and return the result to the browser.</p> <p>You can use the same page scripts on a <a href="http://en.wikipedia.org/wiki/Web_container" target="_blank">servet container</a> such as Tomcat or Glassfish, instead of using JDK&#39;s builtin server.</p> <h3>Lazy evaluation</h3> <p>A <q>pure functional language</q> uses <a href="http://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank">lazy evaluation</a> - i.e. an expression is only evaluated when the value is needed. <q>Impure</q> functional languages like Scheme use strict evaluation, familiar from Java and most commonly-used languages. Kawa has a <a href="http://www.gnu.org/software/kawa/Lazy-evaluation.html" target="_blank">hybrid functionality</a>:  The expression <code>(delay E)</code> evaluates to a <q>promise</q><code>P</code> that will evaluate the expression <code>E</code> <em>when requested</em>. You can call <code>(force P)</code> to <em>explicitly force</em> the resulting promise: It returns the result of evaluating <code>E</code>. The expression <code>E</code> is only evaluated once, and the result remembered in case <code>P</code> is forced later.</p> <p>The forms <code>delay</code> and <code>delay</code> are standard. Kawa also supports <em>implicit forcing</em>, as you&#39;d find in a pure functional language:  If the promise is used in a context that requires a real non-promise value, such as <code>(* P 2)</code>the <code>P</code> then the result is as you wrote: <code>(* (force P) 2)</code>.  It makes it more convenient to use lazy values.</p> <p>Kawa also has <dfn>futures</dfn>; these are also automatically forced when needed.</p> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</em></p>