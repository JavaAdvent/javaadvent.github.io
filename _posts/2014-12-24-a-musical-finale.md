---
id: 9
title: A Musical Finale
date: 2014-12-24T08:30:00+00:00
author: Alexander Turner
layout: post
permalink: /2014/12/a-musical-finale.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Alexander Turner
blogger_permalink:
  - /2014/12/a-musical-finale.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/373003818198838120
image: /content/uploads/2014/12/sing-spectrum-825x468.jpg
categories:
  - 2014
  - hybrid programming
  - java
  - Java Advent
  - java advent 2014
  - jython
  - mathematics
  - music
  - python
---
<div dir="ltr" style="text-align: left;"><h2 style="text-align: left;">What could be more fitting than Christmas music for Christmas Eve?</h2><div><div><div style="text-align: left;">In this post I want to discuss the joy of making music with Java and why/how I have come to use Python...<br /><br /></div><h3>But first, let us celebrate the season!</h3>We are all human and irrespective of our beliefs, it seems we all enjoy music of some form. For me some of the most beautiful music of all was written by Johan Sebastian Bach. Between 1708 and 1717 he wrote a set of pieces which are collectively called Orgelb√ºchlein (Little Organ Book). For this post and to celebrate the Java Advent Calendar I tasked Sonic Field to play this piece of music modelling the sounds of a 18th century pipe organ. If you did not know, yes some German organs of about that time really were able to produce huge sounds with reed pipes (for example, <a href="http://youtu.be/F51uHpH3yQk" target="_blank">Passacaglia And Fugue</a> the <a href="http://www.organartmedia.com/trost" target="_blank">Trost Organ</a>). The piece here is a 'Choral Prelude' which is based on what we would in English commonly call a Carol to be sung by an ensemble.<br /><br /><div style="clear: both; text-align: center;"></div><div style="clear: both; text-align: center;"><object class codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://i.ytimg.com/vi/Xdm0_eKyaT0/0.jpg" height="266" width="320"><param name="movie" value="https://www.youtube.com/v/Xdm0_eKyaT0?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" /><param name="bgcolor" value="#FFFFFF" /><param name="allowFullScreen" value="true" /><embed width="320" height="266"  src="https://www.youtube.com/v/Xdm0_eKyaT0?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"></embed></object></div><br /><div style="text-align: center;">BWV 610 Jesu, meine Freude [Jesus, my joy]<br /><i>This performance dedicated to the Java Advent Calendar</i><br /><i>and created exclusively on the JVM using pure</i><br /><i>mathematics.</i></div></div><div><br /><b>How was this piece created?</b><br />Step one is to transcribe the score into midi. Fortunately, someone else already did this for me using automated score reading software. Not so fortunately, this software makes all sorts of mistakes which have to be fixed. The biggest issue with automatically generated midi files is that they end up with <a href="http://manual.ardour.org/editing-and-arranging/edit-midi/handle-overlapping-notes/" target="_blank">overlapped notes on the same channel</a>; that is strictly impossible in midi and ends up with an ambiguous interpretation of what the sound should be. Midi considers audio as note on, note off. So Note On, Note On, Note Off, Note Off is ambiguous; does it mean:<br /><br />One note overlapping the next or:<br /><span style="font-family: Courier New, Courier, monospace;">-----------------</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;---------------</span><br /><br />One note entirely contained in a longer note?<br /><span style="font-family: Courier New, Courier, monospace;">----------------------------</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;----</span><br /><span style="font-family: Courier New, Courier, monospace;"><br /></span>Fortunately, tricks can be used to try and figure this out based on note length etc. The Java decoder always treats notes as fully contained. The Python method looks for very short notes which are contained in long ones and guesses the real intention was two long notes which ended up overlapped slightly. Here is the python (the Java is here on <a href="https://github.com/nerds-central/SonicFieldRepo/blob/master/SonicField/src/com/nerdscentral/audio/io/MidiFunctions.java" target="_blank">github</a>).<br /><pre><code><br />def repareOverlapMidi(midi,blip=5):<br />    print "Interpretation Pass"<br />    mute=True<br />    while mute:<br />        endAt=len(midi)-1<br />        mute=False<br />        index=0<br />        midiOut=[]<br />        this=[]<br />        next=[]<br />        print "Demerge pass:",endAt<br />        midi=sorted(midi, key=lambda tup: tup[0])<br />        midi=sorted(midi, key=lambda tup: tup[3])<br />        while index&lt;endAt:<br />            this=midi[index]<br />            next=midi[index+1]<br />            ttickOn,ttickOff,tnote,tkey,tvelocity=this<br />            ntickOn,ntickOff,nnote,nkey,nvelocity=next<br />    <br />            # Merge interpretation<br />            finished=False<br />            dif=(ttickOff-ttickOn)<br />            if dif&lt;blip and tkey==nkey and ttickOff&gt;=ntickOn and ttickOff&lt;=ntickOff:<br />                print "Separating: ",this,next," Diff: ",(ttickOff-ntickOn)<br />                midiOut.append([ttickOn ,ntickOn ,tnote,tkey,tvelocity])<br />                midiOut.append([ttickOff,ntickOff,nnote,nkey,nvelocity])<br />                index+=1<br />                mute=True     <br />            elif  dif&lt;blip:<br />                print "Removing blip: ",(ttickOff-ttickOn)<br />                index+=1<br />                mute=True     <br />                continue<br />            else:<br />                midiOut.append(this)       <br />            # iterate the loop<br />            index+=1<br />        if index==endAt:<br />            midiOut.append(next)<br />        if not mute:<br />            return midiOut<br />        midi=midiOut<br /></code></pre>[<a href="https://github.com/nerds-central/SonicFieldRepo/blob/master/SonicField/scripts/python/Bach-Large-Organ/note-formation.sy" target="_blank">This AGPL code is on Github</a>]<br /><br />Then comes some real fun. If you know the original piece, you might have noticed that the introduction is not original. I added that in the midi editing software <a href="http://ariamaestosa.sourceforge.net/" target="_blank">Aria Maestosa</a>. It does not need to be done this way; we do not even need to use midi files. A lot of the music I have created in Sonic Field is just coded directly in Python. However, from midi is how it was done here.<br /><br />Once we have a clean set of notes they need to be converted into sounds. That is done with 'voicing'. I will talk a little about that to set the scene then we can get back into more Java code oriented discussion. After all, this is the Java advent calendar!<br /><br />Voicing is exactly the sort of activity which brings Python to the fore. Java is a wordy language which has a large degree of strictness. It favours well constructed, stable structures. Python relies on its clean syntax rules and layout and the <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment" target="_blank">principle of least astonishment.</a> For me, this Pythonic approach really helps with the very human process of making a sound:<br /><br /><pre><code><br />def chA():<br />    global midi,index<br />    print "##### Channel A #####"<br />    index+=1<br />    midi=shorterThanMidi(midis[index],beat,512)<br />    midi=dampVelocity(midi,80,0.75)<br />    doMidi(voice=leadDiapason,vCorrect=1.0)<br />    postProcess()<br />    <br />    midi=longAsMidi(midis[index],beat,512)<br />    midi=legatoMidi(midi,beat,128)<br />    midi=dampVelocity(midi,68,0.75)<br />    midi=dampVelocity(midi,80,0.75)<br />    doMidi(voice=orchestralOboe,vCorrect=0.35,flatEnv=True,pan=0.2)<br />    postProcessTremolate(rate=3.5)<br />    doMidi(voice=orchestralOboe,vCorrect=0.35,flatEnv=True,pan=0.8)<br />    postProcessTremolate(rate=4.5)<br /></code></pre><br />Above is a 'voice'. Contrary to what one might think, a synthesised sound does not often consist of just one sound source. It consists of many. A piece of music might have many 'voices' and each voice will be a composite of several sounds. To create just the one voice above I have split the notes into long notes and short notes. Then the actual notes are created by a call to doMidi. This takes advantage of Python's 'named arguments with default values' feature. Here is the signature for doMidi:<br /><pre><code><br />def doMidi(voice,vCorrect,pitchShift=1.0,qFactor=1.0,subBass=False,flatEnv=False,pure=False,pan=-1,rawBass=False,pitchAdd=0.0,decay=False,bend=True):<br /></code></pre><br /><table cellpadding="0" cellspacing="0" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-EAAntOrHBnw/VJb3guSNz_I/AAAAAAAAqWA/sG7LfMZrbYc/s1600/sing-spectrum.tiff" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-EAAntOrHBnw/VJb3guSNz_I/AAAAAAAAqWA/sG7LfMZrbYc/s1600/sing-spectrum.tiff" height="146" width="320" /></a></td></tr><tr><td style="text-align: center;"><i>The most complex (unsurprisingly) voice to create is that</i><br /><i>of a human singing. I have been working on this for</i><br /><i>a long time and there is a long way to go; however, its</i><br /><i>is a spectrogram of a piece of music which does</i><br /><i>a passable job of sounding like someone singing.</i></td></tr></tbody></table>The first argument is actually a reference to a function which will create the basic tone. The rest of the arguments describe how that tone will be manipulated in the note formation. Whilst an approach like this can be mimicked using a builder pattern in Java; this latter language does not lend it self to the 'playing around' nature of Python (at least for me).<br /><br />For example, I could just run the script and add flatEvn=True to the arguments and run it again and compare the two sounds. It is an intuitive way of working.<br /><br />Anyhow, once each voice has been composited from many tones and tweaked into the shape and texture we want, they turn up as a huge list of lists of notes which are all mixed together and written out to disk as a flat file format which is basically just a dump of the underlying double data. At this point it sounds terrible! Making the notes is often only half the story.<br /><br /><div style="clear: both; text-align: center;"><object width="320" height="266" class codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://i.ytimg.com/vi/LGYcCJXKtgw/0.jpg"><param name="movie" value="https://www.youtube.com/v/LGYcCJXKtgw?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" /><param name="bgcolor" value="#FFFFFF" /><param name="allowFullScreen" value="true" /><embed width="320" height="266"  src="https://www.youtube.com/v/LGYcCJXKtgw?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"></embed></object></div><div style="clear: both; text-align: center;"><i><span style="font-size: x-small;">Voice Synthesis by Sonic Field</span></i></div><div style="clear: both; text-align: center;"><i><span style="font-size: x-small;">played specifically for this post.</span></i></div><br />You see, real sounds happen in a space. Our Choral is expected to be performed in a church. Notes played without a space around them sound completely artificial and lack any interest. To solve this we use impulse response reverberation. The mathematics behind this is rather complex and so I will not go into it in detail. However in the next section I will start to look at this as a perfect example of why Java is not only necessary but ideal as the back end to Python/Jython.<br /><br /><h3>You seem to like Python Alex - Why Bother With Java?</h3><div>My post might seem a bit like a Python sales job so far. What has been happening is simply a justification of using Python when Java is so good as a language (especially when written in a great IDE like Eclipse for Java). Let us look at something Python would be very bad indeed at. Here is the code for performing the <a href="http://en.wikipedia.org/wiki/Fast_Fourier_transform" target="_blank">Fast Fourier Transform</a>, which is a the heart of putting sounds into a space.</div><div><br /><pre><code><br />package com.nerdscentral.audio.pitch.algorithm;<br /><br />public class CacheableFFT<br />{<br /><br />    private final int      n, m;<br /><br />    // Lookup tables. Only need to recompute when size of FFT changes.<br />    private final double[] cos;<br />    private final double[] sin;<br />    private final boolean  forward;<br /><br />    public boolean isForward()<br />    {<br />        return forward;<br />    }<br /><br />    public int size()<br />    {<br />        return n;<br />    }<br /><br />    public CacheableFFT(int n1, boolean isForward)<br />    {<br />        this.forward = isForward;<br />        this.n = n1;<br />        this.m = (int) (Math.log(n1) / Math.log(2));<br /><br />        // Make sure n is a power of 2<br />        if (n1 != (1 &lt;&lt; m)) throw new RuntimeException(Messages.getString("CacheableFFT.0")); //$NON-NLS-1$<br /><br />        cos = new double[n1 / 2];<br />        sin = new double[n1 / 2];<br />        double dir = isForward ? -2 * Math.PI : 2 * Math.PI;<br /><br />        for (int i = 0; i &lt; n1 / 2; i++)<br />        {<br />            cos[i] = Math.cos(dir * i / n1);<br />            sin[i] = Math.sin(dir * i / n1);<br />        }<br /><br />    }<br /><br />    public void fft(double[] x, double[] y)<br />    {<br />        int i, j, k, n1, n2, a;<br />        double c, s, t1, t2;<br /><br />        // Bit-reverse<br />        j = 0;<br />        n2 = n / 2;<br />        for (i = 1; i &lt; n - 1; i++)<br />        {<br />            n1 = n2;<br />            while (j &gt;= n1)<br />            {<br />                j = j - n1;<br />                n1 = n1 / 2;<br />            }<br />            j = j + n1;<br /><br />            if (i &lt; j)<br />            {<br />                t1 = x[i];<br />                x[i] = x[j];<br />                x[j] = t1;<br />                t1 = y[i];<br />                y[i] = y[j];<br />                y[j] = t1;<br />            }<br />        }<br /><br />        // FFT<br />        n1 = 0;<br />        n2 = 1;<br /><br />        for (i = 0; i &lt; m; i++)<br />        {<br />            n1 = n2;<br />            n2 = n2 + n2;<br />            a = 0;<br /><br />            for (j = 0; j &lt; n1; j++)<br />            {<br />                c = cos[a];<br />                s = sin[a];<br />                a += 1 &lt;&lt; (m - i - 1);<br /><br />                for (k = j; k &lt; n; k = k + n2)<br />                {<br />                    t1 = c * x[k + n1] - s * y[k + n1];<br />                    t2 = s * x[k + n1] + c * y[k + n1];<br />                    x[k + n1] = x[k] - t1;<br />                    y[k + n1] = y[k] - t2;<br />                    x[k] = x[k] + t1;<br />                    y[k] = y[k] + t2;<br />                }<br />            }<br />        }<br />    }<br />}<br /></code></pre>[<a href="https://github.com/nerds-central/SonicFieldRepo/blob/master/SonicField/src/com/nerdscentral/audio/pitch/algorithm/CacheableFFT.java" target="_blank">This AGPL code is on Github</a>]<br /><br />It would be complete lunacy to implement this methematics in JPython (<a href="http://en.wikipedia.org/wiki/Late_binding#Late_binding_in_dynamically-typed_languages" target="_blank">dynamic late binding</a>&nbsp;would give unusably bad performance). Java does a great job of running it quickly and efficiently. In Java this runs just about as fast as it could in any language plus the clean, simple object structure of Java means that using the 'caching' system as straight forward. The caching comes from the fact that the cos and sin multipliers of the FFT can be re-used when the transform is the same length. Now, in the creation of <a href="http://en.wikipedia.org/wiki/Reverberation" target="_blank">reverberation effects</a> (those effects which put sound into a space) FFT lengths are the same over and over again due to <a href="http://www.ni.com/white-paper/4844/en/" target="_blank">windowing</a>. So the speed and object oriented power of Java have both fed into creating a clean, high performance implementation.<br /><br />But we can go further and make the FFT parallelised:<br /><pre><code><br />def reverbInner(signal,convol,grainLength):<br />    def rii():<br />        mag=sf.Magnitude(+signal)<br />        if mag&gt;0:<br />            signal_=sf.Concatenate(signal,sf.Silence(grainLength))<br />            signal_=sf.FrequencyDomain(signal_)<br />            signal_=sf.CrossMultiply(convol,signal_)<br />            signal_=sf.TimeDomain(signal_)<br />            newMag=sf.Magnitude(+signal_)<br />            if newMag&gt;0:<br />                signal_=sf.NumericVolume(signal_,mag/newMag)        <br />                # tail out clicks due to amplitude at end of signal <br />                return sf.Realise(signal_)<br />            else:<br />                return sf.Silence(sf.Length(signal_))<br />        else:<br />            -convol<br />            return signal<br />    return sf_do(rii)<br />            <br />def reverberate(signal,convol):<br />    def revi():<br />        grainLength = sf.Length(+convol)<br />        convol_=sf.FrequencyDomain(sf.Concatenate(convol,sf.Silence(grainLength)))<br />        signal_=sf.Concatenate(signal,sf.Silence(grainLength))<br />        out=[]<br />        for grain in sf.Granulate(signal_,grainLength):<br />            (signal_i,at)=grain<br />            out.append((reverbInner(signal_i,+convol_,grainLength),at))<br />        -convol_<br />        return sf.Clean(sf.FixSize(sf.MixAt(out)))<br />    return sf_do(revi)<br /><br /></code></pre>Here we have the Python which performs the FFT to produce <a href="http://en.wikipedia.org/wiki/Convolution_reverb" target="_blank">impulse response reverberation</a>&nbsp;(c<i>onvolution reverb</i> is another name for this approach). The second function breaks the sound into grains. Each grain is then processes individually and they all have the same length. This performs that windowing effect I talked about earlier (I use a <a href="http://en.wikipedia.org/wiki/Window_function#Triangular_window" target="_blank">triangular window</a> which is not ideal but works well enough due to the long window size). If the grains are long enough, the impact of lots of little FFT calculation basically the same as the effect of one huge one. However, FFT is a nLog(n) process, so lots of little calculations is a lot faster than one big one. In effect, windowing make FFT become a linear scaling calculation.<br /><br />Note that the granulation process is performed in a future. We define a closure called <i>revi</i> and pass it to <i>sf_do()</i> which is executed it at some point in the future base on demand and the number of threads available. &nbsp;Next we can look at the code which performs the FFT on each grain - <i>rii</i>. That again is performed in a future. In other words, the individual windowed FFT calculations are all performed in futures. The expression of a parallel windowed FFT engine in C or FORTRAN ends up very complex and rather intractable. I have not personally come across one which is integrated into the generalised, thread pooled, future based schedular. Nevertheless, the combination of Jython and Java makes such a thing very easy to create.<br /><br /><h3 style="text-align: left;">How are the two meshed?</h3>Now that I hope I have put a good argument for hybrid programming between a great dynamic language (in this case Python) and a powerful mid level static language (in this case Java) it is time to look at how the two are fused together. There are many ways of doing this but Sonic Field picks a very distinct approach. It does not offer a general interface between the two where lots of intermediate code is generated and each method in Java is exposed separately into Python; rather it uses a uniform single interface with virtual dispatch.<br /><br />Sonic Field defines a very (aggressively) simple calling convention from Python into Java which initially might look like a major pain in the behind but works out to create a very flexible and powerful approach.<br /><br />Sonic Field defines 'operators' which all implement the following interface:<br /><pre><code><br />/* For Copyright and License see LICENSE.txt and COPYING.txt in the root directory */<br />package com.nerdscentral.sython;<br /><br />import java.io.Serializable;<br /><br />/**<br /> * @author AlexTu<br /> * <br /> */<br />public interface SFPL_Operator extends Serializable<br />{<br /><br />    /**<br />     * &lt;b&gt;Gives the key word which the parser will use for this operator&lt;/b&gt;<br />     * <br />     * @return the key word<br />     */<br />    public String Word();<br /><br />    /**<br />     * &lt;b&gt;Operate&lt;/b&gt; What ever this operator does when SFPL is running is done by this method. The execution loop all this<br />     * method with the current execution context and the passed forward operand.<br />     * <br />     * @param input<br />     *            the operand passed into this operator<br />     * @param context<br />     *            the current execution context<br />     * @return the operand passed forward from this operator<br />     * @throws SFPL_RuntimeException<br />     */<br />    public Object Interpret(Object input, SFPL_Context context) throws SFPL_RuntimeException;<br />}<br /></code></pre><div style="font-weight: normal;"><span style="font-size: small;">[</span><a href="https://github.com/nerds-central/SonicFieldRepo/blob/master/SonicField/src/com/nerdscentral/sython/SFPL_Operator.java" target="_blank"><span style="font-size: small;">This AGPL code is on Github</span></a><span style="font-size: small;">]</span></div><div><br /></div><div><span style="font-size: small;"><span style="font-weight: normal;">The word() method returns the name of the operator as it will be expressed in Python. The Interpret() method processes arguments passed to it from Python. As Sonic Field comes up it creates a Jython interpreter and then adds the operators to it.&nbsp;</span><span style="font-weight: normal;">The mechanism for doing this is a little involved so rather than go into detail here, I will simply give links to the code on github:</span></span></div><div></div><ul><li><a href="https://github.com/nerds-central/SonicFieldRepo/blob/master/SonicField/src/com/nerdscentral/sython/Sython.java" rel="nofollow" style="font-weight: normal;"><span style="font-size: small;">SonicField.java</span></a></li><li><span style="font-size: small; font-weight: normal;"><a href="https://github.com/nerds-central/SonicFieldRepo/blob/master/SonicField/src/com/nerdscentral/sython/Sython.java" style="font-weight: normal;" target="_blank">SonicField.py</a></span></li></ul><div><div style="text-align: left;"><span style="font-size: small; font-weight: normal;">The result is that every operator is exposed in Python as sf.xxx where xxx is the return from the word() method. With clever operator overloading and other syntactical tricks in Python I am sure that the approach could be refined. Right now, there are a lot of sf.xxx calls in Sonic Field Python ( I call it Synthon ) but I have not gotten around to improving on this simple and effective approach.</span><br /><span style="font-size: small; font-weight: normal;"><br /></span></div></div><div>You might have noticed that everything passed into Java from Python is just 'object'. This seems a bit crude at first take. However, as we touched on in the section of futures in the <a href="http://www.javaadvent.com/2014/12/a-serpentine-path-to-music/" target="_blank">previous post</a>, it offers many advantages because the translation from Jython to Java is orchestrated via the Caster object and a layer of Python which transparently perform many useful translations. For example, the code automatically translates multiple arguments in Jython to a list of objects in Java:<br /><pre><code><br />    def run(self,word,input,args):<br />        if len(args)!=0:<br />            args=list(args)<br />            args.insert(0,input)<br />            input=args<br />        trace=''.join(traceback.format_stack())<br />        SFSignal.setPythonStack(trace)<br />        ret=self.processors.get(word).Interpret(input,self.context)<br />        return ret<br /></code></pre><br /></div>Here we can see how the arguments are processed into a list &nbsp;(which is Jython is implemented as an ArrayList) if there are more than one but are passed as a single object is there is only one. We can also see how the Python stack trace is passed into a thread local in &nbsp;the Java SFSignal object. Should an SFSignal not be freed or be double collected, this Python stack is displayed to help debug the program.<br /><br /><h4 style="text-align: left;">Is this interface approach a generally good idea for Jython/Java Communication?</h4>Definitely not! It works here because of the nature of the Sonic Field audio progressing architecture. We have processors which can be chained. Each processor has a simple input and output. The semantic content passed between Python and Java is quite limited. In more general purpose programming, this simple architecture, rather than being flexible and powerful, would be highly restrictive. In this case, the normal Jython interface with Java would be much more effective. Again, we can see a great example of this simplicity in the previous post when talking about threading (where Python access Java Future objects). Another example is the direct interaction of Python with SFData objects in this post on <a href="http://sonic-field.blogspot.co.uk/2014/03/python-creating-oscillators-in-python.html" target="_blank">modelling oscillators in Python</a>.<br /><pre><code><br />from com.nerdscentral.audio import SFData<br />...<br />            data=SFData.build(len)<br />            for x in range(0,length):<br />                s,t,xs=osc.next()<br />                data.setSample(x,s)<br /></code></pre><br />Which violated the programming model of Sonic Field by creating audio samples directly from Jython, but at the same time illustrates the power of Jython! It also created one of the most unusual soundscapes I have so far achieved with the technology:<br /><br /><div style="clear: both; text-align: center;"><object class codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0" data-thumbnail-src="https://i.ytimg.com/vi/nV5T2n6RAa0/0.jpg" height="266" width="320"><param name="movie" value="https://www.youtube.com/v/nV5T2n6RAa0?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" /><param name="bgcolor" value="#FFFFFF" /><param name="allowFullScreen" value="true" /><embed width="320" height="266"  src="https://www.youtube.com/v/nV5T2n6RAa0?version=3&f=user_uploads&c=google-webdrive-0&app=youtube_gdata" type="application/x-shockwave-flash" allowfullscreen="true"></embed></object></div><div style="text-align: center;"><span style="font-size: x-small;"><i>Engines of war, sound modelling</i></span></div><div style="text-align: center;"><span style="font-size: x-small;"><i>from oscillators in Python.</i></span></div><h3 style="text-align: left;">Wrapping It Up</h3>Well, that is all folks. I could ramble on for ever, but I think I have answered most if not all of the questions I set out in the first post. The key ones that really interest me are about creativity and hybrid programming. Naturally, I am obsessed with performance as I am by profession an optimisation consultant, but moving away from my day job, can Jython and Java be a creating environment and do they offer more creativity than pure Java?<br /><br /><table cellpadding="0" cellspacing="0" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-_OASFw1c9Ak/VJajaqMzERI/AAAAAAAAqU0/n6Es1yyaNwA/s1600/F3.large.jpg" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-_OASFw1c9Ak/VJajaqMzERI/AAAAAAAAqU0/n6Es1yyaNwA/s1600/F3.large.jpg" height="296" width="320" /></a></td></tr><tr><td style="text-align: center;">Transition State Analysis using<br />hybrid programming</td></tr></tbody></table>Too many years ago I worked on a similar hybrid approach in scientific computing. The <a href="http://people.bath.ac.uk/chsihw/grace/grace.html" target="_blank">GRACE</a> software which I helped develop as part of the team at <a href="http://www.bath.ac.uk/" target="_blank">Bath</a> was able to break new ground because it was easier to explore ideas in the hybrid approach than writing raw FORTRAN constantly. I cannot present in deterministic, reductionist language a consistent argument for why this applied then to science or now to music; nevertheless, experience from myself and others has show this to be a strong argument.<br /><br /><i><b>Whether you agree or disagree; irrespective of if you like the music or detest it; I wish you a very merry Christmas indeed.</b></i></div><div></div></div></div></div><br/><br/><em style="background-color: #fcffee; color: #222222; font-family: Verdana, Geneva, sans-serif; font-size: 18px; line-height: 24.6399993896484px;">This post is part of the&nbsp;<a href="http://javaadvent.com/" style="color: #888888; text-decoration: none;">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/" style="color: #888888; text-decoration: none;">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em>