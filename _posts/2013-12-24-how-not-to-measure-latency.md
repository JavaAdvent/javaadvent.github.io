---
id: 35
title: How (NOT TO) measure latency
date: 2013-12-24T10:42:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/how-not-to-measure-latency/
permalink: /2013/12/how-not-to-measure-latency.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Attila-Mihaly Balazs
blogger_permalink:
  - /2013/12/how-not-to-measure-latency.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/3200439759561899550
geo_latitude:
  - 46.777248
geo_longitude:
  - 23.5998899
geo_public:
  - 1
geo_address:
  - Cluj-Napoca, Romania
categories:
  - 2013
  - latency
  - load testing
  - performance testing
  - statistics
---
<p>Latency is <a href="http://en.wikipedia.org/wiki/Latency_(engineering)">defined</a> as <blockquote>time interval between the stimulation and response</blockquote> and is a value which is of importance in many computer systems (financial systems, games, websites, etc). Hence we - as computer engineers - want to specify some upper bounds / worst case scenarios for the systems we build. How can we do this? The days of counting cycles for assembly instructions are long gone (unless you work on embedded systems) - there are just too many additional factors to consider (the operating system - mainly the task scheduler, other running processes, the JIT, the GC, etc). The remaining alternative is doing empirical (hands on) testing.</p> <h3>Use percentiles</h3> <p>So we whip out <a href="http://jmeter.apache.org/">JMeter</a>, configure a load test, take the mean (average) value åœŸ 3 x standard deviation and proudly declare that <a href="http://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule">99.73% of the users</a> will experience latency which is in this interval. We are especially proud because (a) we considered a realistic set of calls (URLs if we are testing a website) and (b) we allowed for JIT warmup.</p> <p>But we are still very wrong! (which can be sad if our company writes <a href="http://en.wikipedia.org/wiki/Service-level_agreement">SLAs</a> based on our numbers - we can bankrupt the company single-handedly!)</p> <p>Lets see where the problem is and how we can fix it before we cause damage. Consider the dataset depicted below (you can get the actual values <a href="https://gist.github.com/cdman/7846275">here</a> to do your own calculations).</p> <div style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-5hABJiyXP4c/UqNjCHUjFHI/AAAAAAAAGAM/qSoJIf5wmWg/s1600/latencies.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-5hABJiyXP4c/UqNjCHUjFHI/AAAAAAAAGAM/qSoJIf5wmWg/s400/latencies.png" /></a></div> <p>For simplicity there are exactly 100 values used in this example. Lets say that they represent the latency of fetching a particular URL. You can immediately tell that the values can be grouped in three distinct categories: very small (perhaps the data was already in the cache?), medium (this is what most users will see) and poor (probably there are some corner-cases). This is typical for medium-to-large complexity (ie. "real life") composed of many moving parts and is called a multimodal distributions. More on this shortly.</p> <p>If we quickly drop these values into LibreOffice Calc and do the number crunching, we'll come to the conclusion that the average (mean) of the values is 40 and according to the six sigma rule 99.73% of the users should experience latencies less than 137. If you look at the chart carefully you'll see that the average (marked with red) is slightly left of the middle. You can also do a simple calculation (because there are exactly 100 values represented) and see that the maximum value in the 99th percentile is 148 not 137. Now this might not seem like a big difference, but it can be the difference between profit and bankrupcy (if you've written a SLA based on this value for example).</p> <p>Where did we go wrong? Let's look again carefully at the three sigma rule (emphasis added): <blockquote>nearly all values lie within three standard deviations of the mean <em>in a normal distribution</em>.</blockquote> Our problem is that we don't have a normal distribution. We probably have a multimodal distribution (as mentioned earlier), but to be safe we should use ways of interpreting the results which are independent of the nature of the distribution.</p> <p>From this example we can derive a couple of recommendations:</p> <ol start="0"><li>Make sure that your test framework / load generator / benchmark isn't the bottleneck - run it against a "null endpoint" (one which doesn't do anything) and ensure that you can get an order of magnitude better numbers</li><li>Take into account things like JITing (warmup periods) and GC if you're testing a JVM based system (or other systems which are based on the same principles - .NET, luajit, etc).</li><li>Use <a href="http://en.wikipedia.org/wiki/Percentile">percentiles</a>. Saying things like "the median (50th percentile) response time of our system is...", "the 99.99th percentile latency is...", "the maximum (100th percentile) latency is..." is ok</li><li>Don't calculate the average (mean). Don't use standard deviation. In fact if you see that value in a test report you can assume that the people who put together the report (a) don't know what they're talking about or (b) are intentionally trying to mislead you (I would bet on the first, but that's just my optimism speaking).</li></ol>  <h3>Look out for coordinated omission</h3> <p>Coordinate omission (a phrase coined by Gil Tene of Azul fame) is a problem which can occur if the test loop looks something like:</p> <code><pre><br />start:<br />  t = time()<br />  do_request()<br />  record_time(time() - t)<br />  wait_until_next_second()<br />  jump start<br /></pre></code> <p>That is, we're trying to do one request every second (perhaps every 100ms would be more realistic, but the point stands). Many test systems (including JMeter and YCSB) have inner loops like this.</p> <p>We run the test and (learning from the previous discussion) report: the 85% of the request will be served under 0.5 seconds if there are 1 requests per second. And we still can be wrong! Let us look at the diagram below to see why:</p> <div style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/--WjzaLTSnDs/UqOA1YVhdUI/AAAAAAAAGAg/-OVyTpdLrKA/s1600/coordinated_omission.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/--WjzaLTSnDs/UqOA1YVhdUI/AAAAAAAAGAg/-OVyTpdLrKA/s400/coordinated_omission.png" /></a></div> <p>On the first line we have our test run (horizontal axis being time). Lets say that between second 3 and 6 the system (and hence all requests to it) are blocked (maybe we have a long GC pause). If you calculate the 85th percentile, you'll 0.5 (hence the claim in the previous paragraph). However, you can see 10 independent clients below, each doing the request in a different second (so we have our criteria of one request per second fulfilled). But if we crunch the numbers, we'll see that the actual 85th percentile in this case is 1.5 (three times worse than the original calculation).</p> <p>Where did we go wrong? The problem is that the test loop and the system under test worked together ("coordinated" - hence the name) to hide (omit) the additional requests which happen during the time the server is blocked. This leads to underestimating the delays (as shown in the example).</p> <ol start="4"><li>Make sure every request less than the sampling interval <em>or</em> use a better benchmarking tool (I don't know of any which correct for this) <em>or</em> post-process the data with Gil's HdrHistogram library which contains <a href="https://github.com/giltene/HdrHistogram/blob/9ce067a134fa33269d3eda37c4667fb5538252b8/src/main/java/org/HdrHistogram/AbstractHistogram.java#L312">built-in facilities</a> to account for coordinated omission</li></ol> <p><em>This post is part of the&nbsp;<a href="http://javaadvent.com/">Java Advent Calendar</a>&nbsp;and is licensed under the&nbsp;<a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a>&nbsp;license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></p>