---
id: 89
title: (Re)Start me up!
date: 2012-12-01T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/restart-me-up/
permalink: /2012/12/restart-me-up.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Attila-Mihaly Balazs
blogger_permalink:
  - /2012/12/restart-me-up.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/1978632060229134289
categories:
  - 2012
  - command line
  - java
---
<p>There are cases where you would like to start a Java process identical to the current one (or at least using the the same JVM with tweaked parameters). Some concrete cases where this would be useful:</p> <ul><li>Auto-tuning the maximum memory parameters (ie. you have an algorithm to determine the optimal value - for example: 80% of the system memory - and your JVM wasn't started with that particular value)</li><li>Creating a cluster of processes for high(er)-availability (true HA implies multiple physical nodes) or because processes have different roles (like the components in MongoDB).</li><li>Daemonizing the current process (that is, the background process should run even after the launching process has terminated) - this is a very frequent modus-operandi for programs on *nix systems where you have the foreground "control" process and the background "daemon" process (not to be confused with the "daemon" threads).</li></ul> <p>Doing this is relatively simple - and can be done in pure Java - after you find the correct API calls:</p> <code><pre><br />List&lt;String&gt; arguments = new ArrayList&lt;&gt;();<br />// the java executable<br />arguments<br />  .add(String.format("%s%sbin%sjava",<br />    System.getProperty("java.home"), File.separator,<br />    File.separator));<br />// pre-execuable arguments (like -D, -agent, etc)<br />arguments.addAll(ManagementFactory.getRuntimeMXBean()<br />  .getInputArguments());<br /><br />String classPath = System.getProperty("java.class.path"), javaExecutable = System<br />  .getProperty("sun.java.command");<br />if (classPath.equals(javaExecutable)) {<br /> // was started with -jar<br /> arguments.add("-jar");<br /> arguments.add(javaExecutable);<br />} else {<br /> arguments.add("-classpath");<br /> arguments.add(classPath);<br /> arguments.add(javaExecutable);<br />}<br /><br />// we might add additional arguments here which will be received by the<br />// launched program<br />// in its args[] paramater<br />arguments.add("runme");<br /><br />// launch it!<br />new ProcessBuilder().command(arguments).start();<br /></pre></code> <p>Some explanations about to the code:</p> <ul><li>It is largely inspired from <a href="https://github.com/brianm/gressil">this project</a></li><li>We suppose that the java executable is named <code>java</code> and is located in <code>bin/java</code> relative to <code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#getProperties%28%29">java.home</a></code>. We use <code>File.separator</code> for the code to be portable.</li><li><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/management/RuntimeMXBean.html#getInputArguments%28%29">getInputArguments</a> is used to get specific arguments passed to the JVM (like <code>-Xmx</code>). It does <strong>not</strong> include the classpath.</li><li>Which is taken from <code>java.class.path</code></li><li>Finally, there is one heuristic step: we try to detect if we were launched using the <code>-jar myjar.jar</code> syntax or the <code>MyMainClass</code> syntax and replicate it.</li></ul> <p>This is it! After that we use <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html">ProcessBuilder</a> (which we should always favour over Runtime.exec because it auto-escapes the parts of the command line for us).</p> <p>A final thought: if you intend to use this method to "daemonize" a process (that is: to ensure that it stays running after its parent process has terminated) you should do two things:</p> <ul><li>Redirect the standard input and output. By default they are redirected into temporary buffers and the JVM will seemingly randomly terminate when those buffers (pipes) fill up.</li><li>Under Windows use <code>javaw</code> instead of <code>java</code>. This ensures that the process won't be tied to the console it was started from (however it will still be tied to the user login session and will terminate when the user logs out - for a more heavy-duty solution look into the <a href="http://wrapper.tanukisoftware.com/doc/english/download.jsp">Java Service Wrapper</a>).</li></ul> <p>This is it for today, hope you enjoyed it, fond it useful. If you run the code and it doesn't work as advertised, let me know so that I can update it (I'm especially interested if it works with non Sun/Oracle JVMs). Come back tomorrow for an other article!</p> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</em></p>