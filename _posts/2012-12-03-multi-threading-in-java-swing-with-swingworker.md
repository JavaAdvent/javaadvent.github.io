---
id: 86
title: Multi-threading in Java Swing with SwingWorker
date: 2012-12-03T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/multi-threading-in-java-swing-with-swingworker/
permalink: /2012/12/multi-threading-in-java-swing-with-swingworker.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - John W. Purcell
blogger_permalink:
  - /2012/12/multi-threading-in-java-swing-with.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/8122469422755678225
geo_latitude:
  - 52.90890204777
geo_longitude:
  - -1.40625
geo_public:
  - 1
geo_address:
  - '39 Anglers&#39; Ln, Derby DE21, UK'
dsq_thread_id:
  - 4962577903
categories:
  - 2012
  - java
---
<p>If you're writing a desktop or Java Web Start program in Java using Swing, you might feel the need to run some stuff in the background by creating your own threads.</p> <p>There's nothing stopping you from using standard multi-threading techniques in Swing, and the usual considerations apply. If you have multiple threads accessing the same variables, you'll need to use synchronized methods or code blocks (or thread-safe classes like AtomicInteger or ArrayBlockingQueue).</p> <p>However, there is a pitfall for the unwary. As with most user interface APIs, you can't update the user interface from threads you've created yourself. Well, as every Java undergraduate knows, you often <i>can</i>, but you shouldn't. If you do this, sometimes your program will work and other times it won't.</p> <p>You can get around this problem by using the specialised SwingWorker class. In this article, I'll show you how you can get your programs working even if you're using the Thread class, and then we'll go on to look at the SwingWorker solution.</p> <p>For demonstration purposes, I've created a little Swing program.</p>  <div style="clear: both; text-align: center;"><img border="0" height="320" src="http://4.bp.blogspot.com/-F6Ny5ZyjI8A/ULmzkS6QWdI/AAAAAAAAAiY/h_uEoEQkrYk/s320/swingworker1.png" width="160" /></div> <p>As you can see, it consists of two labels and a start button. At the moment, clicking the start button invokes a handler method which does nothing. Here's the Java code:</p> <code><pre>import java.awt.Font;<br />import java.awt.GridBagConstraints;<br />import java.awt.GridBagLayout;<br />import java.awt.event.ActionEvent;<br />import java.awt.event.ActionListener;<br />import java.util.List;<br />import java.util.concurrent.ExecutionException;<br /><br />import javax.swing.JButton;<br />import javax.swing.JFrame;<br />import javax.swing.JLabel;<br />import javax.swing.SwingUtilities;<br />import javax.swing.SwingWorker;<br /><br />public class MainFrame extends JFrame {<br /><br /> private JLabel countLabel1 = new JLabel("0");<br /> private JLabel statusLabel = new JLabel("Task not completed.");<br /> private JButton startButton = new JButton("Start");<br /><br /> public MainFrame(String title) {<br />  super(title);<br /><br />  setLayout(new GridBagLayout());<br />  <br />  countLabel1.setFont(new Font("serif", Font.BOLD, 28));<br /><br />  GridBagConstraints gc = new GridBagConstraints();<br /><br />  gc.fill = GridBagConstraints.NONE;<br /><br />  gc.gridx = 0;<br />  gc.gridy = 0;<br />  gc.weightx = 1;<br />  gc.weighty = 1;<br />  add(countLabel1, gc);<br /><br />  gc.gridx = 0;<br />  gc.gridy = 1;<br />  gc.weightx = 1;<br />  gc.weighty = 1;<br />  add(statusLabel, gc);<br /><br />  gc.gridx = 0;<br />  gc.gridy = 2;<br />  gc.weightx = 1;<br />  gc.weighty = 1;<br />  add(startButton, gc);<br /><br />  startButton.addActionListener(new ActionListener() {<br />   public void actionPerformed(ActionEvent arg0) {<br />    start();<br />   }<br />  });<br /><br />  setSize(200, 400);<br />  setDefaultCloseOperation(EXIT_ON_CLOSE);<br />  setVisible(true);<br /> }<br /><br /> private void start() {<br />  <br />  <br /> }<br /> <br /> public static void main(String[] args) {<br />  SwingUtilities.invokeLater(new Runnable() {<br />   <br />   @Override<br />   public void run() {<br />    new MainFrame("SwingWorker Demo");<br />   }<br />  });<br /> }<br />}<br /></pre></code> <p>We're going to add some code into the start() method which is called in response to the start button being clicked.</p> <p>First let's try a normal thread.</p> <code><pre> private void start() {<br />  Thread worker = new Thread() {<br />   public void run() {<br />    <br />    // Simulate doing something useful.<br />    for(int i=0; i&lt;=10; i++) {<br />     // Bad practice<br />     countLabel1.setText(Integer.toString(i));<br />     <br />     try {<br />      Thread.sleep(1000);<br />     } catch (InterruptedException e) {<br />      <br />     }<br />    }<br />    <br />    // Bad practice<br />    statusLabel.setText("Completed.");<br />   }<br />  };<br />  <br />  worker.start();<br /> }<br /></pre></code> <p>As a matter of fact, this code seems to work (at least for me anyway). The program ends up looking like this:</p> <div style="clear: both; text-align: center;"><img border="0" height="320" src="http://2.bp.blogspot.com/-J-96Rnf6awc/ULm5ZskXrEI/AAAAAAAAAio/_rpcPz4FjVc/s320/swingworker1.png" width="160" /></div> <p>This isn't recommended practice, however. We're updating the GUI from our own thread, and under some circumstances that will certainly cause exceptions to be thrown.</p> <p>If we want to update the GUI from another thread, we should use SwingUtilities to schedule our update code to run on the event dispatch thread.</p> <p>The following code is fine, but ugly as the devil himself.</p> <code><pre>private void start() {<br />  Thread worker = new Thread() {<br />   public void run() {<br />    <br />    // Simulate doing something useful.<br />    for(int i=0; i&lt;=10; i++) {<br />     <br />     final int count = i;<br />     <br />     SwingUtilities.invokeLater(new Runnable() {<br />      public void run() {<br />       countLabel1.setText(Integer.toString(count));<br />      }<br />     });<br />     <br />     try {<br />      Thread.sleep(1000);<br />     } catch (InterruptedException e) {<br />      <br />     }<br />    }<br />    <br />    SwingUtilities.invokeLater(new Runnable() {<br />     public void run() {<br />      statusLabel.setText("Completed.");<br />     }<br />    });<br />    <br />   }<br />  };<br />  <br />  worker.start();<br /> }<br /></pre></code> <p>Surely there must be something we can do to make our code more elegant?</p> <h3>The SwingWorker Class</h3> <p><tt>SwingWorker</tt> is an alternative to using the <tt>Thread class</tt>, specifically designed for Swing. It's an abstract class and it takes two template parameters, which make it look highly ferocious and puts most people off using it. But in fact it's not as complex as it seems.</p> <p>Let's take a look at some code that just runs a background thread. For this first example, we won't be using either of the template parameters, so we'll set them both to <tt>Void</tt>, Java's class equivalent of the primitive <tt>void</tt> type (with a lower-case 'v').</p> <h3>Running a Background Task</h3> <p>We can run a task in the background by implementing the <tt>doInBackground</tt> method and calling <tt>execute</tt> to run our code.</p> <code><pre>SwingWorker&lt;Void, Void&gt; worker = new SwingWorker&lt;Void, Void&gt;() {<br />   @Override<br />   protected Void doInBackground() throws Exception {<br />    // Simulate doing something useful.<br />    for (int i = 0; i &lt;= 10; i++) {<br />     Thread.sleep(1000);<br />     System.out.println("Running " + i);<br />    }<br /><br />    return null;<br />   }<br />  };<br />  <br />  worker.execute();</pre></code> <p>Note that <tt>SwingWorker</tt> is a one-shot affair, so if we want to run the code again, we'd need to create another <tt>SwingWorker</tt>; you can't restart the same one.</p> <p>Pretty simple, hey? But what if we want to update the GUI with some kind of status after running our code? You cannot update the GUI from <tt>doInBackground</tt>, because it's not running in the main event dispatch thread.</p> <p>But there is a solution. We need to make use of the first template parameter.</p> <h3>Updating the GUI After the Thread Completes</h3> <p>We can update the GUI by returning a value from <tt>doInBackground()</tt> and then over-riding <tt>done()</tt>, which can safely update the GUI. We use the <tt>get()</tt> method to retrieve the value returned from <tt>doInBackground()</tt></p> <p>So the first template parameter determines the return type of both <tt>doInBackground()</tt> and <tt>get()</tt>.</p> <code><pre>SwingWorker&lt;Boolean, Void&gt; worker = new SwingWorker&lt;Boolean, Void&gt;() {<br />   @Override<br />   protected Boolean doInBackground() throws Exception {<br />    // Simulate doing something useful.<br />    for (int i = 0; i &lt;= 10; i++) {<br />     Thread.sleep(1000);<br />     System.out.println("Running " + i);<br />    }<br /><br />    // Here we can return some object of whatever type<br />    // we specified for the first template parameter.<br />    // (in this case we're auto-boxing 'true').<br />    return true;<br />   }<br /><br />   // Can safely update the GUI from this method.<br />   protected void done() {<br />    <br />    boolean status;<br />    try {<br />     // Retrieve the return value of doInBackground.<br />     status = get();<br />     statusLabel.setText("Completed with status: " + status);<br />    } catch (InterruptedException e) {<br />     // This is thrown if the thread's interrupted.<br />    } catch (ExecutionException e) {<br />     // This is thrown if we throw an exception<br />     // from doInBackground.<br />    }<br />   }<br />   <br />   <br />  };<br />  <br />  worker.execute();</pre></code> <br /><div style="clear: both; text-align: center;"><img border="0" height="320" src="http://4.bp.blogspot.com/-EDmxc0XqFJ8/ULm_vUZW_LI/AAAAAAAAAi4/gxuzMUSs-GQ/s320/swingworker3.png" width="160" /></div> <p>What if we want to update the GUI as we're going along? That's what the second template parameter is for.</p> <h3>Updating the GUI from a Running Thread</h3> <p>To update the GUI from a running thread, we use the second template parameter. We call the <tt>publish()</tt> method to 'publish' the values with which we want to update the user interface (which can be of whatever type the second template parameter specifies). Then we override the <tt>process()</tt> method, which receives the values that we publish.</p> <p>Actually&nbsp;<tt>process()</tt>&nbsp;receives lists of published values, because several values may get published before <tt>process()</tt> is actually called.</p> <p>In this example we just publish the latest value to the user interface.</p> <code><pre>  SwingWorker&lt;Boolean, Integer&gt; worker = new SwingWorker&lt;Boolean, Integer&gt;() {<br />   @Override<br />   protected Boolean doInBackground() throws Exception {<br />    // Simulate doing something useful.<br />    for (int i = 0; i &lt;= 10; i++) {<br />     Thread.sleep(1000);<br />     <br />     // The type we pass to publish() is determined<br />     // by the second template parameter.<br />     publish(i);<br />    }<br /><br />    // Here we can return some object of whatever type<br />    // we specified for the first template parameter.<br />    // (in this case we're auto-boxing 'true').<br />    return true;<br />   }<br /><br />   // Can safely update the GUI from this method.<br />   protected void done() {<br />    <br />    boolean status;<br />    try {<br />     // Retrieve the return value of doInBackground.<br />     status = get();<br />     statusLabel.setText("Completed with status: " + status);<br />    } catch (InterruptedException e) {<br />     // This is thrown if the thread's interrupted.<br />    } catch (ExecutionException e) {<br />     // This is thrown if we throw an exception<br />     // from doInBackground.<br />    }<br />   }<br /><br />   @Override<br />   // Can safely update the GUI from this method.<br />   protected void process(List&lt;Integer&gt; chunks) {<br />    // Here we receive the values that we publish().<br />    // They may come grouped in chunks.<br />    int mostRecentValue = chunks.get(chunks.size()-1);<br />    <br />    countLabel1.setText(Integer.toString(mostRecentValue));<br />   }<br />   <br />   <br />  };<br />  <br />  worker.execute();</pre></code> <div style="clear: both; text-align: center;"><img border="0" height="320" src="http://2.bp.blogspot.com/-Ca-qgd1PnB8/ULnCRuqeR9I/AAAAAAAAAjI/mBptkzhcjyM/s320/swingworker4.png" width="160" /></div> <h3>More .... ? You Want More .... ?</h3> <p>I hope you enjoyed this introduction to the highly-useful SwingWorker class.</p> <p>You can find more tutorials, including a complete free video course on multi-threading and courses on Swing, Android and Servlets, on my site <a href="http://www.caveofprogramming.com/">Cave of Programming</a>.</p> <p>Until next time .... happy coding.<br />- John</p> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</em></p>