---
id: 54
title: Run, JUnit! Run!!!
date: 2013-12-06T14:30:00+00:00
author: Mite Mitreski
layout: post
guid: http://www.javaadvent.com/2013/12/run-junit-run/
permalink: /2013/12/run-junit-run.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Mite Mitreski
blogger_permalink:
  - /2013/12/run-junit-run.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/5567642331034124070
categories:
  - 2013
  - java
  - junit
  - parameters
  - rules
  - testing
---
JUnit together with JavaScript and SVN are some of the technologies that programmers often start using without even reading a single blog post let alone a book. &nbsp;Maybe this is a good thing since they look simple enough and understandable so we can use them right away without any manuals, but this also means that they are also underused. In this article we will go through some features of JUnit that I consider very useful.<br /><br /><h3>Parameterized tests&nbsp;</h3><div>Sometimes we need to run the same method or functionality with many different inputs and different expected results. One way to do this would be to create separate tests for each of the cases, or you</div>can use loop but that it would be harder to track down the origin of a possible test failure.<br /><br />For example if we have the following value object representing rational numbers:<br /><code><pre><br />public class RationalNumber {<br /><br />  private final long numerator;<br />  private final long denominator;<br /><br />  public RationalNumber(long numerator, long denominator) {<br />    this.numerator = numerator;<br />    this.denominator = denominator;<br />  }<br /><br />  public long getNumerator() {<br />    return numerator;<br />  }<br /><br />  public long getDenominator() {<br />    return denominator;<br />  }<br /><br />  @Override<br />  public String toString() {<br />    return String.format("%d/%d", numerator, denominator);<br />  }<br />}<br /></pre></code> And we have a service class called <i>App</i> with a method convert that divides the number to a rounded value of 5 decimal :<br /><code></code><br /><pre><code>public class App {<br /><br />  /**<br />   * THE Logic<br />   *<br />   * @param number some rational number<br />   * @return BigDecimal rounded to 5 decimal points<br />   */<br />  public static BigDecimal convert(RationalNumber number) {<br />    BigDecimal numerator = new BigDecimal(number.getNumerator()).<br />        setScale(5, RoundingMode.HALF_UP);<br /><br />    BigDecimal result = numerator.divide(<br />        new BigDecimal(number.getDenominator()),<br />        RoundingMode.HALF_UP);<br /><br />    return result;<br />  }<br />}<br /><br /></code></pre><code></code>And for the actual <i><b>AppTest</b></i> class we have<br /><code></code><br /><pre><code>@RunWith(Parameterized.class)<br />public class AppTest {<br /><br />  private RationalNumber input;<br />  private BigDecimal expected;<br /><br />  public AppTest(RationalNumber input, BigDecimal expected) {<br />    this.input = input;<br />    this.expected = expected;<br />  }<br /><br />  @Parameterized.Parameters(name = "{index}: number[{0}]= {1}")<br />  public static Collection&lt;Object&gt; data() {<br />    return Arrays.asList(new Object[][]{<br />      {new RationalNumber(1, 2), new BigDecimal("0.50000")},<br />      {new RationalNumber(1, 1), new BigDecimal("1.00000")},<br />      {new RationalNumber(1, 3), new BigDecimal("0.33333")},<br />      {new RationalNumber(1, 5), new BigDecimal("0.20000")},<br />      {new RationalNumber(10000, 3), new BigDecimal("3333.33333")}<br />    });<br />  }<br /><br />  @Test<br />  public void testApp() {<br />    //given the test data<br />    //when<br />    BigDecimal out = App.convert(input);<br />    //then<br />    Assert.assertThat(out, is(equalTo(expected)));<br />  }<br /><br />}<br /></code></pre><code></code><br /><br />The Parametrized runner or &nbsp;<i><b>@RunWith(Parameterized.class) </b></i>&nbsp;enables the "parametrization" or in other words the injection of the collection of values annotated with &nbsp;<i><b>@Parameterized.Parameters</b></i> into the Test constructor where each of the sublist is an parameter list. &nbsp;This means that each of the <i><b>RationalNumber</b></i> objects in the <i><b>data()</b></i> method will be injected into the input variable and each of the BigDecimal values would be the expected value, so in our example we have 5 tests.<br /><br />There is also an optional custom naming of the generated test added in the annotation, so "<i><b>{index}: number[{0}]= {1}</b></i>" will be replaced with the appropriate parameters defined in the <b><i>data()</i></b> method and the <b>"{index}"</b> placeholder will be the test case index, like in the following image<br /><br /><table align="center" cellpadding="0" cellspacing="0" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-9ntNAuHHzIM/UqEZz0Iik0I/AAAAAAAAEzw/M7ttu-k58sY/s1600/service.png" style="margin-left: auto; margin-right: auto;"><img border="0" height="176" src="http://2.bp.blogspot.com/-9ntNAuHHzIM/UqEZz0Iik0I/AAAAAAAAEzw/M7ttu-k58sY/s640/service.png" width="640" /></a></td></tr><tr><td style="text-align: center;">Running the parametrized tests in IntelliJ Idea&nbsp;</td></tr></tbody></table><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><h3><b>JUnit rules</b></h3>The simplest definition of JUnit rules is that they are in a sense an interceptors &nbsp;and very similar to the Spring aspect oriented programming or Java EE interceptors API. Basically you can do useful things before and after the test execution. <br />OK so let's start with some of the built in test rules. One of them is&nbsp;<b><i>ExternalResource</i></b> &nbsp;where the idea is that we setup an external resource and after the teardown garteet the resource was freed up. A classic example of such test is a creation of file, so for that purpose we have a built in class <b>TemporaryFolder</b>&nbsp;but we can also create our own ones for other resources :<br /><br /><br /><pre><code><br />  public class TheRuleTest {<br />  @Rule<br />  public TemporaryFolder folder = new TemporaryFolder();<br /><br />  @Test<br />  public void someTest() throws IOException {<br />    //given<br />    final File tempFile = folder.newFile("thefile.txt");<br />    //when<br />    tempFile.setExecutable(true)  ;<br />    //then<br />    assertThat(tempFile.canExecute(), is(true));<br />  }<br />}<br /><br /></code></pre>We could have done this in a <b>@Before</b> and <b>@After </b>blocks and use <a href="http://blog.mitemitreski.com/2012/11/temporary-directories-in-java-7-and.html#.UqEqkB9OVCI">java temp files</a> but it is easy to forget something and leave some of the files unclosed in some of the scenarios where a test fails.<br /><br />For example there is also a Timeout rule for methods where if the the execution is not finished in given time limit the test will fail with a Timeout exception. For example to limit the running for 20 milliseconds :<br />&nbsp; &nbsp;<br /><code><pre><br />@Rule<br />public MethodRule globalTimeout = new Timeout(20);<br /></pre></code><br />We can implement our own rules that can do a policy enforcement or various project specific changes. The only thing that needs to be done is for us to implement the TestRule interface.<br />A simple scenario to explain the behaviour is to add a rule that prints someting before and after test.<br /><br /><code><pre><br />import org.junit.rules.TestRule;<br /><br />import org.junit.runner.Description;<br />import org.junit.runners.model.Statement;<br /><br />public class MyTestRule implements TestRule {<br /><br />  public class MyStatement extends Statement {<br /><br />    private final Statement statement;<br /><br />    public MyStatement(Statement statement) {<br />      this.statement = statement;<br />    }<br /><br />    @Override<br />    public void evaluate() throws Throwable {<br />      System.out.println("before statement" );<br />      statement.evaluate();<br />      System.out.println("after statement");<br />    }<br /><br />  }<br /><br />  @Override<br />  public Statement apply(Statement statement,<br />                         Description description) {<br /><br />    System.out.println("apply rule");<br />    return new MyStatement(statement);<br />  }<br /><br />}<br /></pre></code><br />So now that we have our rule we can use it in tests, were the tests will just print out different values :<br /><pre><code><br />public class SomeTest {<br /><br />  @Rule<br />  public MyTestRule folder = new MyTestRule();<br /><br />  @Test<br />  public void testA()  {<br />    System.out.println("A");<br />  }<br /><br />  @Test<br />  public void testB()  {<br />    System.out.println("B");<br />  }<br />}<br /></code></pre>When we run a test the following output will be created on the &nbsp;console output :<br /><pre><code><br />apply rule<br />before statement<br />A<br />after statement<br />apply rule<br />before statement<br />B<br />after statement</code></pre>From the  built in one there is one called <b><i>ExpectedException</i></b> that can very useful when trying out testing errors. Additionally there is an option to chain the rules that can be useful in many scenarios.<br /><br /><div><h3>To sum up</h3>If you wanna say that <a href="https://code.google.com/p/spock/">Spock</a> or <a href="http://testng.org/">TestNG</a> or some library build on top of JUnit have more features than JUnit, than that is probably true.<br />But you know what? We don't always have those on our class path and chances are that JUnit is there and already used all over the place. Than why not use it's full potential ?<br /><h4><br />Useful links</h4><ul><li>Restrictions and details about parametrized tests as well as indexing of attributes and removing the constructor - <a href="https://github.com/junit-team/junit/wiki/Parameterized-tests">https://github.com/junit-team/junit/wiki/Parameterized-tests</a></li><li>JUnit Rules -&nbsp;<a href="https://github.com/junit-team/junit/wiki/Rules">https://github.com/junit-team/junit/wiki/Rules</a></li><li>Devoxx talk on JUnit Rules&nbsp;<a href="http://www.devoxx.com/display/DV12/JUnit+Rules">http://www.devoxx.com/display/DV12/JUnit+Rules</a></li><li>TestNP parameters&nbsp;<a href="http://testng.org/doc/documentation-main.html#parameters">http://testng.org/doc/documentation-main.html#parameters</a></li><li>Mixing it up with Spring Runner&nbsp;<a href="http://java.dzone.com/articles/writing-parameterized-tests">http://java.dzone.com/articles/writing-parameterized-tests</a></li></ul><br /><br /><br /></div> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></p>