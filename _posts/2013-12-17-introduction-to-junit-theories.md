---
id: 43
title: Introduction To JUnit Theories
date: 2013-12-17T08:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/introduction-to-junit-theories/
permalink: /2013/12/introduction-to-junit-theories.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Jens Schauder
blogger_permalink:
  - /2013/12/introduction-to-junit-theories.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/2645787553072710207
dsq_thread_id:
  - 4962579289
categories:
  - 2013
  - junit
  - testing
---
Have you ever read a mathematical theory?<br /><br />It typically reads something like this:<br /><br /><i>For all a, b &gt; 0 &nbsp;the following is true: a+b &gt; a and a+b &gt; b</i><br /><br />Just typically the statements are more difficult to understand.<br /><br />There is something interesting about this kind of statement: It holds for EVERY element (or combination of elements) of a rather large (infinite in this case) set.<br /><br />Compare that to the statement a typical test makes:<br /> <pre style="border: solid thin gray;"><code><br /> @Test<br /> public void a_plus_b_is_greater_than_a_and_greater_than_b(){<br />   int a = 2;<br />   int b = 3;<br />   assertTrue(a + b &gt; a);<br />   assertTrue(a + b &gt; b);<br /> }<br /></code></pre><br />This is just a statement about a single element of the large set we talked about. Not very impressive. Of course we can fix that somewhat by looping over the test (or using <a href="https://github.com/junit-team/junit/wiki/Parameterized-tests">parameterized tests</a>):<br /><br /><pre style="border: solid thin gray;"><code><br /> @Test<br /> public void a_plus_b_is_greater_than_a_and_greater_than_b_multiple_values() {<br />    List&lt;Integer&gt; values = Arrays.asList(1, 2, 300, 400000);<br />    for (Integer a : values)<br />      for (Integer b : values) {<br />         assertTrue(a + b &gt; a);<br />         assertTrue(a + b &gt; b);<br />      }<br />    }<br /></code></pre><br />Of course this still only tests a few values, but it also became pretty ugly. We are using 9 lines of code to &nbsp;test what a mathematician writes in a single line! And the main point that this relation ship should hold for any value <span style="font-family: Courier New, Courier, monospace;">a,b</span> is completely lost in translation.<br /><br />But there is hope: <a href="https://github.com/junit-team/junit/wiki/Theories">JUnit Theories</a>. Let's see how the test looks like with that nifty tool:<br /><pre style="border: solid thin gray;"><code>import org.junit.experimental.theories.DataPoints;<br />import org.junit.experimental.theories.Theories;<br />import org.junit.experimental.theories.Theory;<br />import org.junit.runner.RunWith;<br /><br />import static org.junit.Assert.assertTrue;<br /><br />@RunWith(Theories.class)<br />public class AdditionWithTheoriesTest {<br /><br />  @DataPoints<br />  public static int[] positiveIntegers() {<br />       return new int[]{<br />                        1, 10, 1234567};<br />  }<br /><br />  @Theory<br />  public void a_plus_b_is_greater_than_a_and_greater_than_b(Integer a, Integer b) {<br />      assertTrue(a + b &gt; a);<br />      assertTrue(a + b &gt; b);<br />  }<br />}<br /></code></pre> With JUnit Theories the test gets split in two separate parts: a method providing data points i.e. values to be used for tests, and the theory itself. The theory looks almost like a test, but it has a different annotation (<span style="font-family: Courier New, Courier, monospace;">@Theory</span>) and it takes parameters. The theories in a class get executed with every possible combination of data points.<br /><br />This means that if we have more then one theory about our test subject we only have to declare the data points once. So let's add the following theory, which should be true for addition: <span style="font-family: Courier New, Courier, monospace;">a + b = b + a&nbsp;</span>So we add the following theory to our class<br />  @Theory  public void addition_is_commutative(Integer a, Integer b) {     assertTrue(a + b == b + a);  } </code></pre><span style="white-space: pre;"> </span><br />This works like a charm and one can start to see that this actually saves some code as well, because we don't duplicate the data points. But we only test with positive integers, while the commutative property should hold for all integers! Of course our first theory still only holds for positive numbers<br /><br />There is a solution for this as well: <span style="font-family: Courier New, Courier, monospace;"><a href="https://github.com/junit-team/junit/wiki/Assumptions-with-assume">Assume</a></span>. With assume you can check precondition for your theory. If it isn't true for a given parameter set, the theory gets skipped for that parameter set. So our test now looks like this:<br /><pre style="border: solid thin gray;"><code><br /> @RunWith(Theories.class)<br /> public class AdditionWithTheoriesTest {<br /><br />  @DataPoints<br />  public static int[] integers() {<br />     return new int[]{<br />                   -1, -10, -1234567,1, 10, 1234567};<br />  }<br /><br />  @Theory<br />  public void a_plus_b_is_greater_than_a_and_greater_than_b(Integer a, Integer b) {<br />     Assume.assumeTrue(a &gt;0 &amp;&amp; b &gt; 0 );<br />     assertTrue(a + b &gt; a);<br />     assertTrue(a + b &gt; b);<br />  }<br /><br />  @Theory<br />  public void addition_is_commutative(Integer a, Integer b) {<br />     assertTrue(a + b == b + a);<br />  }<br />}<br /></code></pre><br />This makes the tests nicely expressive.<br /><br />The separation of test data from test/theory implementation can have another positive effect apart from brevity: You might start to think about you test data independent of the actual stuff to test.<br /><br />Lets do just that. If you want to test a method that takes an integer argument, what integers would be likely to cause problems? This is my proposal:<br /><br /><pre style="border: solid thin gray;"><code><br />  @DataPoints<br />  public static int[] integers() {<br />     return new int[]{<br />                     0, -1, -10, -1234567,1, 10, 1234567, Integer.MAX_VALUE, Integer.MIN_VALUE};}<br /></code></pre> <br />Which of course causes a test failure in our example. If you add a positive integer to <span style="font-family: Courier New, Courier, monospace;">Integer.MAX_VALUE</span> you get an overflow! So we just learned that our theory in its current form is wrong! Yeah I know this is obvious, but have a look at the tests in your current project. Do all the tests that use Integers test with&nbsp;<span style="font-family: Courier New, Courier, monospace;">MIN_VALUE, MAX_VALUE, 0,</span> a positive and a negative value? Yeah, thought so.<br /><br />What about more complex objects? Strings? Dates? Collections? Or domain objects? With JUnit Theories you can setup test data generators once that create all the scenarios that are prone to create problems and then reuse those in all your tests using theories. It will make your tests more expressive and improve the probability of finding bugs.<br /><br />