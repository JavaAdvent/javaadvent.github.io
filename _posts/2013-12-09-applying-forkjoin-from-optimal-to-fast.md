---
id: 51
title: 'Applying ForkJoin &#8211; from optimal to fast'
date: 2013-12-09T07:39:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2013/12/applying-forkjoin-from-optimal-to-fast/
permalink: /2013/12/applying-forkjoin-from-optimal-to-fast.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Florin Bunau
blogger_permalink:
  - /2013/12/applying-forkjoin-from-optimal-to-fast.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/1886956341342052565
categories:
  - 2013
  - fork
  - High performance
  - java
  - jdk 7
  - join
  - parallel
---
<div dir="ltr" style="text-align: left;" > <p>JDK 7 is well into the hands of developers by now and most people have heard of ForkJoin, yet not so many have the time or chance in daily work to try it.</p> <p>It caused, and probably still causes a bit of confusion on how is it any different than a normal thread pool.<a href="http://stackoverflow.com/questions/7926864/how-is-the-fork-join-framework-better-than-a-thread-pool">[1]</a> </p> <p>My goal in this article is to present a more elaborate, yet still simple example of ForkJoin usage through a code example.</p><p>I time and measure the performance of a <b>Serial</b> vs a <b>Thread pool</b> vs a <b>ForkJoin</b> aproach.</p><p>Here is the github upfront : <a href="https://github.com/fbunau/javaadvent-forkjoin">https://github.com/fbunau/javaadvent-forkjoin</a> </p> <h3>Practical problem</h3> </p>Imagine we have some sort of component in our system that keeps the last price of a stock for every millisecond of time. </p> <p>This could be held in memory as an array of integers. (if we count in bps) </p> <p>The clients of this component make queries like : what is the moment of time between <b>time1</b> and <b>time2</b> when the price was the lowest?</p> <p>This could either be an automated algorithm or just someone in a GUI making rectangle selections.</p> <p><div style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-sta_ywgWP2k/UqRlw41cHkI/AAAAAAAADZI/yyynzjsj5xQ/s1600/stock_chart2.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-sta_ywgWP2k/UqRlw41cHkI/AAAAAAAADZI/yyynzjsj5xQ/s640/stock_chart2.png" /></a></div></p> <p><i>7 queries in the example image</i></p> <p>Let us also imagine that we get many such queries from a client batched up in a Task.</p> <p>They may be batched up for reducing network traffic and round trip time. <br/>We have different sizes of tasks that the component might get, up to 10 queries (someone with a GUI), up to 100, .. up to 1 000 0000 (some automated algorithm). We have many such clients for the component each producing tasks of different sizes. See  <code>Task.TaskType</code></p> <h3>Core problem and solution</h3> <p>The problem at it's core we have to solve is the <b>RMQ</b> problem. Here is Wikipedia on it <a href="http://en.wikipedia.org/wiki/Range_Minimum_Query">[2]</a>: </p> <p>"Given an array of objects taken from a well-ordered set (such as numbers), a Range Minimum Query (or RMQ) from <code>i</code> to <code>j</code> asks for the position of a minimum element in the sub-array <code>A[i, j]</code>."</p> <p>"For example, <code>A = [0, 5, 2, 5, 4, 3, 1, 6, 3]</code> when , then the answer to the range minimum query for the <code>A[3, 8] = [2, 5, 4, 3, 1, 6]</code>  is <code>7</code>, as <code>A[7] = 1</code>  ."</p> <p>There exists an efficient datastructure for solving this problem called “Segment Tree”. </p> <p>I won't go into detail on this as it is excellently covered in this classic Topcoder article <a href="http://www.topcoder.com/tc?d1=tutorials&amp;d2=lowestCommonAncestor&amp;module=Static">[3]</a>. This in itself is not important for this ForkJoin example, I have chosen this because it's more interesting than a simple sum and it's essence is kind of in the spirit of fork-join. It divides the task to be computed and then it join the results! </p> <p>The data structure has <code><b>O(n)</b></code> initialization time and <code><b>O(log N)</b></code> query time, where N is the number of elements in our price per time unit value array. <br />So a task <code><b>T</b></code> contains <code><b>M</b></code> such queries to be made.</p> <p>In an academic Computer Science approach you would just say that we'll process each task with this efficient data structure and the complexity will be : </p> <p><div style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-aUrZMACzG5Q/UqRqN7fDSVI/AAAAAAAADZU/MO5laRHCImc/s1600/formula.png" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-aUrZMACzG5Q/UqRqN7fDSVI/AAAAAAAADZU/MO5laRHCImc/s200/formula.png" /></a></div> You can't get more efficient than that !? Yes, in a theoretical von Neumann machine, but you can in practice.  </p> <p>An easy confusion to make is that because <code>O(n/4) == O(n)</code>, then when writing a program constant factors don't count, but they do! <br />Stop and think, is it the same to wait 10 or 40 minutes / hours / years ?  </p> <h3>Going parallel</h3> <p>So thinking on the problem to be solved, how can we make it faster? Since every computing device  now has more cores for computations, let's put them to good use and do more things at once.<br />We can easily do that using the Fork Join framework.</p> <p>I was first tempted to tweek the RMQ data structure and execute it's operations in parallel. I attacked something that was already log N. But it was a big failure, it's too much overhead for the scheduler to micromanage such short running logic.</p><p>The answer was in the end attack the <code>M_i</code> constant factor.</p> <h3>Thread pool</h3> <p>Before presenting how a ForkJoin solution might be applied, let's imagine how we might apply a thread pool. See : <a href="https://github.com/fbunau/javaadvent-forkjoin/blob/master/src/com/javaadvent/dec9/processor/TaskProcessorPool.java">TaskProcessorPool.java</a></p> <div style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Jdcdy5lEEH0/UqSeN1JUdQI/AAAAAAAADZs/Zf8W0TJMf1o/s1600/graphic2.png" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-Jdcdy5lEEH0/UqSeN1JUdQI/AAAAAAAADZs/Zf8W0TJMf1o/s200/graphic2.png" /></a></div><p>We can have a pool of 4 workers, when we have a Task to do, we add it to the queue. As soon as a worker is available, it will retrieve  from the head of the queue a pending task, and execute it. </p> <p>While this is fine for tasks having the same size, and the size is relatively medium and predictable, it runs into problems when the tasks to be executed are of different sizes. One worker might be choked up with a long running task, and the others sit doing nothing.</p> <p><i>In this image the threadpool will do only 9 out of 16 possible units of work in the 4 units of time (56% efficiency), if no more tasks will be added to the queue</i></p> <h3>Fork Join</h3> <p>Fork join is useful when you are in a problem domain where you can split the task to be solved into smaller ones. </p> <p>What is special about a fork-join pool is that it is a work-stealing thread pool. </p><p>Each worker thread maintains a local dequeue of tasks. When taking a new task for execution it can either : </p> <ul><li>split the task into smaller ones</li><li>execute the task if it's small enough</li></ul> <p>When a thread has no local threads in it's dequeue, it 'steals' , pops tasks from the back of the queue of another random thread, and puts it in his own. There is a high chance that this task is not yet split. So he'll have quite some work on his hands.</p> <p>Comparing to the thread pool, instead of the other threads waiting for some new work, they could split the existing task into smaller ones and help the other thread with that large task.</p> <div style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-eKQKda2g1aw/UqSf2M_X6KI/AAAAAAAADZ4/L37vJWY3jD4/s1600/graphic1.png" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-eKQKda2g1aw/UqSf2M_X6KI/AAAAAAAADZ4/L37vJWY3jD4/s400/graphic1.png" /></a></div> <p>Here is the original paper by Doug Lea for a more detailed explanation :  <a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">http://gee.cs.oswego.edu/dl/papers/fj.pdf</a> </p> <p>Coming back to our example a large batch of operations could be split into multiple batches of  smaller number of operations. See : <a href="https://github.com/fbunau/javaadvent-forkjoin/blob/master/src/com/javaadvent/dec9/processor/TaskProcessorFJ.java">TaskProcessorFJ.java</a></p> <p>Most problems have linear series of operations like this one, it doesn't have to be a special parallel problem for which we need to apply a specialized parallel algorithm to leverage the cores we have on the processor.</p> <p>How much do you split? You split a task until you reach a threshold where generally splitting makes no sense anymore. Ex : ( splitting + a thread getting a job + context switching is more than actually executing the task as it is )</p> <p>For a big XXL, task we have to do 1000000 query operations. We could split this into 2  500000 operation tasks, and do that in parallel. Is  500000 still large? Yes, we can split it more. I have chosen a group of 10000 operations to be the threshold under which there is no use in splitting  and we can just execute them on the current thread.</p><p>Fork join does not split all the tasks upfront, but rather as it works through it.</p> <h3>Performance results</h3><p>I ran 4 iterations for each implementation of processor on my i5-2500 CPU @ 3.30GHz that has 4 cores / 4 threads, after a clean reboot<br />Here are the results : </p> <pre>Doing 4 runs for each of the 3 processors. Pls wait ...<br />TaskProcessorSimple: 7963<br />TaskProcessorSimple: 7757<br />TaskProcessorSimple: 7748<br />TaskProcessorSimple: 7744<br />TaskProcessorPool: 3933<br />TaskProcessorPool: 2906<br />TaskProcessorPool: 4477<br />TaskProcessorPool: 4160<br />TaskProcessorFJ: 2498<br />TaskProcessorFJ: 2498<br />TaskProcessorFJ: 2524<br />TaskProcessorFJ: 2511<br />Test completed.<br /></pre> <h3>Conclusions</h3> <p>Even if you have chosen the right optimal data structure, it's not fast until you use all the resources you have. i.e. exploiting all cores</p><p>ForkJoin is definetly an improvement over the thread pool in certain problem domains and it's worth exploring where it can be applied, and we'll get to see more and more parallel code. <br />This is the kind of <a href="http://ark.intel.com/products/75283/">processor</a> you can buy today 12 cores / 24 threads. Now we just have to write the software to exploit the cool hardware that we have and will get in the future.</p><p>The code is here : <a href="https://github.com/fbunau/javaadvent-forkjoin">https://github.com/fbunau/javaadvent-forkjoin</a> if you want to play with it</p> <p>Thanks for your time, drop some comments if you see any errors or have things to add.</p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on!</em></div>