---
id: 84
title: Integrating Bean Validation with JAX-RS in Java EE 6
date: 2012-12-05T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/integrating-bean-validation-with-jax-rs-in-java-ee-6/
permalink: /2012/12/integrating-bean-validation-with-jax-rs-in-java-ee-6.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Samuel Santos
blogger_permalink:
  - /2012/12/jax-rs-bean-validation-error-message-internationalization.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/6529418112799677517
categories:
  - 2012
  - Bean Validation
  - I18N
  - java
  - JAX-RS
---
<h3>Introduction to Bean Validation</h3> <blockquote cite="http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html">JavaBeans Validation (Bean Validation) is a new validation model available as part of Java EE 6 platform. The Bean Validation model is supported by constraints in the form of annotations placed on a field, method, or class of a JavaBeans component, such as a managed bean.</blockquote> <p>Several built-in constraints are available in the <code>javax.validation.constraints</code> package. <a href="http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html#gkagk" title="Built-In Bean Validation Constraints" target="_blank">The Java EE 6 Tutorial</a> lists all the built-in constraints.</p> <p>Constraints in Bean Validation are expressed via Java annotations:</p> <pre style="border: none;"><code><br />public class Person {<br />    @NotNull<br />    @Size(min = 2, max = 50)<br />    private String name;<br />    // ...<br />}<br /></code></pre> <h3>Bean Validation and RESTful web services</h3> <p>JAX-RS 1.0 provides great support for extracting request values and binding them into Java fields, properties and parameters using annotations such as <code>@HeaderParam</code>, <code>@QueryParam</code>, etc. It also supports binding of request entity bodies into Java objects via non-annotated parameters (i.e., parameters that are not annotated with any of the JAX-RS annotations). Currently, any additional validation on these values in a resource class must be performed programmatically.</p> <p>The next release, JAX-RS 2.0, includes a proposal to enable validation annotations to be combined with JAX-RS annotations. For example, given the validation annotation <code>@Pattern</code>, the following example shows how form parameters could be validated.</p> <pre style="border: none;"><code><br />@GET<br />@Path("{id}")<br />public Person getPerson(<br />        @PathParam("id")<br />        @Pattern(regexp = "[0-9]+", message = "The id must be a valid number")<br />        String id) {<br />    return persons.get(id);<br />}<br /></code></pre> <p>However, at the moment, the only solution is to use a proprietary implementation. What is presented next is a solution based on the <a href="http://www.jboss.org/resteasy" title="RESTEasy" target="_blank">RESTEasy</a> framework from JBoss that complies with the JAX-RS specification and adds a RESTful validation interface through the annotation <code>@ValidateRequest</code>.</p> <p>The exported interface allows us to create our own implementation. However, there is already one widely used and to which RESTEasy also provides a seamless integration. This implementation is <a href="http://www.hibernate.org/subprojects/validator.html" title="Hibernate Validator &amp; Bean Validation TCK" target="_blank">Hibernate Validator</a>.</p> <p>This provider can be added to the project through the following Maven dependencies:</p> <pre style="border: none;"><code><br />&lt;dependency><br />    &lt;groupId>org.jboss.resteasy&lt;/groupId><br />    &lt;artifactId>resteasy-jaxrs&lt;/artifactId><br />    &lt;version>2.3.2.Final&lt;/version><br />    &lt;scope>provided&lt;/scope><br />&lt;/dependency><br />&lt;dependency><br />    &lt;groupId>org.jboss.resteasy&lt;/groupId><br />    &lt;artifactId>resteasy-hibernatevalidator-provider&lt;/artifactId><br />    &lt;version>2.3.2.Final&lt;/version><br />&lt;/dependency><br /></code></pre> <p><strong>Note:</strong> without declaring the <code>@ValidateRequest</code> at class or method level, no validation will occur despite having applied constraint annotations on the methods, e.g. the example above.</p> <pre style="border: none;"><code><br />@GET<br />@Path("{id}")<br /><strong>@ValidateRequest</strong><br />public Person getPerson(<br />        @PathParam("id")<br />        @Pattern(regexp = "[0-9]+", message = "The id must be a valid number")<br />        String id) {<br />    return persons.get(id);<br />}<br /></code></pre> <p>After applying the annotation, the parameter <code>id</code> will be automatically validated when a request is made.<br />You can of course validate entire entities instead of single fields by using the annotation <code>@Valid</code>.<br />We could for example have one method that accepts a <code>Person</code> object and validates it.</p> <pre style="border: none;"><code><br />@POST<br />@Path("/validate")<br />@ValidateRequest<br />public Response validate(<strong>@Valid</strong> Person person) {<br />    // ...<br />}<br /></code></pre> <p><strong>Note:</strong> By default, when validation fails an exception is thrown by the container and a HTTP 500 status is returned to the client. This default behavior can/should be overridden, allowing us to customize the <code>Response</code> that is returned to the client through exception mappers.</p> <h3>Internationalization</h3> <p>Until now we have been using the default or hard-coded error messages, but this is both a bad practice and not flexible at all. I18N is part of the Bean Validation specification and allows us to specify custom error messages using a resource property file. The default resource file name is <code>ValidationMessages.properties</code> and must include pairs of properties/values like:</p> <pre style="border: none;"><code><br />person.id.pattern=The person id must be a valid number<br />person.name.size=The person name must be between {min} and {max} chars long<br /></code></pre> <p><strong>Note:</strong> <code>{min}</code>, <code>{max}</code> refer to properties of the constraint to which the message will be associated with.</p> <p>Those defined messages can then be injected on the validation constraints as:</p> <pre style="border: none;"><code><br />@POST<br />@Path("create")<br />@Consumes(MediaType.APPLICATION_FORM_URLENCODED)<br />public Response createPerson(<br />        @FormParam("id")<br />        @Pattern(regexp = "[0-9]+", message = "<strong>{person.id.pattern}</strong>")<br />        String id,<br />        @FormParam("name")<br />        @Size(min = 2, max = 50, message = "<strong>{person.name.size}</strong>")<br />        String name) {<br />    Person person = new Person();<br />    person.setId(Integer.valueOf(id));<br />    person.setName(name);<br />    persons.put(Integer.valueOf(id), person);<br />    return Response.status(Response.Status.CREATED).entity(person).build();<br />}<br /></code></pre> <p>To provide translations to other languages, one must create a new <code>ValidationMessages_XX.properties</code> file with the translated messages, where <code>XX</code> is the code of the language being provided.</p> <p>Unfortunately Hibernate Validator provider doesn't supports I18N based on a specific HTTP request. It does not take <code>Accept-Language</code> HTTP header into account and always uses the default <code>Locale</code> as provided by <code>Locale.getDefault()</code>. To be able to change the <code>Locale</code> using the <code>Accept-Language</code> HTTP header, a custom implementation must be provided.</p> <h4>Custom validator provider</h4> <p>The code below intends to address this issue and has been tested with <a href="http://www.jboss.org/jbossas/" title="JBoss Application Server" target="_blank">JBoss AS 7.1</a>.</p> <p>The first thing to do is to remove the Maven <code>resteasy-hibernatevalidator-provider</code> dependency, since we are providing our own provider, and add Hibernate Validator dependency:</p> <pre style="border: none;"><code><br />&lt;dependency><br />    &lt;groupId>org.hibernate&lt;/groupId><br />    &lt;artifactId>hibernate-validator&lt;/artifactId><br />    &lt;version>4.2.0.Final&lt;/version><br />&lt;/dependency><br /></code></pre> <p>Next create a custom message interpolator to adjust the default <code>Locale</code> used.</p> <pre style="border: none;"><code><br />public class LocaleAwareMessageInterpolator extends<br />        ResourceBundleMessageInterpolator {<br /><br />    private Locale defaultLocale = Locale.getDefault();<br /><br />    public void setDefaultLocale(Locale defaultLocale) {<br />        this.defaultLocale = defaultLocale;<br />    }<br /><br />    @Override<br />    public String interpolate(final String messageTemplate,<br />            final Context context) {<br />        return interpolate(messageTemplate, context, defaultLocale);<br />    }<br /><br />    @Override<br />    public String interpolate(final String messageTemplate,<br />            final Context context, final Locale locale) {<br />        return super.interpolate(messageTemplate, context, locale);<br />    }<br />}<br /></code></pre> <p>The next step is to provide a <code>ValidatorAdapter</code>. This interface was introduced to decouple RESTEasy from the real validation API.</p> <pre style="border: none;"><code><br />public class RESTValidatorAdapter implements ValidatorAdapter {<br /><br />    private final Validator validator;<br /><br />    private final MethodValidator methodValidator;<br /><br />    private final LocaleAwareMessageInterpolator interpolator = new LocaleAwareMessageInterpolator();<br /><br />    public RESTValidatorAdapter() {<br />        Configuration&lt;?> configuration = Validation.byDefaultProvider()<br />                .configure();<br />        this.validator = configuration.messageInterpolator(interpolator)<br />                .buildValidatorFactory().getValidator();<br />        this.methodValidator = validator.unwrap(MethodValidator.class);<br />    }<br /><br />    @Override<br />    public void applyValidation(Object resource, Method invokedMethod,<br />            Object[] args) {<br />        // For the i8n to work, the first parameter of the method being validated must be a HttpHeaders<br />        if ((args != null) && (args[0] instanceof HttpHeaders)) {<br />            HttpHeaders headers = (HttpHeaders) args[0];<br />            List&lt;Locale> acceptedLanguages = headers.getAcceptableLanguages();<br />            if ((acceptedLanguages != null) && (!acceptedLanguages.isEmpty())) {<br />                <strong>interpolator.setDefaultLocale(acceptedLanguages.get(0));</strong><br />            }<br />        }<br /><br />        ValidateRequest resourceValidateRequest = FindAnnotation<br />                .findAnnotation(invokedMethod.getDeclaringClass()<br />                        .getAnnotations(), ValidateRequest.class);<br /><br />        if (resourceValidateRequest != null) {<br />            Set&lt;ConstraintViolation&lt;?>> constraintViolations = new HashSet&lt;ConstraintViolation&lt;?>>(<br />                    validator.validate(resource,<br />                            resourceValidateRequest.groups()));<br /><br />            if (constraintViolations.size() > 0) {<br />                throw new ConstraintViolationException(constraintViolations);<br />            }<br />        }<br /><br />        ValidateRequest methodValidateRequest = FindAnnotation.findAnnotation(<br />                invokedMethod.getAnnotations(), ValidateRequest.class);<br />        DoNotValidateRequest doNotValidateRequest = FindAnnotation<br />                .findAnnotation(invokedMethod.getAnnotations(),<br />                        DoNotValidateRequest.class);<br /><br />        if ((resourceValidateRequest != null || methodValidateRequest != null)<br />                && doNotValidateRequest == null) {<br />            Set&lt;Class&lt;?>> set = new HashSet&lt;Class&lt;?>>();<br />            if (resourceValidateRequest != null) {<br />                for (Class&lt;?> group : resourceValidateRequest.groups()) {<br />                    set.add(group);<br />                }<br />            }<br /><br />            if (methodValidateRequest != null) {<br />                for (Class&lt;?> group : methodValidateRequest.groups()) {<br />                    set.add(group);<br />                }<br />            }<br /><br />            Set&lt;MethodConstraintViolation&lt;?>> constraintViolations = new HashSet&lt;MethodConstraintViolation&lt;?>>(<br />                    methodValidator.validateAllParameters(resource,<br />                            invokedMethod, args,<br />                            set.toArray(new Class&lt;?>[set.size()])));<br /><br />            if (constraintViolations.size() > 0) {<br />                throw new MethodConstraintViolationException(<br />                        constraintViolations);<br />            }<br />        }<br />    }<br />}<br /></code></pre> <p><strong>Warn:</strong> <code>@HttpHeaders</code> needs to be injected as the first parameter of the methods that are going to be validated:</p> <pre style="border: none;"><code><br />@POST<br />@Path("create")<br />@Consumes(MediaType.APPLICATION_FORM_URLENCODED)<br />public Response createPerson(<br />        <strong>@Context HttpHeaders headers,</strong><br />        @FormParam("id")<br />        @Pattern(regexp = "[0-9]+", message = "{person.id.pattern}")<br />        String id,<br />        @FormParam("name")<br />        @Size(min = 2, max = 50, message = "{person.name.size}")<br />        String name) {<br />    Person person = new Person();<br />    person.setId(Integer.valueOf(id));<br />    person.setName(name);<br />    persons.put(id, person);<br />    return Response.status(Response.Status.CREATED).entity(person).build();<br />}<br /></code></pre> <p>Finally, create the provider that will select the classes above to be used to validate Bean Validation constraints:</p> <pre style="border: none;"><code><br />@Provider<br />public class RESTValidatorContextResolver implements<br />        ContextResolver&lt;ValidatorAdapter> {<br /><br />    private static final RESTValidatorAdapter adapter = new RESTValidatorAdapter();<br /><br />    @Override<br />    public ValidatorAdapter getContext(Class&lt;?> type) {<br />        return adapter;<br />    }<br />}<br /></code></pre> <h3>Mapping Exceptions</h3> <p>The Bean Validation API reports error conditions using exceptions of type <code>javax.validation.ValidationException</code> or any of its subclasses. Applications can supply custom exception mapping providers for any exception. A JAX-RS implementation MUST always use the provider whose generic type is the nearest superclass of the exception, with application-defined providers taking precedence over built-in providers.</p> <p>The exception mapper may look like:</p> <pre style="border: none;"><code><br />@Provider<br />public class ValidationExceptionMapper implements<br />        ExceptionMapper&lt;MethodConstraintViolationException> {<br /><br />    @Override<br />    public Response toResponse(MethodConstraintViolationException ex) {<br />        Map&lt;String, String> errors = new HashMap&lt;String, String>();<br />        for (MethodConstraintViolation&lt;?> methodConstraintViolation : ex<br />                .getConstraintViolations()) {<br />            errors.put(methodConstraintViolation.getParameterName(),<br />                    methodConstraintViolation.getMessage());<br />        }<br />        return Response.status(Status.PRECONDITION_FAILED).entity(errors)<br />                .build();<br />    }<br />}<br /></code></pre> <p>The above example shows the implementation of an <code>ExceptionMapper</code> that maps exceptions of type <code>MethodConstraintViolationException</code>. This exception is thrown by Hibernate Validator implementation when the validation of one or more parameters of a method annotated with the <code>@ValidateRequest</code> fails. This ensures that the client receives a formatted response instead of just the exception being propagated from the resource.</p> <h3>Source code</h3> <p>The source code used for this post is available on <a href="https://github.com/samaxes/jaxrs-beanvalidation-javaee6" title="JAX-RS Bean Validation I18N" target="_blank">GitHub</a>.<br /><strong>Warn:</strong> make sure you change the resource property file name to have the file <code>ValidationMessages.properties</code> (i.e., without any suffix) to map to the <code>Locale</code> as returned by <code>Locale.getDefault()</code>.</p> <p style="text-align: center;">~~~</p> <p><em>Author: Samuel Santos is a Java and Open Source evangelist and a JUG leader of PT.JUG, the Portuguese Java User Group. He is the Technical Lead at <a href="http://www.present-technologies.com/">Present Technologies</a> in Coimbra, Portugal, where he is responsible for stimulating innovation, knowledge sharing, coaching and technology choices activities. Samuel is the author of the blog <a href="http://www.samaxes.com/">samaxes.com</a> and tweets as <a href="http://twitter.com/samaxes">@samaxes</a>.</em></p> <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</em></p>