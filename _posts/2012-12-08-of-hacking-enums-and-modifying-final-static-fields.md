---
id: 81
title: 'Of Hacking Enums and Modifying &#8220;final static&#8221; Fields'
date: 2012-12-08T09:00:00+00:00
author: gpanther
layout: post
guid: http://www.javaadvent.com/2012/12/of-hacking-enums-and-modifying-final-static-fields/
permalink: /2012/12/of-hacking-enums-and-modifying-final-static-fields.html
blogger_blog:
  - www.javaadvent.com
blogger_author:
  - Attila-Mihaly Balazs
blogger_permalink:
  - /2012/12/of-hacking-enums-and-modifying-final.html
blogger_internal:
  - /feeds/2481158163384033132/posts/default/2150732907048985544
categories:
  - 2012
---
<p>In this newsletter, originally published in The Java Specialists' Newsletter <a href="http://www.javaspecialists.eu/archive/Issue161.html">Issue 161</a> we examine how it is possible to create enum instances in the Sun JDK, by using the reflection classes from the sun.reflect package. This will obviously only work for Sun's JDK. If you need to do this on another JVM, you're on your own. </p><p>This all started with an email from Ken Dobson of Edinburgh, which pointed me in the direction of the <code>sun.reflect.ConstructorAccessor</code>, which he claimed could be used to construct enum instances. My <a href="http://www.javaspecialists.eu/archive/Issue141.html">previous approach (newsletter #141)</a> did not work in Java 6.  <p>I was curious why Ken wanted to construct enums. Here is how he wanted to use it: <pre><code><b>public enum </b>HumanState {<br />  HAPPY, SAD<br />}<br /><br /><b>public class </b>Human {<br />  <b>public void </b>sing(HumanState state) {<br />    <b>switch </b>(state) {<br />      <b>case </b>HAPPY:<br />        singHappySong();<br />        <b>break</b>;<br />      <b>case </b>SAD:<br />        singDirge();<br />        <b>break</b>;<br />      <b>default</b>:<br />         <b>new </b>IllegalStateException(<b>"Invalid State: "</b> + state);<br />    }<br />  }<br /><br />  <b>private void </b>singHappySong() {<br />    System.out.println(<b>"When you're happy and you know it ..."</b>);<br />  }<br /><br />  <b>private void </b>singDirge() {<br />    System.out.println(<b>"Don't cry for me Argentina, ..."</b>);<br />  }<br />}<br />  </code></pre><p>The above code needs a unit test. Did you spot the mistake? If you did not, go over the code again with a fine comb to try to find it. When I first saw this, I did not spot the mistake either.  <p>When we make bugs like this, the first thing we should do is produce a unit test that shows it. However, in this case we cannot cause the <code><b>default</b></code> case to happen, because the HumanState only has the HAPPY and SAD enums.  <p>Ken's discovery allowed us to make an instance of an enum by using the ConstructorAccessor class from the sun.reflect package. It would involve something like: <pre><code>Constructor cstr = clazz.getDeclaredConstructor(<br />  String.<b>class</b>, <b>int</b>.<b>class</b><br />);<br />ReflectionFactory reflection =<br />  ReflectionFactory.getReflectionFactory();<br />Enum e =<br />  reflection.newConstructorAccessor(cstr).newInstance(<b>"BLA"</b>,3);<br />  </code></pre><p>However, if we just do that, we end up with an ArrayIndexOutOfBoundsException, which makes sense when we see how the Java compiler converts the switch statement into byte code. Taking the above Human class, here is what is the decompiled code looks like (thanks to <a href="http://www.kpdus.com/jad.html">Pavel Kouznetsov's JAD</a>): <pre><code><b>public class</b> Human {<br />  <b>public void </b>sing(HumanState state) {<br />    <b>static class </b>_cls1 {<br />      <b>static final int </b>$SwitchMap$HumanState[] =<br />        <b>new int</b>[HumanState.values().length];<br />      <b>static </b>{<br />        <b>try </b>{<br />          $SwitchMap$HumanState[HumanState.HAPPY.ordinal()] = 1;<br />        } <b>catch</b>(NoSuchFieldError ex) { }<br />        <b>try </b>{<br />          $SwitchMap$HumanState[HumanState.SAD.ordinal()] = 2;<br />        } <b>catch</b>(NoSuchFieldError ex) { }<br />      }<br />    }<br /><br />    <b>switch</b>(_cls1.$SwitchMap$HumanState[state.ordinal()]) {<br />      <b>case </b>1:<br />        singHappySong();<br />        <b>break</b>;<br />      <b>case </b>2:<br />        singDirge();<br />        <b>break</b>;<br />      <b>default</b>:<br />        <b>new </b>IllegalStateException(<b>"Invalid State: "</b> + state);<br />        <b>break</b>;<br />    }<br />  }<br />  <b>private void </b>singHappySong() {<br />    System.out.println(<b>"When you're happy and you know it ..."</b>);<br />  }<br />  <b>private void </b>singDirge() {<br />    System.out.println(<b>"Don't cry for me Argentina, ..."</b>);<br />  }<br />}<br />  </code></pre><p>You can see immediately why we would get an ArrayIndexOutOfBoundsException, thanks to the inner class _cls1.  <p>My first attempt at fixing this problem did not result in a decent solution. I tried to modify the $VALUES array inside the HumanState enum. However, I just bounced off Java's protective code. You <a href="http://www.javaspecialists.eu/archive/Issue096.html">can modify final fields</a>, as long as they are non-static. This restriction seemed artificial to me, so I set off on a quest to discover the holy grail of static final fields. Again, it was hidden in the chamber of sun.reflect.  <h6>Setting "final static" Fields</h6><p>Several things are needed in order to set a <code><b>final static</b></code> field. First off, we need to get the Field object using normal reflection. If we passed this to the FieldAccessor, we will just bounce off the security code, since we are dealing with a static final field. <i>Secondly, we change the modifiers field value inside the Field object instance to not be final.</i> Thirdly, we pass the doctored field to the FieldAccessor in the sun.reflect package and use this to set it.  <p>Here is my ReflectionHelper class, which we can use to set <code><b>final static</b></code> fields via reflection: <pre><code><b>import </b>sun.reflect.*;<br /><b>import </b>java.lang.reflect.*;<br /><br /><b>public class </b>ReflectionHelper {<br />  <b>private static final </b>String MODIFIERS_FIELD = <b>"modifiers"</b>;<br /><br />  <b>private static final </b>ReflectionFactory reflection =<br />      ReflectionFactory.getReflectionFactory();<br /><br />  <b>public static void </b>setStaticFinalField(<br />      Field field, Object value)<br />      <b>throws </b>NoSuchFieldException, IllegalAccessException {<br />    // we mark the field to be public<br />    field.setAccessible(<b>true</b>);<br />    // next we change the modifier in the Field instance to<br />    // not be final anymore, thus tricking reflection into<br />    // letting us modify the static final field<br />    Field modifiersField =<br />        Field.class.getDeclaredField(MODIFIERS_FIELD);<br />    modifiersField.setAccessible(<b>true</b>);<br />    <b>int </b>modifiers = modifiersField.getInt(field);<br />    // blank out the final bit in the modifiers int<br />    modifiers &amp;= ~Modifier.FINAL;<br />    modifiersField.setInt(field, modifiers);<br />    FieldAccessor fa = reflection.newFieldAccessor(<br />        field, <b>false</b><br />    );<br />    fa.set(<b>null</b>, value);<br />  }<br />}<br />  </code></pre><p>With this ReflectionHelper, I could thus set the $VALUES array inside the enum to contain my new enum. This worked, except that I had to do this before the Human class was loaded for the first time. This would introduce a racing condition into our test cases. By themselves each test would work, but collectively they could fail. Not a good scenario!  <h6>Rewiring Enum Switches</h6><p>The next idea was to rewire the actual switch statement's $SwitchMap$HumanState field. It would be fairly easy to find this field inside the anonymous inner class. All you need is the prefix $SwitchMap$ followed by the enum class name. If the enum is switched several times in one class, then the inner class is only created once.  <p>One of the other solutions that I wrote yesterday did a check on whether our switch statement was dealing with all the possible cases. This would be useful in discovering bugs when a new type is introduced into the system. I discarded that particular solution, but you should be able to easily recreate that based on the EnumBuster that I will show you later.  <h6>The Memento Design Pattern</h6><p>I recently rewrote my <a href="http://www.javaspecialists.eu/courses/dpc.jsp">Design Patterns Course</a> (warning, the website might not have the up-to-date structure up yet - please enquire for more information), to take into account the changes in Java, to throw away some outdated patterns and to introduce some that I had excluded previously. One of the "new" patterns was the Memento, often used with undo functionality. I thought it would be a good pattern to use to undo the damage done to the enum in our great efforts to test our impossible case.  <p>Publishing a Specialists' newsletter gives me certain liberties. I do not have to explain every line that I write. So, without further ado, here is my EnumBuster class, which allows you to make enums, add them to the existing values[], delete enums from the array, whilst at the same time maintaining the switch statement of any class that you specify. <pre><code><b>import</b> sun.reflect.*;<br /><br /><b>import </b>java.lang.reflect.*;<br /><b>import </b>java.util.*;<br /><br /><b>public class </b>EnumBuster&lt;E <b>extends </b>Enum&lt;E&gt;&gt; {<br />  <b>private static final </b>Class[] EMPTY_CLASS_ARRAY =<br />      <b>new </b>Class[0];<br />  <b>private static final </b>Object[] EMPTY_OBJECT_ARRAY =<br />      <b>new </b>Object[0];<br /><br />  <b>private static final </b>String VALUES_FIELD = <b>"$VALUES"</b>;<br />  <b>private static final </b>String ORDINAL_FIELD = <b>"ordinal"</b>;<br /><br />  <b>private final </b>ReflectionFactory reflection =<br />      ReflectionFactory.getReflectionFactory();<br /><br />  <b>private final </b>Class&lt;E&gt; clazz;<br /><br />  <b>private final </b>Collection&lt;Field&gt; switchFields;<br /><br />  <b>private final </b>Deque&lt;Memento&gt; undoStack =<br />      <b>new </b>LinkedList&lt;Memento&gt;();<br /><br />  /**<br />   * Construct an EnumBuster for the given enum class and keep<br />   * the switch statements of the classes specified in<br />   * switchUsers in sync with the enum values.<br />   */<br />  <b>public </b>EnumBuster(Class&lt;E&gt; clazz, Class... switchUsers) {<br />    <b>try </b>{<br />      <b>this</b>.clazz = clazz;<br />      switchFields = findRelatedSwitchFields(switchUsers);<br />    } <b>catch </b>(Exception e) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not create the class"</b>, e);<br />    }<br />  }<br /><br />  /**<br />   * Make a new enum instance, without adding it to the values<br />   * array and using the default ordinal of 0.<br />   */<br />  <b>public </b>E make(String value) {<br />    <b>return </b>make(value, 0,<br />        EMPTY_CLASS_ARRAY, EMPTY_OBJECT_ARRAY);<br />  }<br /><br />  /**<br />   * Make a new enum instance with the given ordinal.<br />   */<br />  <b>public </b>E make(String value, <b>int </b>ordinal) {<br />    <b>return </b>make(value, ordinal,<br />        EMPTY_CLASS_ARRAY, EMPTY_OBJECT_ARRAY);<br />  }<br /><br />  /**<br />   * Make a new enum instance with the given value, ordinal and<br />   * additional parameters.  The additionalTypes is used to match<br />   * the constructor accurately.<br />   */<br />  <b>public </b>E make(String value, <b>int </b>ordinal,<br />                Class[] additionalTypes, Object[] additional) {<br />    <b>try </b>{<br />      undoStack.push(<b>new </b>Memento());<br />      ConstructorAccessor ca = findConstructorAccessor(<br />          additionalTypes, clazz);<br />      <b>return </b>constructEnum(clazz, ca, value,<br />          ordinal, additional);<br />    } <b>catch </b>(Exception e) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not create enum"</b>, e);<br />    }<br />  }<br /><br />  /**<br />   * This method adds the given enum into the array<br />   * inside the enum class.  If the enum already<br />   * contains that particular value, then the value<br />   * is overwritten with our enum.  Otherwise it is<br />   * added at the end of the array.<br />   *<br />   * In addition, if there is a constant field in the<br />   * enum class pointing to an enum with our value,<br />   * then we replace that with our enum instance.<br />   *<br />   * The ordinal is either set to the existing position<br />   * or to the last value.<br />   *<br />   * Warning: This should probably never be called,<br />   * since it can cause permanent changes to the enum<br />   * values.  Use only in extreme conditions.<br />   *<br />   * @param e the enum to add<br />   */<br />  <b>public void </b>addByValue(E e) {<br />    <b>try </b>{<br />      undoStack.push(<b>new </b>Memento());<br />      Field valuesField = findValuesField();<br /><br />      // we get the current Enum[]<br />      E[] values = values();<br />      <b>for </b>(<b>int </b>i = 0; i &lt; values.length; i++) {<br />        E value = values[i];<br />        <b>if </b>(<a href="http://value.name/">value.name</a>().equals(<a href="http://e.name/">e.name</a>())) {<br />          setOrdinal(e, value.ordinal());<br />          values[i] = e;<br />          replaceConstant(e);<br />          <b>return</b>;<br />        }<br />      }<br /><br />      // we did not find it in the existing array, thus<br />      // append it to the array<br />      E[] newValues =<br />          Arrays.copyOf(values, values.length + 1);<br />      newValues[newValues.length - 1] = e;<br />      ReflectionHelper.setStaticFinalField(<br />          valuesField, newValues);<br /><br />      <b>int </b>ordinal = newValues.length - 1;<br />      setOrdinal(e, ordinal);<br />      addSwitchCase();<br />    } <b>catch </b>(Exception ex) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not set the enum"</b>, ex);<br />    }<br />  }<br /><br />  /**<br />   * We delete the enum from the values array and set the<br />   * constant pointer to null.<br />   *<br />   * @param e the enum to delete from the type.<br />   * @return true if the enum was found and deleted;<br />   *         false otherwise<br />   */<br />  <b>public boolean </b>deleteByValue(E e) {<br />    <b>if </b>(e == <b>null</b>) <b>throw new </b>NullPointerException();<br />    <b>try </b>{<br />      undoStack.push(<b>new </b>Memento());<br />      // we get the current E[]<br />      E[] values = values();<br />      <b>for </b>(<b>int </b>i = 0; i &lt; values.length; i++) {<br />        E value = values[i];<br />        <b>if </b>(<a href="http://value.name/">value.name</a>().equals(<a href="http://e.name/">e.name</a>())) {<br />          E[] newValues =<br />              Arrays.copyOf(values, values.length - 1);<br />          System.arraycopy(values, i + 1, newValues, i,<br />              values.length - i - 1);<br />          <b>for </b>(<b>int </b>j = i; j &lt; newValues.length; j++) {<br />            setOrdinal(newValues[j], j);<br />          }<br />          Field valuesField = findValuesField();<br />          ReflectionHelper.setStaticFinalField(<br />              valuesField, newValues);<br />          removeSwitchCase(i);<br />          blankOutConstant(e);<br />          <b>return true</b>;<br />        }<br />      }<br />    } <b>catch </b>(Exception ex) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not set the enum"</b>, ex);<br />    }<br />    <b>return false</b>;<br />  }<br /><br />  /**<br />   * Undo the state right back to the beginning when the<br />   * EnumBuster was created.<br />   */<br />  <b>public void </b>restore() {<br />    <b>while </b>(undo()) {<br />      //<br />    }<br />  }<br /><br />  /**<br />   * Undo the previous operation.<br />   */<br />  <b>public boolean </b>undo() {<br />    <b>try </b>{<br />      Memento memento = undoStack.poll();<br />      <b>if </b>(memento == <b>null</b>) <b>return false</b>;<br />      memento.undo();<br />      <b>return true</b>;<br />    } <b>catch </b>(Exception e) {<br />      <b>throw new </b>IllegalStateException(<b>"Could not undo"</b>, e);<br />    }<br />  }<br /><br />  <b>private </b>ConstructorAccessor findConstructorAccessor(<br />      Class[] additionalParameterTypes,<br />      Class&lt;E&gt; clazz) <b>throws </b>NoSuchMethodException {<br />    Class[] parameterTypes =<br />        <b>new </b>Class[additionalParameterTypes.length + 2];<br />    parameterTypes[0] = String.<b>class</b>;<br />    parameterTypes[1] = <b>int</b>.<b>class</b>;<br />    System.arraycopy(<br />        additionalParameterTypes, 0,<br />        parameterTypes, 2,<br />        additionalParameterTypes.length);<br />    Constructor&lt;E&gt; cstr = clazz.getDeclaredConstructor(<br />        parameterTypes<br />    );<br />    <b>return </b>reflection.newConstructorAccessor(cstr);<br />  }<br /><br />  <b>private </b>E constructEnum(Class&lt;E&gt; clazz,<br />                          ConstructorAccessor ca,<br />                          String value, <b>int </b>ordinal,<br />                          Object[] additional)<br />      <b>throws </b>Exception {<br />    Object[] parms = <b>new </b>Object[additional.length + 2];<br />    parms[0] = value;<br />    parms[1] = ordinal;<br />    System.arraycopy(<br />        additional, 0, parms, 2, additional.length);<br />    <b>return </b>clazz.cast(ca.newInstance(parms));<br />  }<br /><br />  /**<br />   * The only time we ever add a new enum is at the end.<br />   * Thus all we need to do is expand the switch map arrays<br />   * by one empty slot.<br />   */<br />  <b>private void </b>addSwitchCase() {<br />    <b>try </b>{<br />      <b>for </b>(Field switchField : switchFields) {<br />        <b>int</b>[] switches = (<b>int</b>[]) switchField.get(<b>null</b>);<br />        switches = Arrays.copyOf(switches, switches.length + 1);<br />        ReflectionHelper.setStaticFinalField(<br />            switchField, switches<br />        );<br />      }<br />    } <b>catch </b>(Exception e) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not fix switch"</b>, e);<br />    }<br />  }<br /><br />  <b>private void </b>replaceConstant(E e)<br />      <b>throws </b>IllegalAccessException, NoSuchFieldException {<br />    Field[] fields = clazz.getDeclaredFields();<br />    <b>for </b>(Field field : fields) {<br />      <b>if </b>(field.getName().equals(<a href="http://e.name/">e.name</a>())) {<br />        ReflectionHelper.setStaticFinalField(<br />            field, e<br />        );<br />      }<br />    }<br />  }<br /><br /><br />  <b>private void </b>blankOutConstant(E e)<br />      <b>throws </b>IllegalAccessException, NoSuchFieldException {<br />    Field[] fields = clazz.getDeclaredFields();<br />    <b>for </b>(Field field : fields) {<br />      <b>if </b>(field.getName().equals(<a href="http://e.name/">e.name</a>())) {<br />        ReflectionHelper.setStaticFinalField(<br />            field, <b>null</b><br />        );<br />      }<br />    }<br />  }<br /><br />  <b>private void </b>setOrdinal(E e, <b>int </b>ordinal)<br />      <b>throws </b>NoSuchFieldException, IllegalAccessException {<br />    Field ordinalField = Enum.<b>class</b>.getDeclaredField(<br />        ORDINAL_FIELD);<br />    ordinalField.setAccessible(<b>true</b>);<br />    ordinalField.set(e, ordinal);<br />  }<br /><br />  /**<br />   * Method to find the values field, set it to be accessible,<br />   * and return it.<br />   *<br />   * @return the values array field for the enum.<br />   * @throws NoSuchFieldException if the field could not be found<br />   */<br />  <b>private </b>Field findValuesField()<br />      <b>throws </b>NoSuchFieldException {<br />    // first we find the static final array that holds<br />    // the values in the enum class<br />    Field valuesField = clazz.getDeclaredField(<br />        VALUES_FIELD);<br />    // we mark it to be public<br />    valuesField.setAccessible(<b>true</b>);<br />    <b>return </b>valuesField;<br />  }<br /><br />  <b>private </b>Collection&lt;Field&gt; findRelatedSwitchFields(<br />      Class[] switchUsers) {<br />    Collection&lt;Field&gt; result = <b>new </b>ArrayList&lt;Field&gt;();<br />    <b>try </b>{<br />      <b>for </b>(Class switchUser : switchUsers) {<br />        Class[] clazzes = switchUser.getDeclaredClasses();<br />        <b>for </b>(Class suspect : clazzes) {<br />          Field[] fields = suspect.getDeclaredFields();<br />          <b>for </b>(Field field : fields) {<br />            <b>if </b>(field.getName().startsWith(<b>"$SwitchMap$"</b> +<br />                clazz.getSimpleName())) {<br />              field.setAccessible(<b>true</b>);<br />              result.add(field);<br />            }<br />          }<br />        }<br />      }<br />    } <b>catch </b>(Exception e) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not fix switch"</b>, e);<br />    }<br />    <b>return </b> result;<br />  }<br /><br />  <b>private void </b>removeSwitchCase(<b>int </b>ordinal) {<br />    <b>try </b>{<br />      <b>for </b>(Field switchField : switchFields) {<br />        <b>int</b>[] switches = (<b>int</b>[]) switchField.get(null);<br />        <b>int</b>[] newSwitches = Arrays.copyOf(<br />            switches, switches.length - 1);<br />        System.arraycopy(switches, ordinal + 1, newSwitches,<br />            ordinal, switches.length - ordinal - 1);<br />        ReflectionHelper.setStaticFinalField(<br />            switchField, newSwitches<br />        );<br />      }<br />    } <b>catch </b>(Exception e) {<br />      <b>throw new </b>IllegalArgumentException(<br />          <b>"Could not fix switch"</b>, e);<br />    }<br />  }<br /><br />  <b>@SuppressWarnings</b>(<b>"unchecked"</b>)<br />  <b>private </b>E[] values()<br />      <b>throws </b>NoSuchFieldException, IllegalAccessException {<br />    Field valuesField = findValuesField();<br />    <b>return </b>(E[]) valuesField.get(<b>null</b>);<br />  }<br /><br />  <b>private class </b>Memento {<br />    <b>private final </b>E[] values;<br />    <b>private final </b>Map&lt;Field, <b>int</b>[]&gt; savedSwitchFieldValues =<br />        <b>new </b>HashMap&lt;Field, <b>int</b>[]&gt;();<br /><br />    <b>private </b>Memento() <b>throws </b>IllegalAccessException {<br />      <b>try </b>{<br />        values = values().clone();<br />        <b>for </b>(Field switchField : switchFields) {<br />          <b>int</b>[] switchArray = (<b>int</b>[]) switchField.get(null);<br />          savedSwitchFieldValues.put(switchField,<br />              switchArray.clone());<br />        }<br />      } <b>catch </b>(Exception e) {<br />        <b>throw new </b>IllegalArgumentException(<br />            <b>"Could not create the class"</b>, e);<br />      }<br />    }<br /><br />    <b>private void </b>undo() <b>throws</b><br />        NoSuchFieldException, IllegalAccessException {<br />      Field valuesField = findValuesField();<br />      ReflectionHelper.setStaticFinalField(valuesField, values);<br /><br />      <b>for </b>(<b>int </b>i = 0; i &lt; values.length; i++) {<br />        setOrdinal(values[i], i);<br />      }<br /><br />      // reset all of the constants defined inside the enum<br />      Map&lt;String, E&gt; valuesMap =<br />          <b>new </b>HashMap&lt;String, E&gt;();<br />      <b>for </b>(E e : values) {<br />        valuesMap.put(<a href="http://e.name/">e.name</a>(), e);<br />      }<br />      Field[] constantEnumFields = clazz.getDeclaredFields();<br />      <b>for </b>(Field constantEnumField : constantEnumFields) {<br />        E en = valuesMap.get(constantEnumField.getName());<br />        <b>if </b>(en != <b>null</b>) {<br />          ReflectionHelper.setStaticFinalField(<br />              constantEnumField, en<br />          );<br />        }<br />      }<br /><br />      <b>for </b>(Map.Entry&lt;Field, <b>int</b>[]&gt; entry :<br />          savedSwitchFieldValues.entrySet()) {<br />        Field field = entry.getKey();<br />        <b>int</b>[] mappings = entry.getValue();<br />        ReflectionHelper.setStaticFinalField(field, mappings);<br />      }<br />    }<br />  }<br />}<br />  </code></pre><p>The class is quite long and probably still has some bugs. I wrote it en route from San Francisco to New York. Here is how we could use it to test our Human class: <pre><code><b>import</b> junit.framework.TestCase;<br /><br /><b>public class </b>HumanTest <b>extends </b>TestCase {<br />  <b>public void </b>testSingingAddingEnum() {<br />    EnumBuster&lt;HumanState&gt; buster =<br />        <b>new </b>EnumBuster&lt;HumanState&gt;(HumanState.<b>class</b>,<br />            Human.<b>class</b>);<br /><br />    <b>try </b>{<br />      Human heinz = <b>new </b>Human();<br />      heinz.sing(HumanState.HAPPY);<br />      heinz.sing(HumanState.SAD);<br /><br />      HumanState MELLOW = buster.make(<b>"MELLOW"</b>);<br />      buster.addByValue(MELLOW);<br />      System.out.println(Arrays.toString(HumanState.values()));<br /><br />      <b>try </b>{<br />        heinz.sing(MELLOW);<br />        fail(<b>"Should have caused an IllegalStateException"</b>);<br />      }<br />      <b>catch </b>(IllegalStateException success) { }<br />    }<br />    <b>finally </b>{<br />      System.out.println(<b>"Restoring HumanState"</b>);<br />      buster.restore();<br />      System.out.println(Arrays.toString(HumanState.values()));<br />    }<br />  }<br />}<br />  </code></pre><p>This unit test now shows the mistake in our Human.java file, shown earlier. We forgot to add the <code><b>throw</b></code> keyword! <pre><code>When you're happy and you know it ...<br />Don't cry for me Argentina, ...<br />[HAPPY, SAD, MELLOW]<br />Restoring HumanState<br />[HAPPY, SAD]<br /><br />AssertionFailedError: Should have caused an IllegalStateException<br />  at HumanTest.testSingingAddingEnum(HumanTest.java:23)<br />  </code></pre><p>The EnumBuster class can do more than that. We can use it to delete enums that we don't want. If we specify which classes the switch statements are, then these will be maintained at the same time. Plus, we can undo right back to the initial state. Lots of functionality!  <p>One last test case before I sign off, where we add the test class to the switch classes to maintain. <pre><code><b>import</b> junit.framework.TestCase;<br /><br /><b>public class </b>EnumSwitchTest <b>extends </b>TestCase {<br />  <b>public void </b>testSingingDeletingEnum() {<br />    EnumBuster&lt;HumanState&gt; buster =<br />        <b>new </b>EnumBuster&lt;HumanState&gt;(HumanState.<b>class</b>,<br />            EnumSwitchTest.<b>class</b>);<br />    <b>try </b>{<br />      <b>for </b>(HumanState state : HumanState.values()) {<br />        <b>switch </b>(state) {<br />          <b>case </b>HAPPY:<br />          <b>case </b>SAD:<br />            <b>break</b>;<br />          <b>default</b>:<br />            fail(<b>"Unknown state"</b>);<br />        }<br />      }<br /><br />      buster.deleteByValue(HumanState.HAPPY);<br />      <b>for </b>(HumanState state : HumanState.values()) {<br />        <b>switch </b>(state) {<br />          <b>case </b>SAD:<br />            <b>break</b>;<br />          <b>case </b>HAPPY:<br />          <b>default</b>:<br />            fail(<b>"Unknown state"</b>);<br />        }<br />      }<br /><br />      buster.undo();<br />      buster.deleteByValue(HumanState.SAD);<br />      <b>for </b>(HumanState state : HumanState.values()) {<br />        <b>switch </b>(state) {<br />          <b>case </b>HAPPY:<br />            <b>break</b>;<br />          <b>case </b>SAD:<br />          <b>default</b>:<br />            fail(<b>"Unknown state"</b>);<br />        }<br />      }<br /><br />      buster.deleteByValue(HumanState.HAPPY);<br />      <b>for </b>(HumanState state : HumanState.values()) {<br />        <b>switch </b>(state) {<br />          <b>case </b>HAPPY:<br />          <b>case </b>SAD:<br />          <b>default</b>:<br />            fail(<b>"Unknown state"</b>);<br />        }<br />      }<br />    } <b>finally </b>{<br />      buster.restore();<br />    }<br />  }<br />}<br />  </code></pre><p>The EnumBuster even maintains the constants, so if you remove an enum from the values(), it will blank out the final static field. If you add it back, it will set it to the new value.  <p>It was thoroughly entertaining to use the ideas by Ken Dobson to play with reflection in a way that I did not know was possible. (Any Sun engineers reading this, please don't plug these holes in future versions of Java!)  <p>Kind regards  <p>Heinz</p> <p>JavaSpecialists offers all of the courses onsite at your company. <a href="http://www.javaspecialists.eu/courses/inhouse.jsp">More information ...</a><br />Be sure to check out our new course on <a href="http://www.javaspecialists.eu/courses/concurrency.jsp">Java concurrency</a>. Please contact me for more information.   <p>About Dr Heinz M. Kabutz <p>I have been writing for the Java specialist community since 2000. It's been fun.&nbsp; It's even more fun when you share this writing with someone you feel might enjoy it. And they can get it fresh each month if they head for <a href="http://www.javaspecialists.eu/">www.javaspecialists.eu</a> and add themselves to the list. </p>  <p><em>Meta: this post is part of the <a href="http://javaadvent.com/">Java Advent Calendar</a> and is licensed under the <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0 Attribution</a> license. If you like it, please spread the word by sharing, tweeting, FB, G+ and so on! Want to write for the blog? We are looking for contributors to fill all 24 slot and would love to have your contribution! <a href="mailto:dify.ltd@gmail.com">Contact Attila Balazs</a> to contribute!</em></p>